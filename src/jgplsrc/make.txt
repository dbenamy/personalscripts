cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o a.o a.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o ab.o ab.c
ab.c:91:1: warning: expression result unused [-Wunused-value]
BITWISE(jtbitwiserotate,UI,BWROT   )
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ab.c:78:6: note: expanded from macro 'BITWISE'
  RE(0); R z;                                                          \
     ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
ab.c:92:1: warning: expression result unused [-Wunused-value]
BITWISE(jtbitwiseshift, UI,BWSHIFT )
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ab.c:78:6: note: expanded from macro 'BITWISE'
  RE(0); R z;                                                          \
     ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
ab.c:93:1: warning: expression result unused [-Wunused-value]
BITWISE(jtbitwiseshifta,I, BWSHIFTA)
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ab.c:78:6: note: expanded from macro 'BITWISE'
  RE(0); R z;                                                          \
     ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
ab.c:98:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
static VF bwC[16]={bw0000CC,bw0001CC,bw0010CC,bw0011CC, bw0100CC,bw0101CC,bw0110CC,bw0111CC,
                   ^~~~~~~~
ab.c:98:29: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
static VF bwC[16]={bw0000CC,bw0001CC,bw0010CC,bw0011CC, bw0100CC,bw0101CC,bw0110CC,bw0111CC,
                            ^~~~~~~~
ab.c:98:38: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
static VF bwC[16]={bw0000CC,bw0001CC,bw0010CC,bw0011CC, bw0100CC,bw0101CC,bw0110CC,bw0111CC,
                                     ^~~~~~~~
ab.c:98:47: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
static VF bwC[16]={bw0000CC,bw0001CC,bw0010CC,bw0011CC, bw0100CC,bw0101CC,bw0110CC,bw0111CC,
                                              ^~~~~~~~
ab.c:98:57: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
static VF bwC[16]={bw0000CC,bw0001CC,bw0010CC,bw0011CC, bw0100CC,bw0101CC,bw0110CC,bw0111CC,
                                                        ^~~~~~~~
ab.c:98:66: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
static VF bwC[16]={bw0000CC,bw0001CC,bw0010CC,bw0011CC, bw0100CC,bw0101CC,bw0110CC,bw0111CC,
                                                                 ^~~~~~~~
ab.c:98:75: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
static VF bwC[16]={bw0000CC,bw0001CC,bw0010CC,bw0011CC, bw0100CC,bw0101CC,bw0110CC,bw0111CC,
                                                                          ^~~~~~~~
ab.c:98:84: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
static VF bwC[16]={bw0000CC,bw0001CC,bw0010CC,bw0011CC, bw0100CC,bw0101CC,bw0110CC,bw0111CC,
                                                                                   ^~~~~~~~
ab.c:99:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
                   bw1000CC,bw1001CC,bw1010CC,bw1011CC, bw1100CC,bw1101CC,bw1110CC,bw1111CC};
                   ^~~~~~~~
ab.c:99:29: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
                   bw1000CC,bw1001CC,bw1010CC,bw1011CC, bw1100CC,bw1101CC,bw1110CC,bw1111CC};
                            ^~~~~~~~
ab.c:99:38: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
                   bw1000CC,bw1001CC,bw1010CC,bw1011CC, bw1100CC,bw1101CC,bw1110CC,bw1111CC};
                                     ^~~~~~~~
ab.c:99:47: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
                   bw1000CC,bw1001CC,bw1010CC,bw1011CC, bw1100CC,bw1101CC,bw1110CC,bw1111CC};
                                              ^~~~~~~~
ab.c:99:57: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
                   bw1000CC,bw1001CC,bw1010CC,bw1011CC, bw1100CC,bw1101CC,bw1110CC,bw1111CC};
                                                        ^~~~~~~~
ab.c:99:66: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
                   bw1000CC,bw1001CC,bw1010CC,bw1011CC, bw1100CC,bw1101CC,bw1110CC,bw1111CC};
                                                                 ^~~~~~~~
ab.c:99:75: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
                   bw1000CC,bw1001CC,bw1010CC,bw1011CC, bw1100CC,bw1101CC,bw1110CC,bw1111CC};
                                                                          ^~~~~~~~
ab.c:99:84: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
                   bw1000CC,bw1001CC,bw1010CC,bw1011CC, bw1100CC,bw1101CC,bw1110CC,bw1111CC};
                                                                                   ^~~~~~~~
ab.c:101:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
static VF bwI[16]={bw0000II,bw0001II,bw0010II,bw0011II, bw0100II,bw0101II,bw0110II,bw0111II,
                   ^~~~~~~~
ab.c:101:29: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
static VF bwI[16]={bw0000II,bw0001II,bw0010II,bw0011II, bw0100II,bw0101II,bw0110II,bw0111II,
                            ^~~~~~~~
ab.c:101:38: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
static VF bwI[16]={bw0000II,bw0001II,bw0010II,bw0011II, bw0100II,bw0101II,bw0110II,bw0111II,
                                     ^~~~~~~~
ab.c:101:47: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
static VF bwI[16]={bw0000II,bw0001II,bw0010II,bw0011II, bw0100II,bw0101II,bw0110II,bw0111II,
                                              ^~~~~~~~
ab.c:101:57: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
static VF bwI[16]={bw0000II,bw0001II,bw0010II,bw0011II, bw0100II,bw0101II,bw0110II,bw0111II,
                                                        ^~~~~~~~
ab.c:101:66: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
static VF bwI[16]={bw0000II,bw0001II,bw0010II,bw0011II, bw0100II,bw0101II,bw0110II,bw0111II,
                                                                 ^~~~~~~~
ab.c:101:75: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
static VF bwI[16]={bw0000II,bw0001II,bw0010II,bw0011II, bw0100II,bw0101II,bw0110II,bw0111II,
                                                                          ^~~~~~~~
ab.c:101:84: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
static VF bwI[16]={bw0000II,bw0001II,bw0010II,bw0011II, bw0100II,bw0101II,bw0110II,bw0111II,
                                                                                   ^~~~~~~~
ab.c:102:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
                   bw1000II,bw1001II,bw1010II,bw1011II, bw1100II,bw1101II,bw1110II,bw1111II};
                   ^~~~~~~~
ab.c:102:29: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
                   bw1000II,bw1001II,bw1010II,bw1011II, bw1100II,bw1101II,bw1110II,bw1111II};
                            ^~~~~~~~
ab.c:102:38: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
                   bw1000II,bw1001II,bw1010II,bw1011II, bw1100II,bw1101II,bw1110II,bw1111II};
                                     ^~~~~~~~
ab.c:102:47: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
                   bw1000II,bw1001II,bw1010II,bw1011II, bw1100II,bw1101II,bw1110II,bw1111II};
                                              ^~~~~~~~
ab.c:102:57: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
                   bw1000II,bw1001II,bw1010II,bw1011II, bw1100II,bw1101II,bw1110II,bw1111II};
                                                        ^~~~~~~~
ab.c:102:66: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
                   bw1000II,bw1001II,bw1010II,bw1011II, bw1100II,bw1101II,bw1110II,bw1111II};
                                                                 ^~~~~~~~
ab.c:102:75: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
                   bw1000II,bw1001II,bw1010II,bw1011II, bw1100II,bw1101II,bw1110II,bw1111II};
                                                                          ^~~~~~~~
ab.c:102:84: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
                   bw1000II,bw1001II,bw1010II,bw1011II, bw1100II,bw1101II,bw1110II,bw1111II};
                                                                                   ^~~~~~~~
ab.c:131:26: warning: incompatible pointer types assigning to 'VF' (aka 'void (*)()') from 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 if     (i==0    ){c=j; f=bw0001II;}
                         ^~~~~~~~~
ab.c:132:26: warning: incompatible pointer types assigning to 'VF' (aka 'void (*)()') from 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 else if(j==i    ){c=i; f=bw0011II;}
                         ^~~~~~~~~
ab.c:133:26: warning: incompatible pointer types assigning to 'VF' (aka 'void (*)()') from 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 else if(j==255  ){c=i; f=bw0111II;}
                         ^~~~~~~~~
ab.c:134:26: warning: incompatible pointer types assigning to 'VF' (aka 'void (*)()') from 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 else if(j==255-i){c=i; f=bw0110II;}
                         ^~~~~~~~~
ab.c:135:26: warning: incompatible pointer types assigning to 'VF' (aka 'void (*)()') from 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 else if(j==0    ){c=i; f=bw0010II;}
                         ^~~~~~~~~
ab.c:136:26: warning: incompatible pointer types assigning to 'VF' (aka 'void (*)()') from 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 else if(i==255  ){c=j; f=bw1011II;}
                         ^~~~~~~~~
ab.c:159:12: warning: assigning to 'UC *' (aka 'unsigned char *') from 'C *' (aka 'char *') converts between pointers to integer types with different sign [-Wpointer-sign]
 m=wn/n; wv=CAV(w); j=i0(VAV(fs)->f)-16; f=bwinsC[j];
           ^~~~~~~
ab.c:169:30: warning: assigning to 'UC *' (aka 'unsigned char *') from 'C *' (aka 'char *') converts between pointers to integer types with different sign [-Wpointer-sign]
 GA(z,LIT,m,wr-1,1+AS(w)); zv=CAV(z);
                             ^~~~~~~
43 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o af.o af.c
af.c:25:9: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   if(hs=v->h){u=AAV(hs); DO(AN(hs), if(selfq(u[i]))R 1;);}
      ~~^~~~~
af.c:25:9: note: place parentheses around the assignment to silence this warning
   if(hs=v->h){u=AAV(hs); DO(AN(hs), if(selfq(u[i]))R 1;);}
        ^
      (      )
af.c:25:9: note: use '==' to turn this assignment into an equality comparison
   if(hs=v->h){u=AAV(hs); DO(AN(hs), if(selfq(u[i]))R 1;);}
        ^
        ==
af.c:73:9: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
    if(x=symbrdlock(f)){
       ~^~~~~~~~~~~~~~
af.c:73:9: note: place parentheses around the assignment to silence this warning
    if(x=symbrdlock(f)){
        ^
       (              )
af.c:73:9: note: use '==' to turn this assignment into an equality comparison
    if(x=symbrdlock(f)){
        ^
        ==
af.c:78:8: warning: expression result unused [-Wunused-value]
    RE(z);
       ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
3 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o ai.o ai.c
ai.c:18:22: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(c==CFCONS||c==CQQ&&(f=VAV(w)->f,NOUN&AT(f)))R 1;
             ~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~
ai.c:18:22: note: place parentheses around the '&&' expression to silence this warning
 if(c==CFCONS||c==CQQ&&(f=VAV(w)->f,NOUN&AT(f)))R 1;
                     ^
               (                               )
ai.c:254:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(s=strchr(invf[0],id))R ds(invf[1][s-invf[0]]);
    ~^~~~~~~~~~~~~~~~~~~
ai.c:254:6: note: place parentheses around the assignment to silence this warning
 if(s=strchr(invf[0],id))R ds(invf[1][s-invf[0]]);
     ^
    (                   )
ai.c:254:6: note: use '==' to turn this assignment into an equality comparison
 if(s=strchr(invf[0],id))R ds(invf[1][s-invf[0]]);
     ^
     ==
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o am.o am.c
am.c:73:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(q=2==m&&B01&AT(b)){bv=BAV(b); x=u[0]; y=u[1];}
    ~^~~~~~~~~~~~~~~~
am.c:73:6: note: place parentheses around the assignment to silence this warning
 if(q=2==m&&B01&AT(b)){bv=BAV(b); x=u[0]; y=u[1];}
     ^
    (                )
am.c:73:6: note: use '==' to turn this assignment into an equality comparison
 if(q=2==m&&B01&AT(b)){bv=BAV(b); x=u[0]; y=u[1];}
     ^
     ==
am.c:79:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(p=!q||0>c||1<AC(u[c]))GA(z,t,n,r,s) else z=u[c];
    ~^~~~~~~~~~~~~~~~~~~~
am.c:79:6: note: place parentheses around the assignment to silence this warning
 if(p=!q||0>c||1<AC(u[c]))GA(z,t,n,r,s) else z=u[c];
     ^
    (                    )
am.c:79:6: note: use '==' to turn this assignment into an equality comparison
 if(p=!q||0>c||1<AC(u[c]))GA(z,t,n,r,s) else z=u[c];
     ^
     ==
am.c:167:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(ip=ip&&t==wt&&t1!=BOX){ASSERT(!(AFRO&AFLAG(w)),EVRO); z=w;}else RZ(z=cvt(t1,w));
     ~~^~~~~~~~~~~~~~~~~~~
am.c:167:8: note: place parentheses around the assignment to silence this warning
  if(ip=ip&&t==wt&&t1!=BOX){ASSERT(!(AFRO&AFLAG(w)),EVRO); z=w;}else RZ(z=cvt(t1,w));
       ^
     (                    )
am.c:167:8: note: use '==' to turn this assignment into an equality comparison
  if(ip=ip&&t==wt&&t1!=BOX){ASSERT(!(AFRO&AFLAG(w)),EVRO); z=w;}else RZ(z=cvt(t1,w));
       ^
       ==
3 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o am1.o am1.c
am1.c:154:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(m=*AS(t)){  /* new cells being added */
    ~^~~~~~~
am1.c:154:6: note: place parentheses around the assignment to silence this warning
 if(m=*AS(t)){  /* new cells being added */
     ^
    (       )
am1.c:154:6: note: use '==' to turn this assignment into an equality comparison
 if(m=*AS(t)){  /* new cells being added */
     ^
     ==
1 warning generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o amn.o amn.c
amn.c:61:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(c=AN(a)-d){
    ~^~~~~~~~
amn.c:61:6: note: place parentheses around the assignment to silence this warning
 if(c=AN(a)-d){
     ^
    (        )
amn.c:61:6: note: use '==' to turn this assignment into an equality comparison
 if(c=AN(a)-d){
     ^
     ==
amn.c:63:7: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(m=*AS(p))RZ(p=stitch(repeat(sc(n),p),reshape(v2(n*m,c),p1)));
     ~^~~~~~~
amn.c:63:7: note: place parentheses around the assignment to silence this warning
  if(m=*AS(p))RZ(p=stitch(repeat(sc(n),p),reshape(v2(n*m,c),p1)));
      ^
     (       )
amn.c:63:7: note: use '==' to turn this assignment into an equality comparison
  if(m=*AS(p))RZ(p=stitch(repeat(sc(n),p),reshape(v2(n*m,c),p1)));
      ^
      ==
amn.c:69:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(m=*AS(p)){  /* new cells being added */
    ~^~~~~~~
amn.c:69:6: note: place parentheses around the assignment to silence this warning
 if(m=*AS(p)){  /* new cells being added */
     ^
    (       )
amn.c:69:6: note: use '==' to turn this assignment into an equality comparison
 if(m=*AS(p)){  /* new cells being added */
     ^
     ==
amn.c:134:30: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   q=1; while(p<m){DO(r, if(q=yv[i]-dv[i])break;); if(0<=q)break; ++p; yv+=r;}
                            ~^~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
amn.c:134:30: note: place parentheses around the assignment to silence this warning
   q=1; while(p<m){DO(r, if(q=yv[i]-dv[i])break;); if(0<=q)break; ++p; yv+=r;}
                             ^
                            (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
amn.c:134:30: note: use '==' to turn this assignment into an equality comparison
   q=1; while(p<m){DO(r, if(q=yv[i]-dv[i])break;); if(0<=q)break; ++p; yv+=r;}
                             ^
                             ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
4 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o ao.o ao.c
ao.c:71:25: warning: expression result unused [-Wunused-value]
 if(wt&FL+CMPX)NAN1; RE(0);
                        ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
ao.c:139:24: warning: expression result unused [-Wunused-value]
 if(t&FL+CMPX)NAN1; RE(0);
                       ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
ao.c:177:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(b=INT&AT(w)&&1==AR(w)){wv=AV(w); DO(AN(w), if(i!=*wv++){b=0; break;});}
    ~^~~~~~~~~~~~~~~~~~~~
ao.c:177:6: note: place parentheses around the assignment to silence this warning
 if(b=INT&AT(w)&&1==AR(w)){wv=AV(w); DO(AN(w), if(i!=*wv++){b=0; break;});}
     ^
    (                    )
ao.c:177:6: note: use '==' to turn this assignment into an equality comparison
 if(b=INT&AT(w)&&1==AR(w)){wv=AV(w); DO(AN(w), if(i!=*wv++){b=0; break;});}
     ^
     ==
ao.c:234:13: warning: '&&' within '||' [-Wlogical-op-parentheses]
     (wt&B01&&(d==CEQ||d==CPLUSDOT||d==CSTARDOT||d==CNE||d==CPLUS)||
      ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ao.c:234:13: note: place parentheses around the '&&' expression to silence this warning
     (wt&B01&&(d==CEQ||d==CPLUSDOT||d==CSTARDOT||d==CNE||d==CPLUS)||
            ^
      (                                                           )
ao.c:235:12: warning: '&&' within '||' [-Wlogical-op-parentheses]
     wt&INT&&(17<=d&&d<=25)||
     ~~~~~~^~~~~~~~~~~~~~~~
ao.c:235:12: note: place parentheses around the '&&' expression to silence this warning
     wt&INT&&(17<=d&&d<=25)||
           ^
     (                     )
ao.c:236:15: warning: '&&' within '||' [-Wlogical-op-parentheses]
     wt&INT+FL&&(d==CMIN||d==CMAX||d==CPLUS) )))R key(a,w,self);
     ~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ao.c:236:15: note: place parentheses around the '&&' expression to silence this warning
     wt&INT+FL&&(d==CMIN||d==CMAX||d==CPLUS) )))R key(a,w,self);
              ^
     (                                      )
ao.c:345:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(b=q&&(2>=k||q<=2*n)){
    ~^~~~~~~~~~~~~~~~~~
ao.c:345:6: note: place parentheses around the assignment to silence this warning
 if(b=q&&(2>=k||q<=2*n)){
     ^
    (                  )
ao.c:345:6: note: use '==' to turn this assignment into an equality comparison
 if(b=q&&(2>=k||q<=2*n)){
     ^
     ==
ao.c:489:40: warning: '&&' within '||' [-Wlogical-op-parentheses]
                if(d==CCOMMA&&(c==CHEAD&&e==CPOUND||c==CPOUND&&e==CHEAD))f2=jtkeyheadtally;
                               ~~~~~~~~^~~~~~~~~~~~~
ao.c:489:40: note: place parentheses around the '&&' expression to silence this warning
                if(d==CCOMMA&&(c==CHEAD&&e==CPOUND||c==CPOUND&&e==CHEAD))f2=jtkeyheadtally;
                               ~~~~~~~~^~~~~~~~~~~
ao.c:489:62: warning: '&&' within '||' [-Wlogical-op-parentheses]
                if(d==CCOMMA&&(c==CHEAD&&e==CPOUND||c==CPOUND&&e==CHEAD))f2=jtkeyheadtally;
                                                  ~~~~~~~~~~~^~~~~~~~~~
ao.c:489:62: note: place parentheses around the '&&' expression to silence this warning
                if(d==CCOMMA&&(c==CHEAD&&e==CPOUND||c==CPOUND&&e==CHEAD))f2=jtkeyheadtally;
                                                    ~~~~~~~~~^~~~~~~~~~
9 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o ap.o ap.c
ap.c:130:20: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(1==d)DO(m, if(v=memchr(x,p,n))*(z+(v-x))=p; z+=c; x+=c;)
                  ~^~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
ap.c:130:20: note: place parentheses around the assignment to silence this warning
 if(1==d)DO(m, if(v=memchr(x,p,n))*(z+(v-x))=p; z+=c; x+=c;)
                   ^
                  (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
ap.c:130:20: note: use '==' to turn this assignment into an equality comparison
 if(1==d)DO(m, if(v=memchr(x,p,n))*(z+(v-x))=p; z+=c; x+=c;)
                   ^
                   ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
ap.c:147:7: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(v=memchr(x,a,n)){
     ~^~~~~~~~~~~~~~
ap.c:147:7: note: place parentheses around the assignment to silence this warning
  if(v=memchr(x,a,n)){
      ^
     (              )
ap.c:147:7: note: use '==' to turn this assignment into an equality comparison
  if(v=memchr(x,a,n)){
      ^
      ==
ap.c:314:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(n=IC(x)){
    ~^~~~~~
ap.c:314:6: note: place parentheses around the assignment to silence this warning
 if(n=IC(x)){
     ^
    (      )
ap.c:314:6: note: use '==' to turn this assignment into an equality comparison
 if(n=IC(x)){
     ^
     ==
ap.c:339:29: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case 2: MC(x,y,n*k);  if(q=d*p-n)fillv(wt,q*c,x+n*k); break;
                           ~^~~~~~
ap.c:339:29: note: place parentheses around the assignment to silence this warning
  case 2: MC(x,y,n*k);  if(q=d*p-n)fillv(wt,q*c,x+n*k); break;
                            ^
                           (      )
ap.c:339:29: note: use '==' to turn this assignment into an equality comparison
  case 2: MC(x,y,n*k);  if(q=d*p-n)fillv(wt,q*c,x+n*k); break;
                            ^
                            ==
ap.c:340:29: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case 3: MCREL(x,y,n); if(q=d*p-n)fillv(wt,q*c,x+n*k); break;
                           ~^~~~~~
ap.c:340:29: note: place parentheses around the assignment to silence this warning
  case 3: MCREL(x,y,n); if(q=d*p-n)fillv(wt,q*c,x+n*k); break;
                            ^
                           (      )
ap.c:340:29: note: use '==' to turn this assignment into an equality comparison
  case 3: MCREL(x,y,n); if(q=d*p-n)fillv(wt,q*c,x+n*k); break;
                            ^
                            ==
5 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o ar.o ar.c
ar.c:32:5: warning: assigning to 'UI *' (aka 'unsigned long *') from 'I *' (aka 'long *') converts between pointers to integer types with different sign [-Wpointer-sign]
  xi=(I*)x; DO(n/SZI, s^=*xi++;); 
    ^~~~~~
ar.c:36:40: warning: assigning to 'B *' (aka 'char *') from 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
 }else if(0==n%sizeof(UI  ))VDONE(UI,  PARITYW)
                                       ^~~~~~~
ar.c:22:25: note: expanded from macro 'PARITYW'
#define PARITYW         PARITY4
                        ^~~~~~~
ar.c:16:26: note: expanded from macro 'PARITY4'
#define PARITY4         u=(UC*)&s; b=0; b^=*u++; b^=*u++; b^=*u++; b^=*u++; 
                         ^~~~~~~~
ar.c:27:61: note: expanded from macro 'VDONE'
 {I q=n/sizeof(T);T s,*y=(T*)x; DO(m, s=0; DO(q, s^=*y++;); PAR; *z++=b==pc;);}
                                                            ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
ar.c:37:40: warning: assigning to 'B *' (aka 'char *') from 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
 else  if(0==n%sizeof(UINT))VDONE(UINT,PARITY4)
                                       ^~~~~~~
ar.c:16:26: note: expanded from macro 'PARITY4'
#define PARITY4         u=(UC*)&s; b=0; b^=*u++; b^=*u++; b^=*u++; b^=*u++; 
                         ^~~~~~~~
ar.c:27:61: note: expanded from macro 'VDONE'
 {I q=n/sizeof(T);T s,*y=(T*)x; DO(m, s=0; DO(q, s^=*y++;); PAR; *z++=b==pc;);}
                                                            ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
ar.c:38:40: warning: assigning to 'B *' (aka 'char *') from 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
 else  if(0==n%sizeof(US  ))VDONE(US,  PARITY2)
                                       ^~~~~~~
ar.c:15:26: note: expanded from macro 'PARITY2'
#define PARITY2         u=(UC*)&s; b=0; b^=*u++; b^=*u++;
                         ^~~~~~~~
ar.c:27:61: note: expanded from macro 'VDONE'
 {I q=n/sizeof(T);T s,*y=(T*)x; DO(m, s=0; DO(q, s^=*y++;); PAR; *z++=b==pc;);}
                                                            ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
ar.c:235:39: warning: expression result unused [-Wunused-value]
 if(n){ado(jt,1L,n,n,AV(z),AV(x)); RE(0); if(m==n)R z;}
                                      ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
ar.c:260:33: warning: expression result unused [-Wunused-value]
 ado(jt,m,c,n,AV(zx),AV(x)); RE(0);
                                ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
ar.c:339:97: warning: expression result unused [-Wunused-value]
  if(1<n){if(qv){u=xxv; DO(n, MC(u,xv+xk*v[i],xk); u+=xk;);} ado(jt,1L,n*xc,n,zv,qv?xxv:xv); RE(0);}
                                                                                                ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
ar.c:408:35: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case BR2CASE(B01,CEQ     ): if(b=1==r)BTABIFX(==   ); break;
                                 ~^~~~~
ar.c:408:35: note: place parentheses around the assignment to silence this warning
  case BR2CASE(B01,CEQ     ): if(b=1==r)BTABIFX(==   ); break;
                                  ^
                                 (     )
ar.c:408:35: note: use '==' to turn this assignment into an equality comparison
  case BR2CASE(B01,CEQ     ): if(b=1==r)BTABIFX(==   ); break;
                                  ^
                                  ==
ar.c:409:35: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case BR2CASE(B01,CNE     ): if(b=1==r)BTABIFX(!=   ); break;
                                 ~^~~~~
ar.c:409:35: note: place parentheses around the assignment to silence this warning
  case BR2CASE(B01,CNE     ): if(b=1==r)BTABIFX(!=   ); break;
                                  ^
                                 (     )
ar.c:409:35: note: use '==' to turn this assignment into an equality comparison
  case BR2CASE(B01,CNE     ): if(b=1==r)BTABIFX(!=   ); break;
                                  ^
                                  ==
ar.c:410:35: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case BR2CASE(B01,CLT     ): if(b=1==r)BTABIFX(<    ); break;
                                 ~^~~~~
ar.c:410:35: note: place parentheses around the assignment to silence this warning
  case BR2CASE(B01,CLT     ): if(b=1==r)BTABIFX(<    ); break;
                                  ^
                                 (     )
ar.c:410:35: note: use '==' to turn this assignment into an equality comparison
  case BR2CASE(B01,CLT     ): if(b=1==r)BTABIFX(<    ); break;
                                  ^
                                  ==
ar.c:411:35: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case BR2CASE(B01,CLE     ): if(b=1==r)BTABIFX(<=   ); break;
                                 ~^~~~~
ar.c:411:35: note: place parentheses around the assignment to silence this warning
  case BR2CASE(B01,CLE     ): if(b=1==r)BTABIFX(<=   ); break;
                                  ^
                                 (     )
ar.c:411:35: note: use '==' to turn this assignment into an equality comparison
  case BR2CASE(B01,CLE     ): if(b=1==r)BTABIFX(<=   ); break;
                                  ^
                                  ==
ar.c:412:35: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case BR2CASE(B01,CGT     ): if(b=1==r)BTABIFX(>    ); break;
                                 ~^~~~~
ar.c:412:35: note: place parentheses around the assignment to silence this warning
  case BR2CASE(B01,CGT     ): if(b=1==r)BTABIFX(>    ); break;
                                  ^
                                 (     )
ar.c:412:35: note: use '==' to turn this assignment into an equality comparison
  case BR2CASE(B01,CGT     ): if(b=1==r)BTABIFX(>    ); break;
                                  ^
                                  ==
ar.c:413:35: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case BR2CASE(B01,CGE     ): if(b=1==r)BTABIFX(>=   ); break;
                                 ~^~~~~
ar.c:413:35: note: place parentheses around the assignment to silence this warning
  case BR2CASE(B01,CGE     ): if(b=1==r)BTABIFX(>=   ); break;
                                  ^
                                 (     )
ar.c:413:35: note: use '==' to turn this assignment into an equality comparison
  case BR2CASE(B01,CGE     ): if(b=1==r)BTABIFX(>=   ); break;
                                  ^
                                  ==
ar.c:415:35: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case BR2CASE(B01,CPLUSDOT): if(b=1==r)BTABIFX(||   ); break;
                                 ~^~~~~
ar.c:415:35: note: place parentheses around the assignment to silence this warning
  case BR2CASE(B01,CPLUSDOT): if(b=1==r)BTABIFX(||   ); break;
                                  ^
                                 (     )
ar.c:415:35: note: use '==' to turn this assignment into an equality comparison
  case BR2CASE(B01,CPLUSDOT): if(b=1==r)BTABIFX(||   ); break;
                                  ^
                                  ==
ar.c:416:35: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case BR2CASE(B01,CPLUSCO ): if(b=1==r)BTABPFX(BNOR ); break;
                                 ~^~~~~
ar.c:416:35: note: place parentheses around the assignment to silence this warning
  case BR2CASE(B01,CPLUSCO ): if(b=1==r)BTABPFX(BNOR ); break;
                                  ^
                                 (     )
ar.c:416:35: note: use '==' to turn this assignment into an equality comparison
  case BR2CASE(B01,CPLUSCO ): if(b=1==r)BTABPFX(BNOR ); break;
                                  ^
                                  ==
ar.c:419:35: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case BR2CASE(B01,CSTARDOT): if(b=1==r)BTABIFX(&&   ); break;
                                 ~^~~~~
ar.c:419:35: note: place parentheses around the assignment to silence this warning
  case BR2CASE(B01,CSTARDOT): if(b=1==r)BTABIFX(&&   ); break;
                                  ^
                                 (     )
ar.c:419:35: note: use '==' to turn this assignment into an equality comparison
  case BR2CASE(B01,CSTARDOT): if(b=1==r)BTABIFX(&&   ); break;
                                  ^
                                  ==
ar.c:420:35: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case BR2CASE(B01,CSTARCO ): if(b=1==r)BTABPFX(BNAND); break;
                                 ~^~~~~
ar.c:420:35: note: place parentheses around the assignment to silence this warning
  case BR2CASE(B01,CSTARCO ): if(b=1==r)BTABPFX(BNAND); break;
                                  ^
                                 (     )
ar.c:420:35: note: use '==' to turn this assignment into an equality comparison
  case BR2CASE(B01,CSTARCO ): if(b=1==r)BTABPFX(BNAND); break;
                                  ^
                                  ==
ar.c:612:5: warning: expression result unused [-Wunused-value]
 RE(0); R z;
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
18 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o as.o as.c
as.c:289:25: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(!(c==CPLUS||c==CBDOT&&t&INT||(c==CEQ||c==CNE)&&t&B01))R outfix(a,w,self);
              ~~~~~~~~~~^~~~~~~
as.c:289:25: note: place parentheses around the '&&' expression to silence this warning
 if(!(c==CPLUS||c==CBDOT&&t&INT||(c==CEQ||c==CNE)&&t&B01))R outfix(a,w,self);
                ~~~~~~~~^~~~~~~
as.c:289:50: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(!(c==CPLUS||c==CBDOT&&t&INT||(c==CEQ||c==CNE)&&t&B01))R outfix(a,w,self);
                               ~~~~~~~~~~~~~~~~~~^~~~~~~
as.c:289:50: note: place parentheses around the '&&' expression to silence this warning
 if(!(c==CPLUS||c==CBDOT&&t&INT||(c==CEQ||c==CNE)&&t&B01))R outfix(a,w,self);
                                 ~~~~~~~~~~~~~~~~^~~~~~~
as.c:298:32: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(k==IMIN||m<=c||id==CSTARDOT&&!(B01&AT(w)))R outfix(a,w,self);
                 ~~~~~~~~~~~~~~^~~~~~~~~~~~~~
as.c:298:32: note: place parentheses around the '&&' expression to silence this warning
 if(k==IMIN||m<=c||id==CSTARDOT&&!(B01&AT(w)))R outfix(a,w,self);
                               ^
                   (                         )
3 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o au.o au.c
au.c:19:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(f=v->f) d=VERB&AT(f)?fdep(f):NOUN&AT(f)&&VGERL&v->flag?fdepger(f):0;
    ~^~~~~
au.c:19:6: note: place parentheses around the assignment to silence this warning
 if(f=v->f) d=VERB&AT(f)?fdep(f):NOUN&AT(f)&&VGERL&v->flag?fdepger(f):0;
     ^
    (     )
au.c:19:6: note: use '==' to turn this assignment into an equality comparison
 if(f=v->f) d=VERB&AT(f)?fdep(f):NOUN&AT(f)&&VGERL&v->flag?fdepger(f):0;
     ^
     ==
au.c:20:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(g=v->g){k=VERB&AT(g)?fdep(g):NOUN&AT(g)&&VGERR&v->flag?fdepger(g):0; d=MAX(d,k);}
    ~^~~~~
au.c:20:6: note: place parentheses around the assignment to silence this warning
 if(g=v->g){k=VERB&AT(g)?fdep(g):NOUN&AT(g)&&VGERR&v->flag?fdepger(g):0; d=MAX(d,k);}
     ^
    (     )
au.c:20:6: note: use '==' to turn this assignment into an equality comparison
 if(g=v->g){k=VERB&AT(g)?fdep(g):NOUN&AT(g)&&VGERR&v->flag?fdepger(g):0; d=MAX(d,k);}
     ^
     ==
au.c:45:5: warning: expression result unused [-Wunused-value]
 RE(0);
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
3 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o c.o c.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o ca.o ca.c
ca.c:11:49: warning: add explicit braces to avoid dangling else [-Wdangling-else]
 if(primitive(gs))if(flag&VFLR)jt->xmode=XMFLR; else if(flag&VCEIL)jt->xmode=XMCEIL;
                                                ^
ca.c:20:49: warning: add explicit braces to avoid dangling else [-Wdangling-else]
 if(primitive(gs))if(flag&VFLR)jt->xmode=XMFLR; else if(flag&VCEIL)jt->xmode=XMCEIL;
                                                ^
ca.c:63:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(b=0>m)m=-m;
    ~^~~~
ca.c:63:6: note: place parentheses around the assignment to silence this warning
 if(b=0>m)m=-m;
     ^
    (    )
ca.c:63:6: note: use '==' to turn this assignment into an equality comparison
 if(b=0>m)m=-m;
     ^
     ==
ca.c:64:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(c=0>x)x=-x; x=x%m; if(c)x=m-x;
    ~^~~~
ca.c:64:6: note: place parentheses around the assignment to silence this warning
 if(c=0>x)x=-x; x=x%m; if(c)x=m-x;
     ^
    (    )
ca.c:64:6: note: use '==' to turn this assignment into an equality comparison
 if(c=0>x)x=-x; x=x%m; if(c)x=m-x;
     ^
     ==
ca.c:119:24: warning: '&&' within '||' [-Wlogical-op-parentheses]
   if((d==CEXP||d==CAMP&&CEXP==ID(wv->g))&&AT(x)&INT+XNUM&&!AR(x)&&CSTILE==ID(av->g)){
              ~~~~~~~~~^~~~~~~~~~~~~~~~~
ca.c:119:24: note: place parentheses around the '&&' expression to silence this warning
   if((d==CEXP||d==CAMP&&CEXP==ID(wv->g))&&AT(x)&INT+XNUM&&!AR(x)&&CSTILE==ID(av->g)){
                ~~~~~~~^~~~~~~~~~~~~~~~~
ca.c:209:9: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
    if(b=c==CFIT&&equ(zero,v->g))c=ID(v->f); 
       ~^~~~~~~~~~~~~~~~~~~~~~~~
ca.c:209:9: note: place parentheses around the assignment to silence this warning
    if(b=c==CFIT&&equ(zero,v->g))c=ID(v->f); 
        ^
       (                        )
ca.c:209:9: note: use '==' to turn this assignment into an equality comparison
    if(b=c==CFIT&&equ(zero,v->g))c=ID(v->f); 
        ^
        ==
ca.c:223:43: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
    v=VAV(a); c=v->id; p=v->flag%256; if(b=c==CFIT&&equ(zero,v->g))c=ID(v->f);
                                         ~^~~~~~~~~~~~~~~~~~~~~~~~
ca.c:223:43: note: place parentheses around the assignment to silence this warning
    v=VAV(a); c=v->id; p=v->flag%256; if(b=c==CFIT&&equ(zero,v->g))c=ID(v->f);
                                          ^
                                         (                        )
ca.c:223:43: note: use '==' to turn this assignment into an equality comparison
    v=VAV(a); c=v->id; p=v->flag%256; if(b=c==CFIT&&equ(zero,v->g))c=ID(v->f);
                                          ^
                                          ==
7 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o cc.o cc.c
cc.c:49:3: warning: add explicit braces to avoid dangling else [-Wdangling-else]
  else if(4>=AN(a)&&2==AR(w))R cut02m(a,w);
  ^
cc.c:496:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   if(u=memchr(v+pfx,sep,p-pfx))u+=!pfx; else{if(!pfx)break; u=v+p;}
      ~^~~~~~~~~~~~~~~~~~~~~~~~
cc.c:496:8: note: place parentheses around the assignment to silence this warning
   if(u=memchr(v+pfx,sep,p-pfx))u+=!pfx; else{if(!pfx)break; u=v+p;}
       ^
      (                        )
cc.c:496:8: note: use '==' to turn this assignment into an equality comparison
   if(u=memchr(v+pfx,sep,p-pfx))u+=!pfx; else{if(!pfx)break; u=v+p;}
       ^
       ==
cc.c:498:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   if(d=q-neg){
      ~^~~~~~
cc.c:498:8: note: place parentheses around the assignment to silence this warning
   if(d=q-neg){
       ^
      (      )
cc.c:498:8: note: use '==' to turn this assignment into an equality comparison
   if(d=q-neg){
       ^
       ==
cc.c:507:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   if(u=memchr(v+pfx,sep,p-pfx))u+=!pfx; else{if(!pfx)break; u=v+p;}
      ~^~~~~~~~~~~~~~~~~~~~~~~~
cc.c:507:8: note: place parentheses around the assignment to silence this warning
   if(u=memchr(v+pfx,sep,p-pfx))u+=!pfx; else{if(!pfx)break; u=v+p;}
       ^
      (                        )
cc.c:507:8: note: use '==' to turn this assignment into an equality comparison
   if(u=memchr(v+pfx,sep,p-pfx))u+=!pfx; else{if(!pfx)break; u=v+p;}
       ^
       ==
cc.c:597:5: warning: expression result unused [-Wunused-value]
 RE(0); R ope(z);
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
5 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o cd.o cd.c
cd.c:47:43: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(c==CPLUS||c==CMINUS||c==CSTAR||c==CDIV&&ng)R 2;
                                 ~~~~~~~~~^~~~
cd.c:47:43: note: place parentheses around the '&&' expression to silence this warning
 if(c==CPLUS||c==CMINUS||c==CSTAR||c==CDIV&&ng)R 2;
                                          ^
                                   (          )
cd.c:51:19: warning: '&&' within '||' [-Wlogical-op-parentheses]
 R 0<=k&&(c==CBANG&&nf||c==CEXP&&ng)?1+k:0;
          ~~~~~~~~^~~~~~
cd.c:51:19: note: place parentheses around the '&&' expression to silence this warning
 R 0<=k&&(c==CBANG&&nf||c==CEXP&&ng)?1+k:0;
                  ^
          (           )
cd.c:51:32: warning: '&&' within '||' [-Wlogical-op-parentheses]
 R 0<=k&&(c==CBANG&&nf||c==CEXP&&ng)?1+k:0;
                      ~~~~~~~~~^~~~
cd.c:51:32: note: place parentheses around the '&&' expression to silence this warning
 R 0<=k&&(c==CBANG&&nf||c==CEXP&&ng)?1+k:0;
                               ^
                        (          )
cd.c:203:17: warning: expression result unused [-Wunused-value]
    case  0: RE(0); R qq(one,zero);
                ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
cd.c:207:10: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
     if(q=ispoly(f)){RE(m=i0(vib(expn2(sc(q-1),g)))); R dpoly(df1(IX(1+m),tdot(w)));}
        ~^~~~~~~~~~
cd.c:207:10: note: place parentheses around the assignment to silence this warning
     if(q=ispoly(f)){RE(m=i0(vib(expn2(sc(q-1),g)))); R dpoly(df1(IX(1+m),tdot(w)));}
         ^
        (          )
cd.c:207:10: note: use '==' to turn this assignment into an equality comparison
     if(q=ispoly(f)){RE(m=i0(vib(expn2(sc(q-1),g)))); R dpoly(df1(IX(1+m),tdot(w)));}
         ^
         ==
cd.c:342:33: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 f=v->f; nf=f&&NOUN&AT(f); if(vf=f&&!nf)fv=VAV(f);
                              ~~^~~~~~~
cd.c:342:33: note: place parentheses around the assignment to silence this warning
 f=v->f; nf=f&&NOUN&AT(f); if(vf=f&&!nf)fv=VAV(f);
                                ^
                              (        )
cd.c:342:33: note: use '==' to turn this assignment into an equality comparison
 f=v->f; nf=f&&NOUN&AT(f); if(vf=f&&!nf)fv=VAV(f);
                                ^
                                ==
cd.c:343:33: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 g=v->g; ng=g&&NOUN&AT(g); if(vg=g&&!ng)gv=VAV(g);
                              ~~^~~~~~~
cd.c:343:33: note: place parentheses around the assignment to silence this warning
 g=v->g; ng=g&&NOUN&AT(g); if(vg=g&&!ng)gv=VAV(g);
                                ^
                              (        )
cd.c:343:33: note: use '==' to turn this assignment into an equality comparison
 g=v->g; ng=g&&NOUN&AT(g); if(vg=g&&!ng)gv=VAV(g);
                                ^
                                ==
cd.c:367:17: warning: expression result unused [-Wunused-value]
    case  0: RE(0); R ipoly(v2(0L,1L));
                ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
cd.c:371:10: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
     if(q=ispoly(f)){RE(m=i0(vib(expn2(sc(q-1),g)))); R ipoly(df1(IX(1+m),tdot(w)));}
        ~^~~~~~~~~~
cd.c:371:10: note: place parentheses around the assignment to silence this warning
     if(q=ispoly(f)){RE(m=i0(vib(expn2(sc(q-1),g)))); R ipoly(df1(IX(1+m),tdot(w)));}
         ^
        (          )
cd.c:371:10: note: use '==' to turn this assignment into an equality comparison
     if(q=ispoly(f)){RE(m=i0(vib(expn2(sc(q-1),g)))); R ipoly(df1(IX(1+m),tdot(w)));}
         ^
         ==
cd.c:463:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(z=diff0(w))R id==CQQ&&ng&&equ(g,zero)?z:icube(z);
    ~^~~~~~~~~
cd.c:463:6: note: place parentheses around the assignment to silence this warning
 if(z=diff0(w))R id==CQQ&&ng&&equ(g,zero)?z:icube(z);
     ^
    (         )
cd.c:463:6: note: use '==' to turn this assignment into an equality comparison
 if(z=diff0(w))R id==CQQ&&ng&&equ(g,zero)?z:icube(z);
     ^
     ==
cd.c:551:5: warning: expression result unused [-Wunused-value]
 RE(0); R ope(z);
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
11 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o cf.o cf.c
cf.c:36:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(f=atcompf(a,w,self))z=f(jt,a,w,self); else if(cap(fs))CAP2 else FOLK2;
    ~^~~~~~~~~~~~~~~~~~
cf.c:36:6: note: place parentheses around the assignment to silence this warning
 if(f=atcompf(a,w,self))z=f(jt,a,w,self); else if(cap(fs))CAP2 else FOLK2;
     ^
    (                  )
cf.c:36:6: note: use '==' to turn this assignment into an equality comparison
 if(f=atcompf(a,w,self))z=f(jt,a,w,self); else if(cap(fs))CAP2 else FOLK2;
     ^
     ==
cf.c:43:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(f=atcompf(a,w,self))z=f(jt,a,w,self); else if(cap(fs))CAP2 else FOLK2;
    ~^~~~~~~~~~~~~~~~~~
cf.c:43:6: note: place parentheses around the assignment to silence this warning
 if(f=atcompf(a,w,self))z=f(jt,a,w,self); else if(cap(fs))CAP2 else FOLK2;
     ^
    (                  )
cf.c:43:6: note: use '==' to turn this assignment into an equality comparison
 if(f=atcompf(a,w,self))z=f(jt,a,w,self); else if(cap(fs))CAP2 else FOLK2;
     ^
     ==
cf.c:128:54: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(INT&AT(w)&&1==AR(w)){n=AN(w); v=AV(w); DO(n, if(b=0>v[i])break;); if(!b)R odom(2L,n,v);}
                                                    ~^~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
cf.c:128:54: note: place parentheses around the assignment to silence this warning
 if(INT&AT(w)&&1==AR(w)){n=AN(w); v=AV(w); DO(n, if(b=0>v[i])break;); if(!b)R odom(2L,n,v);}
                                                     ^
                                                    (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
cf.c:128:54: note: use '==' to turn this assignment into an equality comparison
 if(INT&AT(w)&&1==AR(w)){n=AN(w); v=AV(w); DO(n, if(b=0>v[i])break;); if(!b)R odom(2L,n,v);}
                                                     ^
                                                     ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
cf.c:196:41: warning: '&&' within '||' [-Wlogical-op-parentheses]
   if(BOX&AT(w)&&(id==CGRAVE||id==CPOWOP&&1<AN(w)))flag=VGERR;
                            ~~~~~~~~~~~~^~~~~~~~~
cf.c:196:41: note: place parentheses around the '&&' expression to silence this warning
   if(BOX&AT(w)&&(id==CGRAVE||id==CPOWOP&&1<AN(w)))flag=VGERR;
                              ~~~~~~~~~~^~~~~~~~~
4 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o cg.o cg.c
cg.c:90:9: warning: '&&' within '||' [-Wlogical-op-parentheses]
   if(ax&&atomic(2,g)||ay&&atomic(2,f))R 1;
      ~~^~~~~~~~~~~~~~~
cg.c:90:9: note: place parentheses around the '&&' expression to silence this warning
   if(ax&&atomic(2,g)||ay&&atomic(2,f))R 1;
      ~~^~~~~~~~~~~~~
cg.c:90:26: warning: '&&' within '||' [-Wlogical-op-parentheses]
   if(ax&&atomic(2,g)||ay&&atomic(2,f))R 1;
                     ~~~~^~~~~~~~~~~~~
cg.c:90:26: note: place parentheses around the '&&' expression to silence this warning
   if(ax&&atomic(2,g)||ay&&atomic(2,f))R 1;
                       ~~^~~~~~~~~~~~~
cg.c:119:22: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  b=0; DO(AN(y), if(b=!AR(yv[i]))break;);
                    ~^~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
cg.c:119:22: note: place parentheses around the assignment to silence this warning
  b=0; DO(AN(y), if(b=!AR(yv[i]))break;);
                     ^
                    (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
cg.c:119:22: note: use '==' to turn this assignment into an equality comparison
  b=0; DO(AN(y), if(b=!AR(yv[i]))break;);
                     ^
                     ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
cg.c:141:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(b=!r&&wr&&AN(w)){h=sv->h; hv=AAV(h); DO(AN(h), if(!atomic(1,hv[i])){b=0; break;});}
    ~^~~~~~~~~~~~~~
cg.c:141:6: note: place parentheses around the assignment to silence this warning
 if(b=!r&&wr&&AN(w)){h=sv->h; hv=AAV(h); DO(AN(h), if(!atomic(1,hv[i])){b=0; break;});}
     ^
    (              )
cg.c:141:6: note: use '==' to turn this assignment into an equality comparison
 if(b=!r&&wr&&AN(w)){h=sv->h; hv=AAV(h); DO(AN(h), if(!atomic(1,hv[i])){b=0; break;});}
     ^
     ==
4 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o ch.o ch.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o cip.o cip.c
cip.c:163:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
            x=zv; if(c=*u++){if(INF(c))DO(n, *x++ =*v?c**v:0.0; ++v;)else DO(n, *x++ =c**v++;);}else{v+=n; DO(n, *x++=0.0;);}
                     ~^~~~~
cip.c:163:23: note: place parentheses around the assignment to silence this warning
            x=zv; if(c=*u++){if(INF(c))DO(n, *x++ =*v?c**v:0.0; ++v;)else DO(n, *x++ =c**v++;);}else{v+=n; DO(n, *x++=0.0;);}
                      ^
                     (     )
cip.c:163:23: note: use '==' to turn this assignment into an equality comparison
            x=zv; if(c=*u++){if(INF(c))DO(n, *x++ =*v?c**v:0.0; ++v;)else DO(n, *x++ =c**v++;);}else{v+=n; DO(n, *x++=0.0;);}
                      ^
                      ==
cip.c:164:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
     DO(p1, x=zv; if(c=*u++){if(INF(c))DO(n, *x+++=*v?c**v:0.0; ++v;)else DO(n, *x+++=c**v++;);}else v+=n;);
                     ~^~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
cip.c:164:23: note: place parentheses around the assignment to silence this warning
     DO(p1, x=zv; if(c=*u++){if(INF(c))DO(n, *x+++=*v?c**v:0.0; ++v;)else DO(n, *x+++=c**v++;);}else v+=n;);
                      ^
                     (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
cip.c:164:23: note: use '==' to turn this assignment into an equality comparison
     DO(p1, x=zv; if(c=*u++){if(INF(c))DO(n, *x+++=*v?c**v:0.0; ++v;)else DO(n, *x+++=c**v++;);}else v+=n;);
                      ^
                      ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
In file included from cip.c:220:
./cip_t.h:8:15: warning: '&&' within '||' [-Wlogical-op-parentheses]
if(c==CPLUSDOT&&(c0==IPBX1||c1==IPBX1)||c==CSTARDOT&&(c0==IPBX0||c1==IPBX0)){
   ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~
./cip_t.h:8:15: note: place parentheses around the '&&' expression to silence this warning
if(c==CPLUSDOT&&(c0==IPBX1||c1==IPBX1)||c==CSTARDOT&&(c0==IPBX0||c1==IPBX0)){
              ^
   (                                  )
./cip_t.h:8:52: warning: '&&' within '||' [-Wlogical-op-parentheses]
if(c==CPLUSDOT&&(c0==IPBX1||c1==IPBX1)||c==CSTARDOT&&(c0==IPBX0||c1==IPBX0)){
                                      ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
./cip_t.h:8:52: note: place parentheses around the '&&' expression to silence this warning
if(c==CPLUSDOT&&(c0==IPBX1||c1==IPBX1)||c==CSTARDOT&&(c0==IPBX0||c1==IPBX0)){
                                                   ^
                                        (                                  )
./cip_t.h:19:22: warning: '&&' within '||' [-Wlogical-op-parentheses]
}}else if(c==CPLUSDOT&&(c0==IPBX0||c1==IPBX0)||c==CSTARDOT&&(c0==IPBX1||c1==IPBX1)||
          ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~
./cip_t.h:19:22: note: place parentheses around the '&&' expression to silence this warning
}}else if(c==CPLUSDOT&&(c0==IPBX0||c1==IPBX0)||c==CSTARDOT&&(c0==IPBX1||c1==IPBX1)||
                     ^
          (                                  )
./cip_t.h:19:59: warning: '&&' within '||' [-Wlogical-op-parentheses]
}}else if(c==CPLUSDOT&&(c0==IPBX0||c1==IPBX0)||c==CSTARDOT&&(c0==IPBX1||c1==IPBX1)||
                                             ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
./cip_t.h:19:59: note: place parentheses around the '&&' expression to silence this warning
}}else if(c==CPLUSDOT&&(c0==IPBX0||c1==IPBX0)||c==CSTARDOT&&(c0==IPBX1||c1==IPBX1)||
                                                          ^
                                               (                                  )
./cip_t.h:20:11: warning: '&&' within '||' [-Wlogical-op-parentheses]
    c==CNE&&(c0==IPBX0||c1==IPBX0)){
    ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
./cip_t.h:20:11: note: place parentheses around the '&&' expression to silence this warning
    c==CNE&&(c0==IPBX0||c1==IPBX0)){
          ^
    (                             )
In file included from cip.c:224:
./cip_t.h:8:15: warning: '&&' within '||' [-Wlogical-op-parentheses]
if(c==CPLUSDOT&&(c0==IPBX1||c1==IPBX1)||c==CSTARDOT&&(c0==IPBX0||c1==IPBX0)){
   ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~
./cip_t.h:8:15: note: place parentheses around the '&&' expression to silence this warning
if(c==CPLUSDOT&&(c0==IPBX1||c1==IPBX1)||c==CSTARDOT&&(c0==IPBX0||c1==IPBX0)){
              ^
   (                                  )
./cip_t.h:8:52: warning: '&&' within '||' [-Wlogical-op-parentheses]
if(c==CPLUSDOT&&(c0==IPBX1||c1==IPBX1)||c==CSTARDOT&&(c0==IPBX0||c1==IPBX0)){
                                      ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
./cip_t.h:8:52: note: place parentheses around the '&&' expression to silence this warning
if(c==CPLUSDOT&&(c0==IPBX1||c1==IPBX1)||c==CSTARDOT&&(c0==IPBX0||c1==IPBX0)){
                                                   ^
                                        (                                  )
./cip_t.h:19:22: warning: '&&' within '||' [-Wlogical-op-parentheses]
}}else if(c==CPLUSDOT&&(c0==IPBX0||c1==IPBX0)||c==CSTARDOT&&(c0==IPBX1||c1==IPBX1)||
          ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~
./cip_t.h:19:22: note: place parentheses around the '&&' expression to silence this warning
}}else if(c==CPLUSDOT&&(c0==IPBX0||c1==IPBX0)||c==CSTARDOT&&(c0==IPBX1||c1==IPBX1)||
                     ^
          (                                  )
./cip_t.h:19:59: warning: '&&' within '||' [-Wlogical-op-parentheses]
}}else if(c==CPLUSDOT&&(c0==IPBX0||c1==IPBX0)||c==CSTARDOT&&(c0==IPBX1||c1==IPBX1)||
                                             ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
./cip_t.h:19:59: note: place parentheses around the '&&' expression to silence this warning
}}else if(c==CPLUSDOT&&(c0==IPBX0||c1==IPBX0)||c==CSTARDOT&&(c0==IPBX1||c1==IPBX1)||
                                                          ^
                                               (                                  )
./cip_t.h:20:11: warning: '&&' within '||' [-Wlogical-op-parentheses]
    c==CNE&&(c0==IPBX0||c1==IPBX0)){
    ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
./cip_t.h:20:11: note: place parentheses around the '&&' expression to silence this warning
    c==CNE&&(c0==IPBX0||c1==IPBX0)){
          ^
    (                             )
In file included from cip.c:228:
./cip_t.h:8:15: warning: '&&' within '||' [-Wlogical-op-parentheses]
if(c==CPLUSDOT&&(c0==IPBX1||c1==IPBX1)||c==CSTARDOT&&(c0==IPBX0||c1==IPBX0)){
   ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~
./cip_t.h:8:15: note: place parentheses around the '&&' expression to silence this warning
if(c==CPLUSDOT&&(c0==IPBX1||c1==IPBX1)||c==CSTARDOT&&(c0==IPBX0||c1==IPBX0)){
              ^
   (                                  )
./cip_t.h:8:52: warning: '&&' within '||' [-Wlogical-op-parentheses]
if(c==CPLUSDOT&&(c0==IPBX1||c1==IPBX1)||c==CSTARDOT&&(c0==IPBX0||c1==IPBX0)){
                                      ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
./cip_t.h:8:52: note: place parentheses around the '&&' expression to silence this warning
if(c==CPLUSDOT&&(c0==IPBX1||c1==IPBX1)||c==CSTARDOT&&(c0==IPBX0||c1==IPBX0)){
                                                   ^
                                        (                                  )
./cip_t.h:19:22: warning: '&&' within '||' [-Wlogical-op-parentheses]
}}else if(c==CPLUSDOT&&(c0==IPBX0||c1==IPBX0)||c==CSTARDOT&&(c0==IPBX1||c1==IPBX1)||
          ~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~
./cip_t.h:19:22: note: place parentheses around the '&&' expression to silence this warning
}}else if(c==CPLUSDOT&&(c0==IPBX0||c1==IPBX0)||c==CSTARDOT&&(c0==IPBX1||c1==IPBX1)||
                     ^
          (                                  )
./cip_t.h:19:59: warning: '&&' within '||' [-Wlogical-op-parentheses]
}}else if(c==CPLUSDOT&&(c0==IPBX0||c1==IPBX0)||c==CSTARDOT&&(c0==IPBX1||c1==IPBX1)||
                                             ~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
./cip_t.h:19:59: note: place parentheses around the '&&' expression to silence this warning
}}else if(c==CPLUSDOT&&(c0==IPBX0||c1==IPBX0)||c==CSTARDOT&&(c0==IPBX1||c1==IPBX1)||
                                                          ^
                                               (                                  )
./cip_t.h:20:11: warning: '&&' within '||' [-Wlogical-op-parentheses]
    c==CNE&&(c0==IPBX0||c1==IPBX0)){
    ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~
./cip_t.h:20:11: note: place parentheses around the '&&' expression to silence this warning
    c==CNE&&(c0==IPBX0||c1==IPBX0)){
          ^
    (                             )
17 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o cl.o cl.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o cp.o cp.c
cp.c:63:22: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(n==IMAX||1==AR(x)&&!AN(x))R powseqlim(w,fs);
           ~~~~~~~~~~^~~~~~~~
cp.c:63:22: note: place parentheses around the '&&' expression to silence this warning
 if(n==IMAX||1==AR(x)&&!AN(x))R powseqlim(w,fs);
             ~~~~~~~~^~~~~~~~
cp.c:125:47: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(!(t==AT(w)&&AN(y)==AN(w)&&(r==AR(w)||1>=r&&1>=AR(w))))R ply1(w,self);
                                        ~~~~~~^~~~~~~~~~
cp.c:125:47: note: place parentheses around the '&&' expression to silence this warning
  if(!(t==AT(w)&&AN(y)==AN(w)&&(r==AR(w)||1>=r&&1>=AR(w))))R ply1(w,self);
                                          ~~~~^~~~~~~~~~
cp.c:164:33: warning: '&&' within '||' [-Wlogical-op-parentheses]
    if(!AR(w)&&(x=*AAV(w),!AR(x)&&NUMERIC&AT(x)||1==AR(x)&&!AN(x))){
                          ~~~~~~^~~~~~~~~~~~~~~~~
cp.c:164:33: note: place parentheses around the '&&' expression to silence this warning
    if(!AR(w)&&(x=*AAV(w),!AR(x)&&NUMERIC&AT(x)||1==AR(x)&&!AN(x))){
                          ~~~~~~^~~~~~~~~~~~~~~
cp.c:164:58: warning: '&&' within '||' [-Wlogical-op-parentheses]
    if(!AR(w)&&(x=*AAV(w),!AR(x)&&NUMERIC&AT(x)||1==AR(x)&&!AN(x))){
                                               ~~~~~~~~~~^~~~~~~~
cp.c:164:58: note: place parentheses around the '&&' expression to silence this warning
    if(!AR(w)&&(x=*AAV(w),!AR(x)&&NUMERIC&AT(x)||1==AR(x)&&!AN(x))){
                                                 ~~~~~~~~^~~~~~~~
cp.c:166:26: warning: '&&' within '||' [-Wlogical-op-parentheses]
     if((!AN(x)||FL&AT(x)&&inf==*DAV(x))&&
               ~~~~~~~~~~^~~~~~~~~~~~~~
cp.c:166:26: note: place parentheses around the '&&' expression to silence this warning
     if((!AN(x)||FL&AT(x)&&inf==*DAV(x))&&
                 ~~~~~~~~^~~~~~~~~~~~~~
5 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o cpdtsp.o cpdtsp.c
cpdtsp.c:150:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   if(c=*axv++){
      ~^~~~~~~
cpdtsp.c:150:8: note: place parentheses around the assignment to silence this warning
   if(c=*axv++){
       ^
      (       )
cpdtsp.c:150:8: note: use '==' to turn this assignment into an equality comparison
   if(c=*axv++){
       ^
       ==
cpdtsp.c:156:16: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
     DO(p, if(d=*dv++){if(!zyv[*v])*zjv++=*v; zyv[*v++]+=c*d; v++;});
              ~^~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
cpdtsp.c:156:16: note: place parentheses around the assignment to silence this warning
     DO(p, if(d=*dv++){if(!zyv[*v])*zjv++=*v; zyv[*v++]+=c*d; v++;});
               ^
              (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
cpdtsp.c:156:16: note: use '==' to turn this assignment into an equality comparison
     DO(p, if(d=*dv++){if(!zyv[*v])*zjv++=*v; zyv[*v++]+=c*d; v++;});
               ^
               ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o cr.o cr.c
In file included from cr.c:34:
./cr_t.h:35:19: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(!mn||yt&DIRECT&&RFLAG){I zn;
       ~~~~~~~~~~~^~~~~~~
./cr_t.h:35:19: note: place parentheses around the '&&' expression to silence this warning
 if(!mn||yt&DIRECT&&RFLAG){I zn;
         ~~~~~~~~~^~~~~~~
./cr_t.h:43:31: warning: '&&' within '||' [-Wlogical-op-parentheses]
   if(yt!=AT(y)||yr!=AR(y)||yr&&ICMP(AS(y),ys,yr))break;
                          ~~~~^~~~~~~~~~~~~~~~~~~
./cr_t.h:43:31: note: place parentheses around the '&&' expression to silence this warning
   if(yt!=AT(y)||yr!=AR(y)||yr&&ICMP(AS(y),ys,yr))break;
                            ~~^~~~~~~~~~~~~~~~~~~
In file included from cr.c:53:
./cr_t.h:35:19: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(!mn||yt&DIRECT&&RFLAG){I zn;
       ~~~~~~~~~~~^~~~~~~
./cr_t.h:35:19: note: place parentheses around the '&&' expression to silence this warning
 if(!mn||yt&DIRECT&&RFLAG){I zn;
         ~~~~~~~~~^~~~~~~
./cr_t.h:43:31: warning: '&&' within '||' [-Wlogical-op-parentheses]
   if(yt!=AT(y)||yr!=AR(y)||yr&&ICMP(AS(y),ys,yr))break;
                          ~~~~^~~~~~~~~~~~~~~~~~~
./cr_t.h:43:31: note: place parentheses around the '&&' expression to silence this warning
   if(yt!=AT(y)||yr!=AR(y)||yr&&ICMP(AS(y),ys,yr))break;
                            ~~^~~~~~~~~~~~~~~~~~~
cr.c:138:12: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  p=0; if(f=v->f)p=VERB&AT(f)&&strchr(ir2,d=ID(f));
          ~^~~~~
cr.c:138:12: note: place parentheses around the assignment to silence this warning
  p=0; if(f=v->f)p=VERB&AT(f)&&strchr(ir2,d=ID(f));
           ^
          (     )
cr.c:138:12: note: use '==' to turn this assignment into an equality comparison
  p=0; if(f=v->f)p=VERB&AT(f)&&strchr(ir2,d=ID(f));
           ^
           ==
cr.c:139:12: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  q=0; if(g=v->g)q=VERB&AT(g)&&strchr(ir2,e=ID(g));
          ~^~~~~
cr.c:139:12: note: place parentheses around the assignment to silence this warning
  q=0; if(g=v->g)q=VERB&AT(g)&&strchr(ir2,e=ID(g));
           ^
          (     )
cr.c:139:12: note: use '==' to turn this assignment into an equality comparison
  q=0; if(g=v->g)q=VERB&AT(g)&&strchr(ir2,e=ID(g));
           ^
           ==
cr.c:143:21: warning: '&&' within '||' [-Wlogical-op-parentheses]
   case CAMP:   if(p&&NOUN&AT(g)||q&&NOUN&AT(f))m+=VIRS1; break;
                   ~^~~~~~~~~~~~~~
cr.c:143:21: note: place parentheses around the '&&' expression to silence this warning
   case CAMP:   if(p&&NOUN&AT(g)||q&&NOUN&AT(f))m+=VIRS1; break;
                   ~^~~~~~~~~~~~
cr.c:143:36: warning: '&&' within '||' [-Wlogical-op-parentheses]
   case CAMP:   if(p&&NOUN&AT(g)||q&&NOUN&AT(f))m+=VIRS1; break;
                                ~~~^~~~~~~~~~~~
cr.c:143:36: note: place parentheses around the '&&' expression to silence this warning
   case CAMP:   if(p&&NOUN&AT(g)||q&&NOUN&AT(f))m+=VIRS1; break;
                                  ~^~~~~~~~~~~~
8 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o crs.o crs.c
crs.c:31:33: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(f){v=AV(y); DO(n-1, if(b[i]=1&&ICMP(v,v+c,f))++m; v+=c;);}else memset(b,C0,n);
                            ~~~~^~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
crs.c:31:33: note: place parentheses around the assignment to silence this warning
  if(f){v=AV(y); DO(n-1, if(b[i]=1&&ICMP(v,v+c,f))++m; v+=c;);}else memset(b,C0,n);
                                ^
                            (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
crs.c:31:33: note: use '==' to turn this assignment into an equality comparison
  if(f){v=AV(y); DO(n-1, if(b[i]=1&&ICMP(v,v+c,f))++m; v+=c;);}else memset(b,C0,n);
                                ^
                                ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
crs.c:168:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(av&&wv)DO(f, if(s=av[i]-wv[i])break;) else s=av?-1:1;
                     ~^~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
crs.c:168:23: note: place parentheses around the assignment to silence this warning
  if(av&&wv)DO(f, if(s=av[i]-wv[i])break;) else s=av?-1:1;
                      ^
                     (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
crs.c:168:23: note: use '==' to turn this assignment into an equality comparison
  if(av&&wv)DO(f, if(s=av[i]-wv[i])break;) else s=av?-1:1;
                      ^
                      ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
crs.c:175:26: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(av&&wv&&f)DO(f, if(s=av[i]-wv[i])break;) else s=!f?0:av?-1:1;
                        ~^~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
crs.c:175:26: note: place parentheses around the assignment to silence this warning
  if(av&&wv&&f)DO(f, if(s=av[i]-wv[i])break;) else s=!f?0:av?-1:1;
                         ^
                        (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
crs.c:175:26: note: use '==' to turn this assignment into an equality comparison
  if(av&&wv&&f)DO(f, if(s=av[i]-wv[i])break;) else s=!f?0:av?-1:1;
                         ^
                         ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
crs.c:176:7: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&0<s||!b&&0>s){RZ(zv[j++]=CALL2(f2,b?ae:aa,b?ww:we,fs)); ICPY(iv,b?wv:av,g); iv+=g; k=m;}
     ~^~~~~~~
crs.c:176:7: note: place parentheses around the '&&' expression to silence this warning
  if(b&&0<s||!b&&0>s){RZ(zv[j++]=CALL2(f2,b?ae:aa,b?ww:we,fs)); ICPY(iv,b?wv:av,g); iv+=g; k=m;}
      ^
     (     )
crs.c:176:16: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&0<s||!b&&0>s){RZ(zv[j++]=CALL2(f2,b?ae:aa,b?ww:we,fs)); ICPY(iv,b?wv:av,g); iv+=g; k=m;}
           ~~~~^~~~~
crs.c:176:16: note: place parentheses around the '&&' expression to silence this warning
  if(b&&0<s||!b&&0>s){RZ(zv[j++]=CALL2(f2,b?ae:aa,b?ww:we,fs)); ICPY(iv,b?wv:av,g); iv+=g; k=m;}
               ^
             (      )
crs.c:188:38: warning: add explicit braces to avoid dangling else [-Wdangling-else]
  else if(!b&&0>=s)if(aj==an)av=v=0; else{v=av; av+=ak*ac; RE(ak=spradv(an,ab,af,acr,aj,ap,&aa)); aj+=ak;}
                                     ^
crs.c:189:12: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
         ~~^~~~~~~
crs.c:189:12: note: place parentheses around the '&&' expression to silence this warning
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
           ^
         (      )
crs.c:189:20: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
                ~~~^~~~~~~~~~~~~~
crs.c:189:20: note: place parentheses around the '&&' expression to silence this warning
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
                  ~^~~~~~~~~~~~~~
crs.c:189:44: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
                                         ~~^~~~~~~
crs.c:189:44: note: place parentheses around the '&&' expression to silence this warning
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
                                           ^
                                         (      )
crs.c:189:52: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
                                                ~~~^~~~~~~~~~~~~~
crs.c:189:52: note: place parentheses around the '&&' expression to silence this warning
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
                                                  ~^~~~~~~~~~~~~~
crs.c:189:7: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
     ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
crs.c:189:7: note: place parentheses around the '&&' expression to silence this warning
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
      ^
     (                            )
crs.c:189:39: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
                                  ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~
crs.c:189:39: note: place parentheses around the '&&' expression to silence this warning
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
                                      ^
                                    (                             )
crs.c:194:56: warning: add explicit braces to avoid dangling else [-Wdangling-else]
  else if(!b&&0<=s&&(!v||ICMP(v,av,f)))if(wj==wn)wv=0; else{wv+=wk*wc; RE(wk=spradv(wn,wb,wf,wcr,wj,wp,&ww)); wj+=wk;}
                                                       ^
crs.c:225:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(av&&wv)DO(f, if(s=av[i]-wv[i])break;) else s=av?-1:1;
                     ~^~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
crs.c:225:23: note: place parentheses around the assignment to silence this warning
  if(av&&wv)DO(f, if(s=av[i]-wv[i])break;) else s=av?-1:1;
                      ^
                     (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
crs.c:225:23: note: use '==' to turn this assignment into an equality comparison
  if(av&&wv)DO(f, if(s=av[i]-wv[i])break;) else s=av?-1:1;
                      ^
                      ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
crs.c:232:26: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(av&&wv&&f)DO(f, if(s=av[i]-wv[i])break;) else s=!f?0:av?-1:1;
                        ~^~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
crs.c:232:26: note: place parentheses around the assignment to silence this warning
  if(av&&wv&&f)DO(f, if(s=av[i]-wv[i])break;) else s=!f?0:av?-1:1;
                         ^
                        (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
crs.c:232:26: note: use '==' to turn this assignment into an equality comparison
  if(av&&wv&&f)DO(f, if(s=av[i]-wv[i])break;) else s=!f?0:av?-1:1;
                         ^
                         ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
crs.c:233:7: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&0<s||!b&&0>s){ado(jt,b?ae:aa,b?ww:we); RZ(zv[j++]); ICPY(iv,b?wv:av,g); iv+=g; k=m;}
     ~^~~~~~~
crs.c:233:7: note: place parentheses around the '&&' expression to silence this warning
  if(b&&0<s||!b&&0>s){ado(jt,b?ae:aa,b?ww:we); RZ(zv[j++]); ICPY(iv,b?wv:av,g); iv+=g; k=m;}
      ^
     (     )
crs.c:233:16: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&0<s||!b&&0>s){ado(jt,b?ae:aa,b?ww:we); RZ(zv[j++]); ICPY(iv,b?wv:av,g); iv+=g; k=m;}
           ~~~~^~~~~
crs.c:233:16: note: place parentheses around the '&&' expression to silence this warning
  if(b&&0<s||!b&&0>s){ado(jt,b?ae:aa,b?ww:we); RZ(zv[j++]); ICPY(iv,b?wv:av,g); iv+=g; k=m;}
               ^
             (      )
crs.c:245:38: warning: add explicit braces to avoid dangling else [-Wdangling-else]
  else if(!b&&0>=s)if(aj==an)av=v=0; else{v=av; av+=ak*ac; RE(ak=spradv(an,ab,af,acr,aj,ap,&aa)); aj+=ak;}
                                     ^
crs.c:246:12: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
         ~~^~~~~~~
crs.c:246:12: note: place parentheses around the '&&' expression to silence this warning
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
           ^
         (      )
crs.c:246:20: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
                ~~~^~~~~~~~~~~~~~
crs.c:246:20: note: place parentheses around the '&&' expression to silence this warning
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
                  ~^~~~~~~~~~~~~~
crs.c:246:44: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
                                         ~~^~~~~~~
crs.c:246:44: note: place parentheses around the '&&' expression to silence this warning
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
                                           ^
                                         (      )
crs.c:246:52: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
                                                ~~~^~~~~~~~~~~~~~
crs.c:246:52: note: place parentheses around the '&&' expression to silence this warning
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
                                                  ~^~~~~~~~~~~~~~
crs.c:246:7: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
     ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
crs.c:246:7: note: place parentheses around the '&&' expression to silence this warning
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
      ^
     (                            )
crs.c:246:39: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
                                  ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~
crs.c:246:39: note: place parentheses around the '&&' expression to silence this warning
  if(b&&(!s&&!wv||v&&ICMP(v,wv,f))||!b&&(!s&&!av||v&&ICMP(v,av,f))){
                                      ^
                                    (                             )
crs.c:251:56: warning: add explicit braces to avoid dangling else [-Wdangling-else]
  else if(!b&&0<=s&&(!v||ICMP(v,av,f)))if(wj==wn)wv=0; else{wv+=wk*wc; RE(wk=spradv(wn,wb,wf,wcr,wj,wp,&ww)); wj+=wk;}
                                                       ^
25 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o ct.o ct.c
ct.c:106:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(j=*AV(c)){
    ~^~~~~~~
ct.c:106:6: note: place parentheses around the assignment to silence this warning
 if(j=*AV(c)){
     ^
    (       )
ct.c:106:6: note: use '==' to turn this assignment into an equality comparison
 if(j=*AV(c)){
     ^
     ==
ct.c:165:48: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(b&&(c==CAMPCO||c==CATCO||(c==CAMP||c==CAT)&&1<VAV(gt)->mr))R taysum(gt);
                            ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~
ct.c:165:48: note: place parentheses around the '&&' expression to silence this warning
  if(b&&(c==CAMPCO||c==CATCO||(c==CAMP||c==CAT)&&1<VAV(gt)->mr))R taysum(gt);
                                               ^
                              (                               )
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o cu.o cu.c
cu.c:64:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(b=LIT&AT(w)&&256<AN(w)){
    ~^~~~~~~~~~~~~~~~~~~~~
cu.c:64:6: note: place parentheses around the assignment to silence this warning
 if(b=LIT&AT(w)&&256<AN(w)){
     ^
    (                     )
cu.c:64:6: note: use '==' to turn this assignment into an equality comparison
 if(b=LIT&AT(w)&&256<AN(w)){
     ^
     ==
cu.c:86:9: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   if(b1=CSLASH==u->id){x=u->f; u=VAV(x);}
      ~~^~~~~~~~~~~~~~
cu.c:86:9: note: place parentheses around the assignment to silence this warning
   if(b1=CSLASH==u->id){x=u->f; u=VAV(x);}
        ^
      (               )
cu.c:86:9: note: use '==' to turn this assignment into an equality comparison
   if(b1=CSLASH==u->id){x=u->f; u=VAV(x);}
        ^
        ==
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o cv.o cv.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o cx.o cx.c
cx.c:80:5: warning: expression result unused [-Wunused-value]
 RE(0);
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
cx.c:138:6: warning: add explicit braces to avoid dangling else [-Wdangling-else]
     else  {r=9; BGA(cd,INT,r*WCD,1,0); cv=(CDATA*)AV(cd)-1; ra(cd);}
     ^
cx.c:240:56: warning: while loop has empty body [-Wempty-body]
  if(m){while(' '==*p)++p; if(')'==*p){while(' '==*++p); if(p>=m+q)break;}}
                                                       ^
cx.c:240:56: note: put the semicolon on a separate line to silence this warning
cx.c:259:50: warning: while loop has empty body [-Wempty-body]
  while(' '==*x)++x; if(':'==*x){while(' '==*++x); if(CLF==*x){r=++x; break;}}
                                                 ^
cx.c:259:50: note: put the semicolon on a separate line to silence this warning
4 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o d.o d.c
d.c:30:27: warning: adding 'int' to a string does not append to the string [-Wstring-plus-int]
 if(equ(alp,w))eputs(" a."+!jt->nflag);
                     ~~~~~^~~~~~~~~~~
./ja.h:273:49: note: expanded from macro 'eputs'
#define eputs(x)                    jteputs(jt,(x))
                                                ^
d.c:30:27: note: use array indexing to silence this warning
 if(equ(alp,w))eputs(" a."+!jt->nflag);
                          ^
                     &    [
./ja.h:273:49: note: expanded from macro 'eputs'
#define eputs(x)                    jteputs(jt,(x))
                                                ^
d.c:69:25: warning: adding 'int' to a string does not append to the string [-Wstring-plus-int]
  case BOX:  eputs(" a:"+!jt->nflag); break;
                   ~~~~~^~~~~~~~~~~
./ja.h:273:49: note: expanded from macro 'eputs'
#define eputs(x)                    jteputs(jt,(x))
                                                ^
d.c:69:25: note: use array indexing to silence this warning
  case BOX:  eputs(" a:"+!jt->nflag); break;
                        ^
                   &    [
./ja.h:273:49: note: expanded from macro 'eputs'
#define eputs(x)                    jteputs(jt,(x))
                                                ^
d.c:97:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(a=d->dca)ep(AN(a),NAV(a)->s); 
    ~^~~~~~~
d.c:97:6: note: place parentheses around the assignment to silence this warning
 if(a=d->dca)ep(AN(a),NAV(a)->s); 
     ^
    (       )
d.c:97:6: note: use '==' to turn this assignment into an equality comparison
 if(a=d->dca)ep(AN(a),NAV(a)->s); 
     ^
     ==
d.c:188:5: warning: expression result unused [-Wunused-value]
 RE(0);
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
4 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o dc.o dc.c
dc.c:12:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
static SYMWALK(jtdloc,A,BOX,5,2,1,{RZ(*zv++=sfn(0,d->name)); RZ(*zv++=dfrep(d->val));})
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                               ~^~
dc.c:12:8: note: place parentheses around the assignment to silence this warning
static SYMWALK(jtdloc,A,BOX,5,2,1,{RZ(*zv++=sfn(0,d->name)); RZ(*zv++=dfrep(d->val));})
       ^
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                                ^
dc.c:12:8: note: use '==' to turn this assignment into an equality comparison
static SYMWALK(jtdloc,A,BOX,5,2,1,{RZ(*zv++=sfn(0,d->name)); RZ(*zv++=dfrep(d->val));})
       ^
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                                ^
dc.c:28:39: warning: '&&' within '||' [-Wlogical-op-parentheses]
 c=si->dcsusp||s0&&DCPARSE==s0->dctype&&s0->dcsusp?'*':' ';
             ~~~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~
dc.c:28:39: note: place parentheses around the '&&' expression to silence this warning
 c=si->dcsusp||s0&&DCPARSE==s0->dctype&&s0->dcsusp?'*':' ';
                                      ^
               (                                  )
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o dss.o dss.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o dstop.o dstop.c
dstop.c:42:26: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  while(' '==*s)++s; if(b='~'==*s)++s; while(' '==*s)++s;
                        ~^~~~~~~~
dstop.c:42:26: note: place parentheses around the assignment to silence this warning
  while(' '==*s)++s; if(b='~'==*s)++s; while(' '==*s)++s;
                         ^
                        (        )
dstop.c:42:26: note: use '==' to turn this assignment into an equality comparison
  while(' '==*s)++s; if(b='~'==*s)++s; while(' '==*s)++s;
                         ^
                         ==
1 warning generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o dsusp.o dsusp.c
dsusp.c:66:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(c=d->dcc){i=*(I*)d->dci; R(MIN(i,AN(c)-1)+(CW*)AV(c))->source;}else R 0;
    ~^~~~~~~
dsusp.c:66:6: note: place parentheses around the assignment to silence this warning
 if(c=d->dcc){i=*(I*)d->dci; R(MIN(i,AN(c)-1)+(CW*)AV(c))->source;}else R 0;
     ^
    (       )
dsusp.c:66:6: note: use '==' to turn this assignment into an equality comparison
 if(c=d->dcc){i=*(I*)d->dci; R(MIN(i,AN(c)-1)+(CW*)AV(c))->source;}else R 0;
     ^
     ==
dsusp.c:157:7: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(s=dbstop(c,ci->source)){z=0; jsignal(EVSTOP);}
     ~^~~~~~~~~~~~~~~~~~~~~
dsusp.c:157:7: note: place parentheses around the assignment to silence this warning
  if(s=dbstop(c,ci->source)){z=0; jsignal(EVSTOP);}
      ^
     (                     )
dsusp.c:157:7: note: use '==' to turn this assignment into an equality comparison
  if(s=dbstop(c,ci->source)){z=0; jsignal(EVSTOP);}
      ^
      ==
dsusp.c:173:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   if(s=dbstop(d,0L)){z=0; jsignal(EVSTOP);}
      ~^~~~~~~~~~~~~
dsusp.c:173:8: note: place parentheses around the assignment to silence this warning
   if(s=dbstop(d,0L)){z=0; jsignal(EVSTOP);}
       ^
      (             )
dsusp.c:173:8: note: use '==' to turn this assignment into an equality comparison
   if(s=dbstop(d,0L)){z=0; jsignal(EVSTOP);}
       ^
       ==
dsusp.c:177:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   if(b=jt->dbalpha||jt->dbomega){a=jt->dbalpha; w=jt->dbomega; jt->dbalpha=jt->dbomega=0;}
      ~^~~~~~~~~~~~~~~~~~~~~~~~~
dsusp.c:177:8: note: place parentheses around the assignment to silence this warning
   if(b=jt->dbalpha||jt->dbomega){a=jt->dbalpha; w=jt->dbomega; jt->dbalpha=jt->dbomega=0;}
       ^
      (                         )
dsusp.c:177:8: note: use '==' to turn this assignment into an equality comparison
   if(b=jt->dbalpha||jt->dbomega){a=jt->dbalpha; w=jt->dbomega; jt->dbalpha=jt->dbomega=0;}
       ^
       ==
dsusp.c:217:5: warning: expression result unused [-Wunused-value]
 RE(0);
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
5 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o dtoa.o dtoa.c
dtoa.c:558:9: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
        if (rv = freelist[k]) {
            ~~~^~~~~~~~~~~~~
dtoa.c:558:9: note: place parentheses around the assignment to silence this warning
        if (rv = freelist[k]) {
               ^
            (               )
dtoa.c:558:9: note: use '==' to turn this assignment into an equality comparison
        if (rv = freelist[k]) {
               ^
               ==
dtoa.c:839:9: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
                if (y = *xb++) {
                    ~~^~~~~~~
dtoa.c:839:9: note: place parentheses around the assignment to silence this warning
                if (y = *xb++) {
                      ^
                    (        )
dtoa.c:839:9: note: use '==' to turn this assignment into an equality comparison
                if (y = *xb++) {
                      ^
                      ==
dtoa.c:923:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
        if (i = k & 3)
            ~~^~~~~~~
dtoa.c:923:8: note: place parentheses around the assignment to silence this warning
        if (i = k & 3)
              ^
            (        )
dtoa.c:923:8: note: use '==' to turn this assignment into an equality comparison
        if (i = k & 3)
              ^
              ==
dtoa.c:1004:11: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
                if (*x1 = z)
                    ~~~~^~~
dtoa.c:1004:11: note: place parentheses around the assignment to silence this warning
                if (*x1 = z)
                        ^
                    (      )
dtoa.c:1004:11: note: use '==' to turn this assignment into an equality comparison
                if (*x1 = z)
                        ^
                        ==
dtoa.c:1308:9: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
        if (de = (int)(d0 >> Exp_shift))
            ~~~^~~~~~~~~~~~~~~~~~~~~~~~
dtoa.c:1308:9: note: place parentheses around the assignment to silence this warning
        if (de = (int)(d0 >> Exp_shift))
               ^
            (                          )
dtoa.c:1308:9: note: use '==' to turn this assignment into an equality comparison
        if (de = (int)(d0 >> Exp_shift))
               ^
               ==
dtoa.c:1312:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
        if (y = d1) {
            ~~^~~~
dtoa.c:1312:8: note: place parentheses around the assignment to silence this warning
        if (y = d1) {
              ^
            (     )
dtoa.c:1312:8: note: use '==' to turn this assignment into an equality comparison
        if (y = d1) {
              ^
              ==
dtoa.c:1313:9: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
                if (k = lo0bits(&y)) {
                    ~~^~~~~~~~~~~~~
dtoa.c:1313:9: note: place parentheses around the assignment to silence this warning
                if (k = lo0bits(&y)) {
                      ^
                    (              )
dtoa.c:1313:9: note: use '==' to turn this assignment into an equality comparison
                if (k = lo0bits(&y)) {
                      ^
                      ==
dtoa.c:2813:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
        if (i = (int)(word0(d) >> Exp_shift1 & (Exp_mask>>Exp_shift1))) {
            ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dtoa.c:2813:8: note: place parentheses around the assignment to silence this warning
        if (i = (int)(word0(d) >> Exp_shift1 & (Exp_mask>>Exp_shift1))) {
              ^
            (                                                         )
dtoa.c:2813:8: note: use '==' to turn this assignment into an equality comparison
        if (i = (int)(word0(d) >> Exp_shift1 & (Exp_mask>>Exp_shift1))) {
              ^
              ==
dtoa.c:2967:15: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
                else if (j1 = -k) {
                         ~~~^~~~
dtoa.c:2967:15: note: place parentheses around the assignment to silence this warning
                else if (j1 = -k) {
                            ^
                         (      )
dtoa.c:2967:15: note: use '==' to turn this assignment into an equality comparison
                else if (j1 = -k) {
                            ^
                            ==
dtoa.c:3081:39: warning: '&&' within '||' [-Wlogical-op-parentheses]
                                if (dval(d) > ds || dval(d) == ds && L & 1) {
                                                 ~~ ~~~~~~~~~~~~~~^~~~~~~~
dtoa.c:3081:39: note: place parentheses around the '&&' expression to silence this warning
                                if (dval(d) > ds || dval(d) == ds && L & 1) {
                                                    ~~~~~~~~~~~~~~^~~~~~~~
dtoa.c:3128:10: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
                        if (j = b5 - m5)
                            ~~^~~~~~~~~
dtoa.c:3128:10: note: place parentheses around the assignment to silence this warning
                        if (j = b5 - m5)
                              ^
                            (          )
dtoa.c:3128:10: note: use '==' to turn this assignment into an equality comparison
                        if (j = b5 - m5)
                              ^
                              ==
dtoa.c:3166:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
        if (i = ((s5 ? 32 - hi0bits(S->x[S->wds-1]) : 1) + s2) & 0x1f)
            ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dtoa.c:3166:8: note: place parentheses around the assignment to silence this warning
        if (i = ((s5 ? 32 - hi0bits(S->x[S->wds-1]) : 1) + s2) & 0x1f)
              ^
            (                                                        )
dtoa.c:3166:8: note: use '==' to turn this assignment into an equality comparison
        if (i = ((s5 ? 32 - hi0bits(S->x[S->wds-1]) : 1) + s2) & 0x1f)
              ^
              ==
dtoa.c:3253:8: warning: '&&' within '||' [-Wlogical-op-parentheses]
                                                        && !(word1(d) & 1)
                                                        ^~~~~~~~~~~~~~~~~~
dtoa.c:3253:8: note: place parentheses around the '&&' expression to silence this warning
                                                        && !(word1(d) & 1)
                                                        ^
dtoa.c:3272:29: warning: '&&' within '||' [-Wlogical-op-parentheses]
                                        if ((j1 > 0 || j1 == 0 && dig & 1)
                                                    ~~ ~~~~~~~~^~~~~~~~~~
dtoa.c:3272:29: note: place parentheses around the '&&' expression to silence this warning
                                        if ((j1 > 0 || j1 == 0 && dig & 1)
                                                               ^
                                                       (                 )
dtoa.c:3332:22: warning: '&&' within '||' [-Wlogical-op-parentheses]
        if (j > 0 || j == 0 && dig & 1) {
                  ~~ ~~~~~~~^~~~~~~~~~
dtoa.c:3332:22: note: place parentheses around the '&&' expression to silence this warning
        if (j > 0 || j == 0 && dig & 1) {
                            ^
                     (                )
15 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o f.o f.c
f.c:33:14: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 c=*buf; if(q=c=='-')*s++=CSIGN; q=q||(c=='+');
            ~^~~~~~~
f.c:33:14: note: place parentheses around the assignment to silence this warning
 c=*buf; if(q=c=='-')*s++=CSIGN; q=q||(c=='+');
             ^
            (       )
f.c:33:14: note: use '==' to turn this assignment into an equality comparison
 c=*buf; if(q=c=='-')*s++=CSIGN; q=q||(c=='+');
             ^
             ==
f.c:36:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(t=strchr(s,'e')){
    ~^~~~~~~~~~~~~~
f.c:36:6: note: place parentheses around the assignment to silence this warning
 if(t=strchr(s,'e')){
     ^
    (              )
f.c:36:6: note: use '==' to turn this assignment into an equality comparison
 if(t=strchr(s,'e')){
     ^
     ==
f.c:39:16: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(k)while(*t=*(k+t))t++;
             ~~^~~~~~~
f.c:39:16: note: place parentheses around the assignment to silence this warning
  if(k)while(*t=*(k+t))t++;
               ^
             (        )
f.c:39:16: note: use '==' to turn this assignment into an equality comparison
  if(k)while(*t=*(k+t))t++;
               ^
               ==
f.c:56:34: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   RZ(t=thxqe(w)); p=AN(t); if(ov=n<p)p=n4; MC(y,AV(t),p); y+=p; break;
                               ~~^~~~
f.c:56:34: note: place parentheses around the assignment to silence this warning
   RZ(t=thxqe(w)); p=AN(t); if(ov=n<p)p=n4; MC(y,AV(t),p); y+=p; break;
                                 ^
                               (     )
f.c:56:34: note: use '==' to turn this assignment into an equality comparison
   RZ(t=thxqe(w)); p=AN(t); if(ov=n<p)p=n4; MC(y,AV(t),p); y+=p; break;
                                 ^
                                 ==
f.c:58:9: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   if(ov=n<2*wn)p=n4/2; else p=wn; DO(p, *y++=*x++?'1':'0'; *y++=' ';); break;
      ~~^~~~~~~
f.c:58:9: note: place parentheses around the assignment to silence this warning
   if(ov=n<2*wn)p=n4/2; else p=wn; DO(p, *y++=*x++?'1':'0'; *y++=' ';); break;
        ^
      (        )
f.c:58:9: note: use '==' to turn this assignment into an equality comparison
   if(ov=n<2*wn)p=n4/2; else p=wn; DO(p, *y++=*x++?'1':'0'; *y++=' ';); break;
        ^
        ==
f.c:66:24: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
     p=strlen(t); if(ov=n4<p+y-s)break; strcpy(y,t); y+=p;
                     ~~^~~~~~~~~
f.c:66:24: note: place parentheses around the assignment to silence this warning
     p=strlen(t); if(ov=n4<p+y-s)break; strcpy(y,t); y+=p;
                       ^
                     (          )
f.c:66:24: note: use '==' to turn this assignment into an equality comparison
     p=strlen(t); if(ov=n4<p+y-s)break; strcpy(y,t); y+=p;
                       ^
                       ==
f.c:72:58: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   else        DO(wn, fmt(jt,buf,x); p=strlen(buf); if(ov=n4<1+p+y-s)break; strcpy(y,buf); y+=p; *y++=' '; x+=k;);
                                                       ~~^~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
f.c:72:58: note: place parentheses around the assignment to silence this warning
   else        DO(wn, fmt(jt,buf,x); p=strlen(buf); if(ov=n4<1+p+y-s)break; strcpy(y,buf); y+=p; *y++=' '; x+=k;);
                                                         ^
                                                       (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
f.c:72:58: note: use '==' to turn this assignment into an equality comparison
   else        DO(wn, fmt(jt,buf,x); p=strlen(buf); if(ov=n4<1+p+y-s)break; strcpy(y,buf); y+=p; *y++=' '; x+=k;);
                                                         ^
                                                         ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
f.c:151:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(b=1<AN(d)||1!=*AV(d)){RZ(d=thx1(y.d)); n=AN(d);}
    ~^~~~~~~~~~~~~~~~~~~
f.c:151:6: note: place parentheses around the assignment to silence this warning
 if(b=1<AN(d)||1!=*AV(d)){RZ(d=thx1(y.d)); n=AN(d);}
     ^
    (                   )
f.c:151:6: note: use '==' to turn this assignment into an equality comparison
 if(b=1<AN(d)||1!=*AV(d)){RZ(d=thx1(y.d)); n=AN(d);}
     ^
     ==
8 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o f2.o f2.c
f2.c:28:12: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   while(*t=*(k+t))++t;
         ~~^~~~~~~
f2.c:28:12: note: place parentheses around the assignment to silence this warning
   while(*t=*(k+t))++t;
           ^
         (        )
f2.c:28:12: note: use '==' to turn this assignment into an equality comparison
   while(*t=*(k+t))++t;
           ^
           ==
f2.c:183:15: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(2<r||1==n&&2!=r){
        ~~~~~~^~~~~~
f2.c:183:15: note: place parentheses around the '&&' expression to silence this warning
  if(2<r||1==n&&2!=r){
              ^
          (         )
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o i.o i.c
i.c:31:8: warning: use of logical '&&' with constant operand [-Wconstant-logical-operand]
 liln=1&&SYS&SYS_LILENDIAN;
       ^ ~~~~~~~~~~~~~~~~~
i.c:31:8: note: use '&' for a bitwise operation
 liln=1&&SYS&SYS_LILENDIAN;
       ^~~~~
       &
i.c:31:8: note: remove constant to silence this warning
 liln=1&&SYS&SYS_LILENDIAN;
       ^~~~~~~~~~~~~~~~~~~
1 warning generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o io.o io.c
io.c:72:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(b=1==*p)p=""; /* 1 means literal input */
    ~^~~~~~
io.c:72:6: note: place parentheses around the assignment to silence this warning
 if(b=1==*p)p=""; /* 1 means literal input */
     ^
    (      )
io.c:72:6: note: use '==' to turn this assignment into an equality comparison
 if(b=1==*p)p=""; /* 1 means literal input */
     ^
     ==
io.c:78:27: warning: passing 'UC *' (aka 'unsigned char *') to parameter of type 'C *' (aka 'char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  jt->dcs->dci=j=advl(j,n,s);
                          ^
io.c:53:25: note: passing argument to parameter 's' here
static I advl(I j,I n,C*s){B b;C c,*v;
                        ^
io.c:80:24: warning: passing 'UC *' (aka 'unsigned char *') to parameter of type 'C *' (aka 'char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  jtwri(jt,MTYOLOG,p,m,k+s);
                       ^~~
io.c:22:34: note: passing argument to parameter 's' here
void jtwri(J jt,I type,C*p,I m,C*s){C buf[1024],*t=jt->outseq,*v=buf;I c,d,e,n;
                                 ^
io.c:81:5: warning: passing 'UC *' (aka 'unsigned char *') to parameter of type 'C *' (aka 'char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  R inpl(b,m,k+s);
    ^~~~~~~~~~~~~
./ja.h:460:55: note: expanded from macro 'inpl'
#define inpl(x,y,z)                 jtinpl(jt,(x),(y),(z))
                                                      ^~~
io.c:43:25: note: passing argument to parameter 's' here
A jtinpl(J jt,B b,I n,C*s){C c;I k=0;
                        ^
io.c:105:2: warning: implicit declaration of function 'close' is invalid in C99 [-Wimplicit-function-declaration]
 close(jt->breakfh);
 ^
io.c:107:2: warning: implicit declaration of function 'unlink' is invalid in C99 [-Wimplicit-function-declaration]
 unlink(jt->breakfn);
 ^
io.c:321:6: warning: implicit declaration of function 'isalpha' is invalid in C99 [-Wimplicit-function-declaration]
        if(!isalpha(*psrc)) return EVILNAME;
            ^
io.c:322:8: warning: implicit declaration of function 'isalnum' is invalid in C99 [-Wimplicit-function-declaration]
        while(isalnum(*psrc) || *psrc=='_') *psnk++ = *psrc++;
              ^
8 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o j.o j.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o jdlllic.o jdlllic.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o k.o k.c
k.c:24:13: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case B01: TOBIT(B, 1         ); break;
            ^~~~~~~~~~~~~~~~~~~~
k.c:14:26: note: expanded from macro 'TOBIT'
   DO(q, k=0; DO(BB, if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;);  \
                        ~^~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
k.c:24:13: note: place parentheses around the assignment to silence this warning
  case B01: TOBIT(B, 1         ); break;
            ^
k.c:14:26: note: expanded from macro 'TOBIT'
   DO(q, k=0; DO(BB, if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;);  \
                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
k.c:24:13: note: use '==' to turn this assignment into an equality comparison
  case B01: TOBIT(B, 1         ); break;
            ^
k.c:14:26: note: expanded from macro 'TOBIT'
   DO(q, k=0; DO(BB, if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;);  \
                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
k.c:24:13: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case B01: TOBIT(B, 1         ); break;
            ^~~~~~~~~~~~~~~~~~~~
k.c:15:26: note: expanded from macro 'TOBIT'
   if(r){k=0; DO(r,  if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;}   \
                        ~^~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
k.c:24:13: note: place parentheses around the assignment to silence this warning
  case B01: TOBIT(B, 1         ); break;
            ^
k.c:15:26: note: expanded from macro 'TOBIT'
   if(r){k=0; DO(r,  if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;}   \
                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
k.c:24:13: note: use '==' to turn this assignment into an equality comparison
  case B01: TOBIT(B, 1         ); break;
            ^
k.c:15:26: note: expanded from macro 'TOBIT'
   if(r){k=0; DO(r,  if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;}   \
                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
k.c:25:13: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case INT: TOBIT(I, 1==x      ); break;
            ^~~~~~~~~~~~~~~~~~~~
k.c:14:26: note: expanded from macro 'TOBIT'
   DO(q, k=0; DO(BB, if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;);  \
                        ~^~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
k.c:25:13: note: place parentheses around the assignment to silence this warning
  case INT: TOBIT(I, 1==x      ); break;
            ^
k.c:14:26: note: expanded from macro 'TOBIT'
   DO(q, k=0; DO(BB, if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;);  \
                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
k.c:25:13: note: use '==' to turn this assignment into an equality comparison
  case INT: TOBIT(I, 1==x      ); break;
            ^
k.c:14:26: note: expanded from macro 'TOBIT'
   DO(q, k=0; DO(BB, if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;);  \
                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
k.c:25:13: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case INT: TOBIT(I, 1==x      ); break;
            ^~~~~~~~~~~~~~~~~~~~
k.c:15:26: note: expanded from macro 'TOBIT'
   if(r){k=0; DO(r,  if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;}   \
                        ~^~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
k.c:25:13: note: place parentheses around the assignment to silence this warning
  case INT: TOBIT(I, 1==x      ); break;
            ^
k.c:15:26: note: expanded from macro 'TOBIT'
   if(r){k=0; DO(r,  if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;}   \
                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
k.c:25:13: note: use '==' to turn this assignment into an equality comparison
  case INT: TOBIT(I, 1==x      ); break;
            ^
k.c:15:26: note: expanded from macro 'TOBIT'
   if(r){k=0; DO(r,  if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;}   \
                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
k.c:26:13: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case FL:  TOBIT(D, FEQ(1.0,x)); break;
            ^~~~~~~~~~~~~~~~~~~~
k.c:14:26: note: expanded from macro 'TOBIT'
   DO(q, k=0; DO(BB, if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;);  \
                        ~^~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
k.c:26:13: note: place parentheses around the assignment to silence this warning
  case FL:  TOBIT(D, FEQ(1.0,x)); break;
            ^
k.c:14:26: note: expanded from macro 'TOBIT'
   DO(q, k=0; DO(BB, if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;);  \
                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
k.c:26:13: note: use '==' to turn this assignment into an equality comparison
  case FL:  TOBIT(D, FEQ(1.0,x)); break;
            ^
k.c:14:26: note: expanded from macro 'TOBIT'
   DO(q, k=0; DO(BB, if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;);  \
                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
k.c:26:13: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case FL:  TOBIT(D, FEQ(1.0,x)); break;
            ^~~~~~~~~~~~~~~~~~~~
k.c:15:26: note: expanded from macro 'TOBIT'
   if(r){k=0; DO(r,  if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;}   \
                        ~^~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
k.c:26:13: note: place parentheses around the assignment to silence this warning
  case FL:  TOBIT(D, FEQ(1.0,x)); break;
            ^
k.c:15:26: note: expanded from macro 'TOBIT'
   if(r){k=0; DO(r,  if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;}   \
                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
k.c:26:13: note: use '==' to turn this assignment into an equality comparison
  case FL:  TOBIT(D, FEQ(1.0,x)); break;
            ^
k.c:15:26: note: expanded from macro 'TOBIT'
   if(r){k=0; DO(r,  if(x=*v++){if(AS)k|=bit[i]; else R 0;}); *zv++=k;}   \
                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
k.c:32:17: warning: assigning to 'UC *' (aka 'unsigned char *') from 'C *' (aka 'char *') converts between pointers to integer types with different sign [-Wpointer-sign]
 v=(US*)AV(w); x=(C*)yv;
                ^~~~~~~
k.c:158:9: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(neg=0>t)t=-t; q.d=iv1;
     ~~~^~~~
k.c:158:9: note: place parentheses around the assignment to silence this warning
  if(neg=0>t)t=-t; q.d=iv1;
        ^
     (      )
k.c:158:9: note: use '==' to turn this assignment into an equality comparison
  if(neg=0>t)t=-t; q.d=iv1;
        ^
        ==
k.c:165:12: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   if(recip=1>t)t=1.0/t;
      ~~~~~^~~~
k.c:165:12: note: place parentheses around the assignment to silence this warning
   if(recip=1>t)t=1.0/t;
           ^
      (        )
k.c:165:12: note: use '==' to turn this assignment into an equality comparison
   if(recip=1>t)t=1.0/t;
           ^
           ==
k.c:233:6: warning: '/*' within block comment [-Wcomment]
}    /* most significant digit last, decimal point before last digit */
     ^
10 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o m.o m.c
m.c:87:4: warning: add explicit braces to avoid dangling else [-Wdangling-else]
  }else jt->spfor+=msize[((MS*)w-1)->j];
   ^
m.c:205:21: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
    DO(AN(w)-1, if(k=*v++){u=k+jt->sympv; CALL1(f,u->name,0L); CALL1(f,u->val,0L);});
                   ~^~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
m.c:205:21: note: place parentheses around the assignment to silence this warning
    DO(AN(w)-1, if(k=*v++){u=k+jt->sympv; CALL1(f,u->name,0L); CALL1(f,u->val,0L);});
                    ^
                   (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
m.c:205:21: note: use '==' to turn this assignment into an equality comparison
    DO(AN(w)-1, if(k=*v++){u=k+jt->sympv; CALL1(f,u->name,0L); CALL1(f,u->val,0L);});
                    ^
                    ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o mbx.o mbx.c
mbx.c:248:9: warning: '/*' within block comment [-Wcomment]
// }    /* w has addresses relative to a; works in place */
        ^
1 warning generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o p.o p.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o pv.o pv.c
pv.c:89:7: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(xt=tine(x.t)){xi=tvi(x.t); u=VAV(xt); if(0>xi&&CFORK==u->id){xi=tvi(u->f); if(0>xi)xi=tvi(u->h);}}
    ~~^~~~~~~~~~
pv.c:89:7: note: place parentheses around the assignment to silence this warning
 if(xt=tine(x.t)){xi=tvi(x.t); u=VAV(xt); if(0>xi&&CFORK==u->id){xi=tvi(u->f); if(0>xi)xi=tvi(u->h);}}
      ^
    (           )
pv.c:89:7: note: use '==' to turn this assignment into an equality comparison
 if(xt=tine(x.t)){xi=tvi(x.t); u=VAV(xt); if(0>xi&&CFORK==u->id){xi=tvi(u->f); if(0>xi)xi=tvi(u->h);}}
      ^
      ==
pv.c:90:7: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(yt=tine(y.t)){yi=tvi(y.t); v=VAV(yt); if(0>yi&&CFORK==v->id){yi=tvi(v->f); if(0>yi)yi=tvi(v->h);}}
    ~~^~~~~~~~~~
pv.c:90:7: note: place parentheses around the assignment to silence this warning
 if(yt=tine(y.t)){yi=tvi(y.t); v=VAV(yt); if(0>yi&&CFORK==v->id){yi=tvi(v->f); if(0>yi)yi=tvi(v->h);}}
      ^
    (           )
pv.c:90:7: note: use '==' to turn this assignment into an equality comparison
 if(yt=tine(y.t)){yi=tvi(y.t); v=VAV(yt); if(0>yi&&CFORK==v->id){yi=tvi(v->f); if(0>yi)yi=tvi(v->h);}}
      ^
      ==
pv.c:100:23: warning: '&&' within '||' [-Wlogical-op-parentheses]
   else if(xr&&(yl||yr&&jt->tmonad))z.t=sf;
                  ~~~~^~~~~~~~~~~~
pv.c:100:23: note: place parentheses around the '&&' expression to silence this warning
   else if(xr&&(yl||yr&&jt->tmonad))z.t=sf;
                      ^
                    (             )
pv.c:134:30: warning: '&&' within '||' [-Wlogical-op-parentheses]
   case DCASE(5,5): if(xi==yi&&xj==yj||xi==yj&&xj==yi)
                       ~~~~~~^~~~~~~~~~
pv.c:134:30: note: place parentheses around the '&&' expression to silence this warning
   case DCASE(5,5): if(xi==yi&&xj==yj||xi==yj&&xj==yi)
                             ^
                       (             )
pv.c:134:46: warning: '&&' within '||' [-Wlogical-op-parentheses]
   case DCASE(5,5): if(xi==yi&&xj==yj||xi==yj&&xj==yi)
                                     ~~~~~~~~^~~~~~~~
pv.c:134:46: note: place parentheses around the '&&' expression to silence this warning
   case DCASE(5,5): if(xi==yi&&xj==yj||xi==yj&&xj==yi)
                                             ^
                                       (             )
pv.c:136:22: warning: add explicit braces to avoid dangling else [-Wdangling-else]
                     else if(u->g==swapc(u->g))z.t=folk(v->f,folk(u->g,fs,     v->g ),v->h);
                     ^
pv.c:216:45: warning: expression result unused [-Wunused-value]
  } else {stack[n-1]=vmove(n,m-1,stack); RE(0); n-=0<m--;}
                                            ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
7 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o px.o px.c
px.c:50:39: warning: expression result unused [-Wunused-value]
static A jtcex(J jt,A w,AF f){A z; RE(w); z=f(jt,w); RESETERR; R z;}
                                      ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
1 warning generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o r.o r.c
r.c:25:7: warning: '&&' within '||' [-Wlogical-op-parentheses]
 m+=!b&&!xop||hs&&xop;
    ~~^~~~~~~~
r.c:25:7: note: place parentheses around the '&&' expression to silence this warning
 m+=!b&&!xop||hs&&xop;
      ^
    (       )
r.c:25:17: warning: '&&' within '||' [-Wlogical-op-parentheses]
 m+=!b&&!xop||hs&&xop;
            ~~~~^~~~~
r.c:25:17: note: place parentheses around the '&&' expression to silence this warning
 m+=!b&&!xop||hs&&xop;
                ^
              (      )
r.c:43:30: warning: '&&' within '||' [-Wlogical-op-parentheses]
  m=id==CFORK?3:!!fs+(ex||xop&&hs||!xop&&gs);
                        ~~~~~^~~~
r.c:43:30: note: place parentheses around the '&&' expression to silence this warning
  m=id==CFORK?3:!!fs+(ex||xop&&hs||!xop&&gs);
                             ^
                          (      )
r.c:43:40: warning: '&&' within '||' [-Wlogical-op-parentheses]
  m=id==CFORK?3:!!fs+(ex||xop&&hs||!xop&&gs);
                                 ~~~~~~^~~~
r.c:43:40: note: place parentheses around the '&&' expression to silence this warning
  m=id==CFORK?3:!!fs+(ex||xop&&hs||!xop&&gs);
                                       ^
                                   (       )
4 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o rl.o rl.c
rl.c:22:22: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(1==n||(2==n||3>=n&&' '==c)&&(d==CESC1||d==CESC2)||vnm(n,v))R 0;
               ~~~~~~^~~~~~~~
rl.c:22:22: note: place parentheses around the '&&' expression to silence this warning
 if(1==n||(2==n||3>=n&&' '==c)&&(d==CESC1||d==CESC2)||vnm(n,v))R 0;
                     ^
                 (           )
rl.c:22:31: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(1==n||(2==n||3>=n&&' '==c)&&(d==CESC1||d==CESC2)||vnm(n,v))R 0;
        ~~~~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~
rl.c:22:31: note: place parentheses around the '&&' expression to silence this warning
 if(1==n||(2==n||3>=n&&' '==c)&&(d==CESC1||d==CESC2)||vnm(n,v))R 0;
                              ^
          (                                         )
rl.c:23:50: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(C9==ctype[c])DO(n-1, d=c; c=ctype[*++v]; if(b=!NUMV(c)||d==CS&&c!=C9)break;)
                                                ~^~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
rl.c:23:50: note: place parentheses around the assignment to silence this warning
 if(C9==ctype[c])DO(n-1, d=c; c=ctype[*++v]; if(b=!NUMV(c)||d==CS&&c!=C9)break;)
                                                 ^
                                                (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
rl.c:23:50: note: use '==' to turn this assignment into an equality comparison
 if(C9==ctype[c])DO(n-1, d=c; c=ctype[*++v]; if(b=!NUMV(c)||d==CS&&c!=C9)break;)
                                                 ^
                                                 ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
rl.c:24:52: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 else if(c==q)   DO(n-1, c=*v++; if(c==q)p=!p; if(b=p?0:c!=q)break;)
                                                  ~^~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
rl.c:24:52: note: place parentheses around the assignment to silence this warning
 else if(c==q)   DO(n-1, c=*v++; if(c==q)p=!p; if(b=p?0:c!=q)break;)
                                                   ^
                                                  (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
rl.c:24:52: note: use '==' to turn this assignment into an equality comparison
 else if(c==q)   DO(n-1, c=*v++; if(c==q)p=!p; if(b=p?0:c!=q)break;)
                                                   ^
                                                   ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
rl.c:25:63: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 else if(c=='(') DO(n-1, c=*v++; j+=c=='('?1:c==')'?-1:0; if(b=!j)break;)
                                                             ~^~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
rl.c:25:63: note: place parentheses around the assignment to silence this warning
 else if(c=='(') DO(n-1, c=*v++; j+=c=='('?1:c==')'?-1:0; if(b=!j)break;)
                                                              ^
                                                             (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
rl.c:25:63: note: use '==' to turn this assignment into an equality comparison
 else if(c=='(') DO(n-1, c=*v++; j+=c=='('?1:c==')'?-1:0; if(b=!j)break;)
                                                              ^
                                                              ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
rl.c:91:17: warning: '&&' within '||' [-Wlogical-op-parentheses]
 j=2; b=7<n||1<n&&1<AR(w);
           ~~~~~^~~~~~~~~
rl.c:91:17: note: place parentheses around the '&&' expression to silence this warning
 j=2; b=7<n||1<n&&1<AR(w);
             ~~~^~~~~~~~~
rl.c:118:22: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 DO(n, x=WVR(i); if(b=1!=AR(x)||!(LIT&AT(x)))break;);
                    ~^~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
rl.c:118:22: note: place parentheses around the assignment to silence this warning
 DO(n, x=WVR(i); if(b=1!=AR(x)||!(LIT&AT(x)))break;);
                     ^
                    (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
rl.c:118:22: note: use '==' to turn this assignment into an equality comparison
 DO(n, x=WVR(i); if(b=1!=AR(x)||!(LIT&AT(x)))break;);
                     ^
                     ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
rl.c:146:13: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(7<n||1<n&&1<AR(w)){
       ~~~~~^~~~~~~~~
rl.c:146:13: note: place parentheses around the '&&' expression to silence this warning
 if(7<n||1<n&&1<AR(w)){
         ~~~^~~~~~~~~
rl.c:152:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   if(p=!(equ(b,sc(n-1))&&equ(d,num[-1]))){
      ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
rl.c:152:8: note: place parentheses around the assignment to silence this warning
   if(p=!(equ(b,sc(n-1))&&equ(d,num[-1]))){
       ^
      (                                  )
rl.c:152:8: note: use '==' to turn this assignment into an equality comparison
   if(p=!(equ(b,sc(n-1))&&equ(d,num[-1]))){
       ^
       ==
rl.c:158:7: warning: expression result unused [-Wunused-value]
   RE(y); R raze(y);
      ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
rl.c:243:92: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(1<=n){f=AVR(0); t=v->f; c=ID(t); ft=c==CHOOK||c==CFORK||c==CADVF||id==CFORK&&NOUN&AT(t)&&lp(f);}
                                                                    ~~~~~~~~~~~~~~~~~~~~~~~^~~~~~~
rl.c:243:92: note: place parentheses around the '&&' expression to silence this warning
 if(1<=n){f=AVR(0); t=v->f; c=ID(t); ft=c==CHOOK||c==CFORK||c==CADVF||id==CFORK&&NOUN&AT(t)&&lp(f);}
                                                                      ~~~~~~~~~~~~~~~~~~~~~^~~~~~~
rl.c:253:7: warning: expression result unused [-Wunused-value]
   RE(0); R raze(y);
      ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
rl.c:272:27: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(2>n||2==n&&1==AN(v[0])&&':'==*CAV(v[0])){
       ~~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~
rl.c:272:27: note: place parentheses around the '&&' expression to silence this warning
 if(2>n||2==n&&1==AN(v[0])&&':'==*CAV(v[0])){
         ~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~
13 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o rt.o rt.c
rt.c:25:17: warning: '&&' within '||' [-Wlogical-op-parentheses]
    if(b&&(c==ul&&' '!=bv[k]||c!=' '&&ll==bv[k])){xv[j-1]+=1; b=0;}
           ~~~~~^~~~~~~~~~~~~~
rt.c:25:17: note: place parentheses around the '&&' expression to silence this warning
    if(b&&(c==ul&&' '!=bv[k]||c!=' '&&ll==bv[k])){xv[j-1]+=1; b=0;}
                ^
           (                )
rt.c:25:37: warning: '&&' within '||' [-Wlogical-op-parentheses]
    if(b&&(c==ul&&' '!=bv[k]||c!=' '&&ll==bv[k])){xv[j-1]+=1; b=0;}
                            ~~~~~~~~^~~~~~~~~~~
rt.c:25:37: note: place parentheses around the '&&' expression to silence this warning
    if(b&&(c==ul&&' '!=bv[k]||c!=' '&&ll==bv[k])){xv[j-1]+=1; b=0;}
                                    ^
                              (                )
rt.c:80:40: warning: '&&' within '||' [-Wlogical-op-parentheses]
 m=AN(a); u=CAV(a); b=!m||1==m&&'0'<=*u&&*u<='9';
                        ~~~~~~~~~~~~~~~^~~~~~~~~
rt.c:80:40: note: place parentheses around the '&&' expression to silence this warning
 m=AN(a); u=CAV(a); b=!m||1==m&&'0'<=*u&&*u<='9';
                                       ^
                          (                     )
rt.c:129:33: warning: '&&' within '||' [-Wlogical-op-parentheses]
 m=!!fs+(gs||ex)+(id==CFORK||xop&&hs);
                           ~~~~~^~~~
rt.c:129:33: note: place parentheses around the '&&' expression to silence this warning
 m=!!fs+(gs||ex)+(id==CFORK||xop&&hs);
                                ^
                             (      )
4 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o s.o s.c
s.c:67:12: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(u->next=*hv){v=*hv+jt->sympv; v->prev=j; v->flag^=LHEAD;}
    ~~~~~~~^~~~
s.c:67:12: note: place parentheses around the assignment to silence this warning
 if(u->next=*hv){v=*hv+jt->sympv; v->prev=j; v->flag^=LHEAD;}
           ^
    (          )
s.c:67:12: note: use '==' to turn this assignment into an equality comparison
 if(u->next=*hv){v=*hv+jt->sympv; v->prev=j; v->flag^=LHEAD;}
           ^
           ==
s.c:85:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
static SYMWALK(jtsymfreeha, B,B01,100,1, 1, RZ(symfree(d)))   /* free pool table entries      */
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                               ~^~
s.c:85:8: note: place parentheses around the assignment to silence this warning
static SYMWALK(jtsymfreeha, B,B01,100,1, 1, RZ(symfree(d)))   /* free pool table entries      */
       ^
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                                ^
s.c:85:8: note: use '==' to turn this assignment into an equality comparison
static SYMWALK(jtsymfreeha, B,B01,100,1, 1, RZ(symfree(d)))   /* free pool table entries      */
       ^
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                                ^
s.c:100:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
static SYMWALK(jtsympoola, I,INT,100,1, 1, *zv++=j;)
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                               ~^~
s.c:100:8: note: place parentheses around the assignment to silence this warning
static SYMWALK(jtsympoola, I,INT,100,1, 1, *zv++=j;)
       ^
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                                ^
s.c:100:8: note: use '==' to turn this assignment into an equality comparison
static SYMWALK(jtsympoola, I,INT,100,1, 1, *zv++=j;)
       ^
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                                ^
s.c:122:22: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 for(i=0;i<n;++i)if(j=v[i]){    /* per named locales    */
                    ~^~~~~
s.c:122:22: note: place parentheses around the assignment to silence this warning
 for(i=0;i<n;++i)if(j=v[i]){    /* per named locales    */
                     ^
                    (     )
s.c:122:22: note: use '==' to turn this assignment into an equality comparison
 for(i=0;i<n;++i)if(j=v[i]){    /* per named locales    */
                     ^
                     ==
s.c:128:22: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 for(i=0;i<n;++i)if(x=pu[i]){   /* per numbered locales */
                    ~^~~~~~
s.c:128:22: note: place parentheses around the assignment to silence this warning
 for(i=0;i<n;++i)if(x=pu[i]){   /* per numbered locales */
                     ^
                    (      )
s.c:128:22: note: use '==' to turn this assignment into an equality comparison
 for(i=0;i<n;++i)if(x=pu[i]){   /* per numbered locales */
                     ^
                     ==
s.c:132:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(x=jt->local){               /* per local table      */
    ~^~~~~~~~~~
s.c:132:6: note: place parentheses around the assignment to silence this warning
 if(x=jt->local){               /* per local table      */
     ^
    (          )
s.c:132:6: note: use '==' to turn this assignment into an equality comparison
 if(x=jt->local){               /* per local table      */
     ^
     ==
s.c:170:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(e=probe(a,g))R e;
    ~^~~~~~~~~~~
s.c:170:6: note: place parentheses around the assignment to silence this warning
 if(e=probe(a,g))R e;
     ^
    (           )
s.c:170:6: note: use '==' to turn this assignment into an equality comparison
 if(e=probe(a,g))R e;
     ^
     ==
s.c:172:24: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 DO(AN(y), x=v[i]; if(e=probe(a,stfind(1,AN(x),CAV(x))))break;);
                      ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
s.c:172:24: note: place parentheses around the assignment to silence this warning
 DO(AN(y), x=v[i]; if(e=probe(a,stfind(1,AN(x),CAV(x))))break;);
                       ^
                      (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
s.c:172:24: note: use '==' to turn this assignment into an equality comparison
 DO(AN(y), x=v[i]; if(e=probe(a,stfind(1,AN(x),CAV(x))))break;);
                       ^
                       ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
s.c:179:24: warning: while loop has empty body [-Wempty-body]
  v=s; while('_'!=*--v); ++v;
                       ^
s.c:179:24: note: put the semicolon on a separate line to silence this warning
s.c:241:14: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 c=d; while(c=c->dclnk){jt->curname=c->dca; ASSERT(!(DCCALL==c->dctype&&v==(L*)c->dcn),EVSTACK);}
            ~^~~~~~~~~
s.c:241:14: note: place parentheses around the assignment to silence this warning
 c=d; while(c=c->dclnk){jt->curname=c->dca; ASSERT(!(DCCALL==c->dctype&&v==(L*)c->dcn),EVSTACK);}
             ^
            (         )
s.c:241:14: note: use '==' to turn this assignment into an equality comparison
 c=d; while(c=c->dclnk){jt->curname=c->dca; ASSERT(!(DCCALL==c->dctype&&v==(L*)c->dcn),EVSTACK);}
             ^
             ==
s.c:270:33: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(jt->stch&&(m<n||jt->local!=g&&jt->stloc!=g))e->flag|=LCH;
                  ~~~~~~~~~~~~~~^~~~~~~~~~~~~~
s.c:270:33: note: place parentheses around the '&&' expression to silence this warning
 if(jt->stch&&(m<n||jt->local!=g&&jt->stloc!=g))e->flag|=LCH;
                                ^
                    (                         )
11 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o sc.o sc.c
sc.c:10:5: warning: expression result unused [-Wunused-value]
 RE(0);
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
1 warning generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o sl.o sl.c
sl.c:163:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(v=probe(nfs(n,s),jt->stloc)){
    ~^~~~~~~~~~~~~~~~~~~~~~~~~~
sl.c:163:6: note: place parentheses around the assignment to silence this warning
 if(v=probe(nfs(n,s),jt->stloc)){
     ^
    (                          )
sl.c:163:6: note: use '==' to turn this assignment into an equality comparison
 if(v=probe(nfs(n,s),jt->stloc)){
     ^
     ==
sl.c:208:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
static SYMWALK(jtlocmap1,I,INT,18,3,1,
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                               ~^~
sl.c:208:8: note: place parentheses around the assignment to silence this warning
static SYMWALK(jtlocmap1,I,INT,18,3,1,
       ^
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                                ^
sl.c:208:8: note: use '==' to turn this assignment into an equality comparison
static SYMWALK(jtlocmap1,I,INT,18,3,1,
       ^
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                                ^
sl.c:228:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
static SYMWALK(jtredefg,B,B01,100,1,1,RZ(redef(mark,d)))
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                               ~^~
sl.c:228:8: note: place parentheses around the assignment to silence this warning
static SYMWALK(jtredefg,B,B01,100,1,1,RZ(redef(mark,d)))
       ^
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                                ^
sl.c:228:8: note: use '==' to turn this assignment into an equality comparison
static SYMWALK(jtredefg,B,B01,100,1,1,RZ(redef(mark,d)))
       ^
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                                ^
3 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o sn.o sn.c
sn.c:33:16: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if((1==n||2==n&&'.'==s[1])&&strchr("mnuvxy",c=*s)){
         ~~~~~~^~~~~~~~~~~
sn.c:33:16: note: place parentheses around the '&&' expression to silence this warning
 if((1==n||2==n&&'.'==s[1])&&strchr("mnuvxy",c=*s)){
               ^
           (              )
sn.c:91:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
static SYMWALK(jtnlxxx, A,BOX,20,1, jt->nla[*((UC*)NAV(d->name)->s)]&&jt->nlt&AT(d->val), 
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                               ~^~
sn.c:91:8: note: place parentheses around the assignment to silence this warning
static SYMWALK(jtnlxxx, A,BOX,20,1, jt->nla[*((UC*)NAV(d->name)->s)]&&jt->nlt&AT(d->val), 
       ^
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                                ^
sn.c:91:8: note: use '==' to turn this assignment into an equality comparison
static SYMWALK(jtnlxxx, A,BOX,20,1, jt->nla[*((UC*)NAV(d->name)->s)]&&jt->nlt&AT(d->val), 
       ^
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                                ^
sn.c:94:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
       SYMWALK(jtnlsym, A,BOX,20,1, jt->nla[*((UC*)NAV(d->name)->s)],
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                               ~^~
sn.c:94:8: note: place parentheses around the assignment to silence this warning
       SYMWALK(jtnlsym, A,BOX,20,1, jt->nla[*((UC*)NAV(d->name)->s)],
       ^
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                                ^
sn.c:94:8: note: use '==' to turn this assignment into an equality comparison
       SYMWALK(jtnlsym, A,BOX,20,1, jt->nla[*((UC*)NAV(d->name)->s)],
       ^
./s.h:28:33: note: expanded from macro 'SYMWALK'
  for(i=1;i<n;++i,k=*++e)while(j=k){                         \
                                ^
3 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o t.o t.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o u.o u.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o v.o v.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o v0.o v0.c
v0.c:28:8: warning: expression result unused [-Wunused-value]
static CFR(jtcfrd,D,FL,  dplus,dtymes,dnegate)
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
v0.c:25:6: note: expanded from macro 'CFR'
  RE(z); EPILOG(z);                              \
     ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
v0.c:29:8: warning: expression result unused [-Wunused-value]
static CFR(jtcfrx,X,XNUM,xplus,xtymes, negate)
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
v0.c:25:6: note: expanded from macro 'CFR'
  RE(z); EPILOG(z);                              \
     ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
v0.c:30:8: warning: expression result unused [-Wunused-value]
static CFR(jtcfrq,Q,RAT, qplus,qtymes,QNEGATE)
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
v0.c:25:6: note: expanded from macro 'CFR'
  RE(z); EPILOG(z);                              \
     ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
v0.c:49:18: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(p&&d.im)if(b=!b)c=u[j]; else if(p=ZCJ(c,u[j])){t=v; DO(2+j, t++->im=0.0;);}
                ~^~~
v0.c:49:18: note: place parentheses around the assignment to silence this warning
  if(p&&d.im)if(b=!b)c=u[j]; else if(p=ZCJ(c,u[j])){t=v; DO(2+j, t++->im=0.0;);}
                 ^
                (   )
v0.c:49:18: note: use '==' to turn this assignment into an equality comparison
  if(p&&d.im)if(b=!b)c=u[j]; else if(p=ZCJ(c,u[j])){t=v; DO(2+j, t++->im=0.0;);}
                 ^
                 ==
v0.c:49:39: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(p&&d.im)if(b=!b)c=u[j]; else if(p=ZCJ(c,u[j])){t=v; DO(2+j, t++->im=0.0;);}
                                     ~^~~~~~~~~~~~
v0.c:49:39: note: place parentheses around the assignment to silence this warning
  if(p&&d.im)if(b=!b)c=u[j]; else if(p=ZCJ(c,u[j])){t=v; DO(2+j, t++->im=0.0;);}
                                      ^
                                     (            )
v0.c:49:39: note: use '==' to turn this assignment into an equality comparison
  if(p&&d.im)if(b=!b)c=u[j]; else if(p=ZCJ(c,u[j])){t=v; DO(2+j, t++->im=0.0;);}
                                      ^
                                      ==
v0.c:49:30: warning: add explicit braces to avoid dangling else [-Wdangling-else]
  if(p&&d.im)if(b=!b)c=u[j]; else if(p=ZCJ(c,u[j])){t=v; DO(2+j, t++->im=0.0;);}
                             ^
v0.c:87:5: warning: expression result unused [-Wunused-value]
 RE(0); RZ(QEQ(q,zeroQ));
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
v0.c:240:6: warning: expression result unused [-Wunused-value]
  RE(z); RZ(z=ope(z));
     ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
8 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o v1.o v1.c
v1.c:63:25: warning: '&&' within '||' [-Wlogical-op-parentheses]
 p=u->f; q=v->f; if(!(!p&&!q||p&&q&&matchsub(0L,0L,1L,1L,p,q,&b,C0,C1)))R 0;
                      ~~^~~~~~
v1.c:63:25: note: place parentheses around the '&&' expression to silence this warning
 p=u->f; q=v->f; if(!(!p&&!q||p&&q&&matchsub(0L,0L,1L,1L,p,q,&b,C0,C1)))R 0;
                        ^
                      (     )
v1.c:63:35: warning: '&&' within '||' [-Wlogical-op-parentheses]
 p=u->f; q=v->f; if(!(!p&&!q||p&&q&&matchsub(0L,0L,1L,1L,p,q,&b,C0,C1)))R 0;
                            ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
v1.c:63:35: note: place parentheses around the '&&' expression to silence this warning
 p=u->f; q=v->f; if(!(!p&&!q||p&&q&&matchsub(0L,0L,1L,1L,p,q,&b,C0,C1)))R 0;
                              ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
v1.c:64:25: warning: '&&' within '||' [-Wlogical-op-parentheses]
 p=u->g; q=v->g; if(!(!p&&!q||p&&q&&matchsub(0L,0L,1L,1L,p,q,&b,C0,C1)))R 0;
                      ~~^~~~~~
v1.c:64:25: note: place parentheses around the '&&' expression to silence this warning
 p=u->g; q=v->g; if(!(!p&&!q||p&&q&&matchsub(0L,0L,1L,1L,p,q,&b,C0,C1)))R 0;
                        ^
                      (     )
v1.c:64:35: warning: '&&' within '||' [-Wlogical-op-parentheses]
 p=u->g; q=v->g; if(!(!p&&!q||p&&q&&matchsub(0L,0L,1L,1L,p,q,&b,C0,C1)))R 0;
                            ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
v1.c:64:35: note: place parentheses around the '&&' expression to silence this warning
 p=u->g; q=v->g; if(!(!p&&!q||p&&q&&matchsub(0L,0L,1L,1L,p,q,&b,C0,C1)))R 0;
                              ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
v1.c:65:25: warning: '&&' within '||' [-Wlogical-op-parentheses]
 p=u->h; q=v->h;    R !p&&!q||p&&q&&matchsub(0L,0L,1L,1L,p,q,&b,C0,C1);
                      ~~^~~~~~
v1.c:65:25: note: place parentheses around the '&&' expression to silence this warning
 p=u->h; q=v->h;    R !p&&!q||p&&q&&matchsub(0L,0L,1L,1L,p,q,&b,C0,C1);
                        ^
                      (     )
v1.c:65:35: warning: '&&' within '||' [-Wlogical-op-parentheses]
 p=u->h; q=v->h;    R !p&&!q||p&&q&&matchsub(0L,0L,1L,1L,p,q,&b,C0,C1);
                            ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
v1.c:65:35: note: place parentheses around the '&&' expression to silence this warning
 p=u->h; q=v->h;    R !p&&!q||p&&q&&matchsub(0L,0L,1L,1L,p,q,&b,C0,C1);
                              ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
v1.c:88:71: warning: '&&' within '||' [-Wlogical-op-parentheses]
 c=(af>wf?AN(a):AN(w))/(mn?mn:1); b=p!=q||ICMP(af+AS(a),wf+AS(w),p)||c&&!HOMO(at,wt);
                                                                   ~~~^~~~~~~~~~~~~~
v1.c:88:71: note: place parentheses around the '&&' expression to silence this warning
 c=(af>wf?AN(a):AN(w))/(mn?mn:1); b=p!=q||ICMP(af+AS(a),wf+AS(w),p)||c&&!HOMO(at,wt);
                                                                     ~^~~~~~~~~~~~~~
v1.c:130:10: warning: '&&' within '||' [-Wlogical-op-parentheses]
 R d==m+k&&d==n+j||equ(ae,we)?one:zero;
   ~~~~~~^~~~~~~~~~
v1.c:130:10: note: place parentheses around the '&&' expression to silence this warning
 R d==m+k&&d==n+j||equ(ae,we)?one:zero;
         ^
   (             )
8 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o v2.o v2.c
v2.c:337:5: warning: expression result unused [-Wunused-value]
 RE(0); R z;
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
v2.c:373:14: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(AR(a)||wr&&(b||xt))R rank2ex(a,w,0L,0L,0L,jtqco2);
         ~~~~^~~~~~~~~
v2.c:373:14: note: place parentheses around the '&&' expression to silence this warning
 if(AR(a)||wr&&(b||xt))R rank2ex(a,w,0L,0L,0L,jtqco2);
             ^
           (          )
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o va1.o va1.c
va1.c:86:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(b=1&&wt&SPARSE){wp=PAV(w); e=SPA(wp,e); wt=AT(e);}
    ~^~~~~~~~~~~~~
va1.c:86:6: note: place parentheses around the assignment to silence this warning
 if(b=1&&wt&SPARSE){wp=PAV(w); e=SPA(wp,e); wt=AT(e);}
     ^
    (             )
va1.c:86:6: note: use '==' to turn this assignment into an equality comparison
 if(b=1&&wt&SPARSE){wp=PAV(w); e=SPA(wp,e); wt=AT(e);}
     ^
     ==
va1.c:103:22: warning: passing 'UC [11]' to parameter of type 'const char *' converts between pointers to integer types with different sign [-Wpointer-sign]
  p=((va1tab+(strchr(va1fns,id)-(C*)va1fns))->p1)[wt&B01?0:wt&INT?1:wt&FL?2:wt&CMPX?3:wt&XNUM?4:5];
                     ^~~~~~
/usr/include/string.h:86:26: note: passing argument to parameter here
char    *strchr(const char *, int);
                            ^
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o va2.o va2.c
va2.c:21:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0000II,  VI+VII}, {bw0000II,  VI+VII}, {bw0000II,  VI+VII}, 
   ^~~~~~~~
va2.c:21:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0000II,  VI+VII}, {bw0000II,  VI+VII}, {bw0000II,  VI+VII}, 
                        ^~~~~~~~
va2.c:21:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0000II,  VI+VII}, {bw0000II,  VI+VII}, {bw0000II,  VI+VII}, 
                                             ^~~~~~~~
va2.c:22:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0000II,  VI+VII}, {bw0000II,  VI},     {bw0000II,  VI+VII},
   ^~~~~~~~
va2.c:22:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0000II,  VI+VII}, {bw0000II,  VI},     {bw0000II,  VI+VII},
                        ^~~~~~~~
va2.c:22:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0000II,  VI+VII}, {bw0000II,  VI},     {bw0000II,  VI+VII},
                                             ^~~~~~~~
va2.c:23:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0000II,  VI+VII}, {bw0000II,  VI+VII}, {bw0000II,  VI+VII},
   ^~~~~~~~
va2.c:23:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0000II,  VI+VII}, {bw0000II,  VI+VII}, {bw0000II,  VI+VII},
                        ^~~~~~~~
va2.c:23:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0000II,  VI+VII}, {bw0000II,  VI+VII}, {bw0000II,  VI+VII},
                                             ^~~~~~~~
va2.c:24:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0000II,  VI+VII}, {bw0000II,  VI+VII}, {bw0000II,  VI+VII}, {0,0}}, 
   ^~~~~~~~
va2.c:24:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0000II,  VI+VII}, {bw0000II,  VI+VII}, {bw0000II,  VI+VII}, {0,0}}, 
                        ^~~~~~~~
va2.c:24:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0000II,  VI+VII}, {bw0000II,  VI+VII}, {bw0000II,  VI+VII}, {0,0}}, 
                                             ^~~~~~~~
va2.c:30:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0001II,  VI+VII}, {bw0001II,  VI+VII}, {bw0001II,  VI+VII}, 
   ^~~~~~~~
va2.c:30:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0001II,  VI+VII}, {bw0001II,  VI+VII}, {bw0001II,  VI+VII}, 
                        ^~~~~~~~
va2.c:30:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0001II,  VI+VII}, {bw0001II,  VI+VII}, {bw0001II,  VI+VII}, 
                                             ^~~~~~~~
va2.c:31:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0001II,  VI+VII}, {bw0001II,  VI},     {bw0001II,  VI+VII},
   ^~~~~~~~
va2.c:31:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0001II,  VI+VII}, {bw0001II,  VI},     {bw0001II,  VI+VII},
                        ^~~~~~~~
va2.c:31:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0001II,  VI+VII}, {bw0001II,  VI},     {bw0001II,  VI+VII},
                                             ^~~~~~~~
va2.c:32:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0001II,  VI+VII}, {bw0001II,  VI+VII}, {bw0001II,  VI+VII},
   ^~~~~~~~
va2.c:32:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0001II,  VI+VII}, {bw0001II,  VI+VII}, {bw0001II,  VI+VII},
                        ^~~~~~~~
va2.c:32:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0001II,  VI+VII}, {bw0001II,  VI+VII}, {bw0001II,  VI+VII},
                                             ^~~~~~~~
va2.c:33:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0001II,  VI+VII}, {bw0001II,  VI+VII}, {bw0001II,  VI+VII}, {0,0}}, 
   ^~~~~~~~
va2.c:33:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0001II,  VI+VII}, {bw0001II,  VI+VII}, {bw0001II,  VI+VII}, {0,0}}, 
                        ^~~~~~~~
va2.c:33:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0001II,  VI+VII}, {bw0001II,  VI+VII}, {bw0001II,  VI+VII}, {0,0}}, 
                                             ^~~~~~~~
va2.c:39:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0010II,  VI+VII}, {bw0010II,  VI+VII}, {bw0010II,  VI+VII}, 
   ^~~~~~~~
va2.c:39:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0010II,  VI+VII}, {bw0010II,  VI+VII}, {bw0010II,  VI+VII}, 
                        ^~~~~~~~
va2.c:39:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0010II,  VI+VII}, {bw0010II,  VI+VII}, {bw0010II,  VI+VII}, 
                                             ^~~~~~~~
va2.c:40:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0010II,  VI+VII}, {bw0010II,  VI},     {bw0010II,  VI+VII},
   ^~~~~~~~
va2.c:40:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0010II,  VI+VII}, {bw0010II,  VI},     {bw0010II,  VI+VII},
                        ^~~~~~~~
va2.c:40:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0010II,  VI+VII}, {bw0010II,  VI},     {bw0010II,  VI+VII},
                                             ^~~~~~~~
va2.c:41:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0010II,  VI+VII}, {bw0010II,  VI+VII}, {bw0010II,  VI+VII},
   ^~~~~~~~
va2.c:41:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0010II,  VI+VII}, {bw0010II,  VI+VII}, {bw0010II,  VI+VII},
                        ^~~~~~~~
va2.c:41:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0010II,  VI+VII}, {bw0010II,  VI+VII}, {bw0010II,  VI+VII},
                                             ^~~~~~~~
va2.c:42:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0010II,  VI+VII}, {bw0010II,  VI+VII}, {bw0010II,  VI+VII}, {0,0}}, 
   ^~~~~~~~
va2.c:42:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0010II,  VI+VII}, {bw0010II,  VI+VII}, {bw0010II,  VI+VII}, {0,0}}, 
                        ^~~~~~~~
va2.c:42:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0010II,  VI+VII}, {bw0010II,  VI+VII}, {bw0010II,  VI+VII}, {0,0}}, 
                                             ^~~~~~~~
va2.c:48:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0011II,  VI+VII}, {bw0011II,  VI+VII}, {bw0011II,  VI+VII}, 
   ^~~~~~~~
va2.c:48:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0011II,  VI+VII}, {bw0011II,  VI+VII}, {bw0011II,  VI+VII}, 
                        ^~~~~~~~
va2.c:48:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0011II,  VI+VII}, {bw0011II,  VI+VII}, {bw0011II,  VI+VII}, 
                                             ^~~~~~~~
va2.c:49:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0011II,  VI+VII}, {bw0011II,  VI},     {bw0011II,  VI+VII},
   ^~~~~~~~
va2.c:49:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0011II,  VI+VII}, {bw0011II,  VI},     {bw0011II,  VI+VII},
                        ^~~~~~~~
va2.c:49:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0011II,  VI+VII}, {bw0011II,  VI},     {bw0011II,  VI+VII},
                                             ^~~~~~~~
va2.c:50:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0011II,  VI+VII}, {bw0011II,  VI+VII}, {bw0011II,  VI+VII},
   ^~~~~~~~
va2.c:50:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0011II,  VI+VII}, {bw0011II,  VI+VII}, {bw0011II,  VI+VII},
                        ^~~~~~~~
va2.c:50:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0011II,  VI+VII}, {bw0011II,  VI+VII}, {bw0011II,  VI+VII},
                                             ^~~~~~~~
va2.c:51:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0011II,  VI+VII}, {bw0011II,  VI+VII}, {bw0011II,  VI+VII}, {0,0}}, 
   ^~~~~~~~
va2.c:51:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0011II,  VI+VII}, {bw0011II,  VI+VII}, {bw0011II,  VI+VII}, {0,0}}, 
                        ^~~~~~~~
va2.c:51:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0011II,  VI+VII}, {bw0011II,  VI+VII}, {bw0011II,  VI+VII}, {0,0}}, 
                                             ^~~~~~~~
va2.c:57:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0100II,  VI+VII}, {bw0100II,  VI+VII}, {bw0100II,  VI+VII}, 
   ^~~~~~~~
va2.c:57:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0100II,  VI+VII}, {bw0100II,  VI+VII}, {bw0100II,  VI+VII}, 
                        ^~~~~~~~
va2.c:57:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0100II,  VI+VII}, {bw0100II,  VI+VII}, {bw0100II,  VI+VII}, 
                                             ^~~~~~~~
va2.c:58:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0100II,  VI+VII}, {bw0100II,  VI},     {bw0100II,  VI+VII},
   ^~~~~~~~
va2.c:58:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0100II,  VI+VII}, {bw0100II,  VI},     {bw0100II,  VI+VII},
                        ^~~~~~~~
va2.c:58:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0100II,  VI+VII}, {bw0100II,  VI},     {bw0100II,  VI+VII},
                                             ^~~~~~~~
va2.c:59:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0100II,  VI+VII}, {bw0100II,  VI+VII}, {bw0100II,  VI+VII},
   ^~~~~~~~
va2.c:59:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0100II,  VI+VII}, {bw0100II,  VI+VII}, {bw0100II,  VI+VII},
                        ^~~~~~~~
va2.c:59:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0100II,  VI+VII}, {bw0100II,  VI+VII}, {bw0100II,  VI+VII},
                                             ^~~~~~~~
va2.c:60:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0100II,  VI+VII}, {bw0100II,  VI+VII}, {bw0100II,  VI+VII}, {0,0}}, 
   ^~~~~~~~
va2.c:60:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0100II,  VI+VII}, {bw0100II,  VI+VII}, {bw0100II,  VI+VII}, {0,0}}, 
                        ^~~~~~~~
va2.c:60:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0100II,  VI+VII}, {bw0100II,  VI+VII}, {bw0100II,  VI+VII}, {0,0}}, 
                                             ^~~~~~~~
va2.c:66:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0101II,  VI+VII}, {bw0101II,  VI+VII}, {bw0101II,  VI+VII}, 
   ^~~~~~~~
va2.c:66:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0101II,  VI+VII}, {bw0101II,  VI+VII}, {bw0101II,  VI+VII}, 
                        ^~~~~~~~
va2.c:66:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0101II,  VI+VII}, {bw0101II,  VI+VII}, {bw0101II,  VI+VII}, 
                                             ^~~~~~~~
va2.c:67:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0101II,  VI+VII}, {bw0101II,  VI},     {bw0101II,  VI+VII},
   ^~~~~~~~
va2.c:67:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0101II,  VI+VII}, {bw0101II,  VI},     {bw0101II,  VI+VII},
                        ^~~~~~~~
va2.c:67:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0101II,  VI+VII}, {bw0101II,  VI},     {bw0101II,  VI+VII},
                                             ^~~~~~~~
va2.c:68:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0101II,  VI+VII}, {bw0101II,  VI+VII}, {bw0101II,  VI+VII},
   ^~~~~~~~
va2.c:68:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0101II,  VI+VII}, {bw0101II,  VI+VII}, {bw0101II,  VI+VII},
                        ^~~~~~~~
va2.c:68:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0101II,  VI+VII}, {bw0101II,  VI+VII}, {bw0101II,  VI+VII},
                                             ^~~~~~~~
va2.c:69:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0101II,  VI+VII}, {bw0101II,  VI+VII}, {bw0101II,  VI+VII}, {0,0}}, 
   ^~~~~~~~
va2.c:69:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0101II,  VI+VII}, {bw0101II,  VI+VII}, {bw0101II,  VI+VII}, {0,0}}, 
                        ^~~~~~~~
va2.c:69:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0101II,  VI+VII}, {bw0101II,  VI+VII}, {bw0101II,  VI+VII}, {0,0}}, 
                                             ^~~~~~~~
va2.c:75:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0110II,  VI+VII}, {bw0110II,  VI+VII}, {bw0110II,  VI+VII}, 
   ^~~~~~~~
va2.c:75:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0110II,  VI+VII}, {bw0110II,  VI+VII}, {bw0110II,  VI+VII}, 
                        ^~~~~~~~
va2.c:75:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0110II,  VI+VII}, {bw0110II,  VI+VII}, {bw0110II,  VI+VII}, 
                                             ^~~~~~~~
va2.c:76:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0110II,  VI+VII}, {bw0110II,  VI},     {bw0110II,  VI+VII},
   ^~~~~~~~
va2.c:76:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0110II,  VI+VII}, {bw0110II,  VI},     {bw0110II,  VI+VII},
                        ^~~~~~~~
va2.c:76:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0110II,  VI+VII}, {bw0110II,  VI},     {bw0110II,  VI+VII},
                                             ^~~~~~~~
va2.c:77:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0110II,  VI+VII}, {bw0110II,  VI+VII}, {bw0110II,  VI+VII},
   ^~~~~~~~
va2.c:77:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0110II,  VI+VII}, {bw0110II,  VI+VII}, {bw0110II,  VI+VII},
                        ^~~~~~~~
va2.c:77:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0110II,  VI+VII}, {bw0110II,  VI+VII}, {bw0110II,  VI+VII},
                                             ^~~~~~~~
va2.c:78:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0110II,  VI+VII}, {bw0110II,  VI+VII}, {bw0110II,  VI+VII}, {0,0}}, 
   ^~~~~~~~
va2.c:78:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0110II,  VI+VII}, {bw0110II,  VI+VII}, {bw0110II,  VI+VII}, {0,0}}, 
                        ^~~~~~~~
va2.c:78:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0110II,  VI+VII}, {bw0110II,  VI+VII}, {bw0110II,  VI+VII}, {0,0}}, 
                                             ^~~~~~~~
va2.c:84:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0111II,  VI+VII}, {bw0111II,  VI+VII}, {bw0111II,  VI+VII}, 
   ^~~~~~~~
va2.c:84:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0111II,  VI+VII}, {bw0111II,  VI+VII}, {bw0111II,  VI+VII}, 
                        ^~~~~~~~
va2.c:84:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw0111II,  VI+VII}, {bw0111II,  VI+VII}, {bw0111II,  VI+VII}, 
                                             ^~~~~~~~
va2.c:85:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0111II,  VI+VII}, {bw0111II,  VI},     {bw0111II,  VI+VII},
   ^~~~~~~~
va2.c:85:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0111II,  VI+VII}, {bw0111II,  VI},     {bw0111II,  VI+VII},
                        ^~~~~~~~
va2.c:85:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0111II,  VI+VII}, {bw0111II,  VI},     {bw0111II,  VI+VII},
                                             ^~~~~~~~
va2.c:86:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0111II,  VI+VII}, {bw0111II,  VI+VII}, {bw0111II,  VI+VII},
   ^~~~~~~~
va2.c:86:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0111II,  VI+VII}, {bw0111II,  VI+VII}, {bw0111II,  VI+VII},
                        ^~~~~~~~
va2.c:86:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0111II,  VI+VII}, {bw0111II,  VI+VII}, {bw0111II,  VI+VII},
                                             ^~~~~~~~
va2.c:87:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0111II,  VI+VII}, {bw0111II,  VI+VII}, {bw0111II,  VI+VII}, {0,0}}, 
   ^~~~~~~~
va2.c:87:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0111II,  VI+VII}, {bw0111II,  VI+VII}, {bw0111II,  VI+VII}, {0,0}}, 
                        ^~~~~~~~
va2.c:87:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw0111II,  VI+VII}, {bw0111II,  VI+VII}, {bw0111II,  VI+VII}, {0,0}}, 
                                             ^~~~~~~~
va2.c:93:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1000II,  VI+VII}, {bw1000II,  VI+VII}, {bw1000II,  VI+VII}, 
   ^~~~~~~~
va2.c:93:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1000II,  VI+VII}, {bw1000II,  VI+VII}, {bw1000II,  VI+VII}, 
                        ^~~~~~~~
va2.c:93:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1000II,  VI+VII}, {bw1000II,  VI+VII}, {bw1000II,  VI+VII}, 
                                             ^~~~~~~~
va2.c:94:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1000II,  VI+VII}, {bw1000II,  VI},     {bw1000II,  VI+VII},
   ^~~~~~~~
va2.c:94:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1000II,  VI+VII}, {bw1000II,  VI},     {bw1000II,  VI+VII},
                        ^~~~~~~~
va2.c:94:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1000II,  VI+VII}, {bw1000II,  VI},     {bw1000II,  VI+VII},
                                             ^~~~~~~~
va2.c:95:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1000II,  VI+VII}, {bw1000II,  VI+VII}, {bw1000II,  VI+VII},
   ^~~~~~~~
va2.c:95:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1000II,  VI+VII}, {bw1000II,  VI+VII}, {bw1000II,  VI+VII},
                        ^~~~~~~~
va2.c:95:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1000II,  VI+VII}, {bw1000II,  VI+VII}, {bw1000II,  VI+VII},
                                             ^~~~~~~~
va2.c:96:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1000II,  VI+VII}, {bw1000II,  VI+VII}, {bw1000II,  VI+VII}, {0,0}}, 
   ^~~~~~~~
va2.c:96:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1000II,  VI+VII}, {bw1000II,  VI+VII}, {bw1000II,  VI+VII}, {0,0}}, 
                        ^~~~~~~~
va2.c:96:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1000II,  VI+VII}, {bw1000II,  VI+VII}, {bw1000II,  VI+VII}, {0,0}}, 
                                             ^~~~~~~~
va2.c:102:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1001II,  VI+VII}, {bw1001II,  VI+VII}, {bw1001II,  VI+VII}, 
   ^~~~~~~~
va2.c:102:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1001II,  VI+VII}, {bw1001II,  VI+VII}, {bw1001II,  VI+VII}, 
                        ^~~~~~~~
va2.c:102:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1001II,  VI+VII}, {bw1001II,  VI+VII}, {bw1001II,  VI+VII}, 
                                             ^~~~~~~~
va2.c:103:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1001II,  VI+VII}, {bw1001II,  VI},     {bw1001II,  VI+VII},
   ^~~~~~~~
va2.c:103:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1001II,  VI+VII}, {bw1001II,  VI},     {bw1001II,  VI+VII},
                        ^~~~~~~~
va2.c:103:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1001II,  VI+VII}, {bw1001II,  VI},     {bw1001II,  VI+VII},
                                             ^~~~~~~~
va2.c:104:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1001II,  VI+VII}, {bw1001II,  VI+VII}, {bw1001II,  VI+VII},
   ^~~~~~~~
va2.c:104:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1001II,  VI+VII}, {bw1001II,  VI+VII}, {bw1001II,  VI+VII},
                        ^~~~~~~~
va2.c:104:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1001II,  VI+VII}, {bw1001II,  VI+VII}, {bw1001II,  VI+VII},
                                             ^~~~~~~~
va2.c:105:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1001II,  VI+VII}, {bw1001II,  VI+VII}, {bw1001II,  VI+VII}, {0,0}}, 
   ^~~~~~~~
va2.c:105:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1001II,  VI+VII}, {bw1001II,  VI+VII}, {bw1001II,  VI+VII}, {0,0}}, 
                        ^~~~~~~~
va2.c:105:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1001II,  VI+VII}, {bw1001II,  VI+VII}, {bw1001II,  VI+VII}, {0,0}}, 
                                             ^~~~~~~~
va2.c:111:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1010II,  VI+VII}, {bw1010II,  VI+VII}, {bw1010II,  VI+VII}, 
   ^~~~~~~~
va2.c:111:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1010II,  VI+VII}, {bw1010II,  VI+VII}, {bw1010II,  VI+VII}, 
                        ^~~~~~~~
va2.c:111:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1010II,  VI+VII}, {bw1010II,  VI+VII}, {bw1010II,  VI+VII}, 
                                             ^~~~~~~~
va2.c:112:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1010II,  VI+VII}, {bw1010II,  VI},     {bw1010II,  VI+VII},
   ^~~~~~~~
va2.c:112:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1010II,  VI+VII}, {bw1010II,  VI},     {bw1010II,  VI+VII},
                        ^~~~~~~~
va2.c:112:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1010II,  VI+VII}, {bw1010II,  VI},     {bw1010II,  VI+VII},
                                             ^~~~~~~~
va2.c:113:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1010II,  VI+VII}, {bw1010II,  VI+VII}, {bw1010II,  VI+VII},
   ^~~~~~~~
va2.c:113:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1010II,  VI+VII}, {bw1010II,  VI+VII}, {bw1010II,  VI+VII},
                        ^~~~~~~~
va2.c:113:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1010II,  VI+VII}, {bw1010II,  VI+VII}, {bw1010II,  VI+VII},
                                             ^~~~~~~~
va2.c:114:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1010II,  VI+VII}, {bw1010II,  VI+VII}, {bw1010II,  VI+VII}, {0,0}}, 
   ^~~~~~~~
va2.c:114:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1010II,  VI+VII}, {bw1010II,  VI+VII}, {bw1010II,  VI+VII}, {0,0}}, 
                        ^~~~~~~~
va2.c:114:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1010II,  VI+VII}, {bw1010II,  VI+VII}, {bw1010II,  VI+VII}, {0,0}}, 
                                             ^~~~~~~~
va2.c:120:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1011II,  VI+VII}, {bw1011II,  VI+VII}, {bw1011II,  VI+VII}, 
   ^~~~~~~~
va2.c:120:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1011II,  VI+VII}, {bw1011II,  VI+VII}, {bw1011II,  VI+VII}, 
                        ^~~~~~~~
va2.c:120:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1011II,  VI+VII}, {bw1011II,  VI+VII}, {bw1011II,  VI+VII}, 
                                             ^~~~~~~~
va2.c:121:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1011II,  VI+VII}, {bw1011II,  VI},     {bw1011II,  VI+VII},
   ^~~~~~~~
va2.c:121:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1011II,  VI+VII}, {bw1011II,  VI},     {bw1011II,  VI+VII},
                        ^~~~~~~~
va2.c:121:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1011II,  VI+VII}, {bw1011II,  VI},     {bw1011II,  VI+VII},
                                             ^~~~~~~~
va2.c:122:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1011II,  VI+VII}, {bw1011II,  VI+VII}, {bw1011II,  VI+VII},
   ^~~~~~~~
va2.c:122:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1011II,  VI+VII}, {bw1011II,  VI+VII}, {bw1011II,  VI+VII},
                        ^~~~~~~~
va2.c:122:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1011II,  VI+VII}, {bw1011II,  VI+VII}, {bw1011II,  VI+VII},
                                             ^~~~~~~~
va2.c:123:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1011II,  VI+VII}, {bw1011II,  VI+VII}, {bw1011II,  VI+VII}, {0,0}}, 
   ^~~~~~~~
va2.c:123:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1011II,  VI+VII}, {bw1011II,  VI+VII}, {bw1011II,  VI+VII}, {0,0}}, 
                        ^~~~~~~~
va2.c:123:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1011II,  VI+VII}, {bw1011II,  VI+VII}, {bw1011II,  VI+VII}, {0,0}}, 
                                             ^~~~~~~~
va2.c:129:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1100II,  VI+VII}, {bw1100II,  VI+VII}, {bw1100II,  VI+VII}, 
   ^~~~~~~~
va2.c:129:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1100II,  VI+VII}, {bw1100II,  VI+VII}, {bw1100II,  VI+VII}, 
                        ^~~~~~~~
va2.c:129:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1100II,  VI+VII}, {bw1100II,  VI+VII}, {bw1100II,  VI+VII}, 
                                             ^~~~~~~~
va2.c:130:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1100II,  VI+VII}, {bw1100II,  VI},     {bw1100II,  VI+VII},
   ^~~~~~~~
va2.c:130:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1100II,  VI+VII}, {bw1100II,  VI},     {bw1100II,  VI+VII},
                        ^~~~~~~~
va2.c:130:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1100II,  VI+VII}, {bw1100II,  VI},     {bw1100II,  VI+VII},
                                             ^~~~~~~~
va2.c:131:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1100II,  VI+VII}, {bw1100II,  VI+VII}, {bw1100II,  VI+VII},
   ^~~~~~~~
va2.c:131:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1100II,  VI+VII}, {bw1100II,  VI+VII}, {bw1100II,  VI+VII},
                        ^~~~~~~~
va2.c:131:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1100II,  VI+VII}, {bw1100II,  VI+VII}, {bw1100II,  VI+VII},
                                             ^~~~~~~~
va2.c:132:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1100II,  VI+VII}, {bw1100II,  VI+VII}, {bw1100II,  VI+VII}, {0,0}}, 
   ^~~~~~~~
va2.c:132:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1100II,  VI+VII}, {bw1100II,  VI+VII}, {bw1100II,  VI+VII}, {0,0}}, 
                        ^~~~~~~~
va2.c:132:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1100II,  VI+VII}, {bw1100II,  VI+VII}, {bw1100II,  VI+VII}, {0,0}}, 
                                             ^~~~~~~~
va2.c:138:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1101II,  VI+VII}, {bw1101II,  VI+VII}, {bw1101II,  VI+VII}, 
   ^~~~~~~~
va2.c:138:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1101II,  VI+VII}, {bw1101II,  VI+VII}, {bw1101II,  VI+VII}, 
                        ^~~~~~~~
va2.c:138:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1101II,  VI+VII}, {bw1101II,  VI+VII}, {bw1101II,  VI+VII}, 
                                             ^~~~~~~~
va2.c:139:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1101II,  VI+VII}, {bw1101II,  VI},     {bw1101II,  VI+VII},
   ^~~~~~~~
va2.c:139:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1101II,  VI+VII}, {bw1101II,  VI},     {bw1101II,  VI+VII},
                        ^~~~~~~~
va2.c:139:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1101II,  VI+VII}, {bw1101II,  VI},     {bw1101II,  VI+VII},
                                             ^~~~~~~~
va2.c:140:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1101II,  VI+VII}, {bw1101II,  VI+VII}, {bw1101II,  VI+VII},
   ^~~~~~~~
va2.c:140:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1101II,  VI+VII}, {bw1101II,  VI+VII}, {bw1101II,  VI+VII},
                        ^~~~~~~~
va2.c:140:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1101II,  VI+VII}, {bw1101II,  VI+VII}, {bw1101II,  VI+VII},
                                             ^~~~~~~~
va2.c:141:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1101II,  VI+VII}, {bw1101II,  VI+VII}, {bw1101II,  VI+VII}, {0,0}}, 
   ^~~~~~~~
va2.c:141:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1101II,  VI+VII}, {bw1101II,  VI+VII}, {bw1101II,  VI+VII}, {0,0}}, 
                        ^~~~~~~~
va2.c:141:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1101II,  VI+VII}, {bw1101II,  VI+VII}, {bw1101II,  VI+VII}, {0,0}}, 
                                             ^~~~~~~~
va2.c:147:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1110II,  VI+VII}, {bw1110II,  VI+VII}, {bw1110II,  VI+VII}, 
   ^~~~~~~~
va2.c:147:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1110II,  VI+VII}, {bw1110II,  VI+VII}, {bw1110II,  VI+VII}, 
                        ^~~~~~~~
va2.c:147:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1110II,  VI+VII}, {bw1110II,  VI+VII}, {bw1110II,  VI+VII}, 
                                             ^~~~~~~~
va2.c:148:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1110II,  VI+VII}, {bw1110II,  VI},     {bw1110II,  VI+VII},
   ^~~~~~~~
va2.c:148:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1110II,  VI+VII}, {bw1110II,  VI},     {bw1110II,  VI+VII},
                        ^~~~~~~~
va2.c:148:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1110II,  VI+VII}, {bw1110II,  VI},     {bw1110II,  VI+VII},
                                             ^~~~~~~~
va2.c:149:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1110II,  VI+VII}, {bw1110II,  VI+VII}, {bw1110II,  VI+VII},
   ^~~~~~~~
va2.c:149:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1110II,  VI+VII}, {bw1110II,  VI+VII}, {bw1110II,  VI+VII},
                        ^~~~~~~~
va2.c:149:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1110II,  VI+VII}, {bw1110II,  VI+VII}, {bw1110II,  VI+VII},
                                             ^~~~~~~~
va2.c:150:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1110II,  VI+VII}, {bw1110II,  VI+VII}, {bw1110II,  VI+VII}, {0,0}}, 
   ^~~~~~~~
va2.c:150:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1110II,  VI+VII}, {bw1110II,  VI+VII}, {bw1110II,  VI+VII}, {0,0}}, 
                        ^~~~~~~~
va2.c:150:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1110II,  VI+VII}, {bw1110II,  VI+VII}, {bw1110II,  VI+VII}, {0,0}}, 
                                             ^~~~~~~~
va2.c:156:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1111II,  VI+VII}, {bw1111II,  VI+VII}, {bw1111II,  VI+VII}, 
   ^~~~~~~~
va2.c:156:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1111II,  VI+VII}, {bw1111II,  VI+VII}, {bw1111II,  VI+VII}, 
                        ^~~~~~~~
va2.c:156:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
 {{bw1111II,  VI+VII}, {bw1111II,  VI+VII}, {bw1111II,  VI+VII}, 
                                             ^~~~~~~~
va2.c:157:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1111II,  VI+VII}, {bw1111II,  VI},     {bw1111II,  VI+VII},
   ^~~~~~~~
va2.c:157:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1111II,  VI+VII}, {bw1111II,  VI},     {bw1111II,  VI+VII},
                        ^~~~~~~~
va2.c:157:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1111II,  VI+VII}, {bw1111II,  VI},     {bw1111II,  VI+VII},
                                             ^~~~~~~~
va2.c:158:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1111II,  VI+VII}, {bw1111II,  VI+VII}, {bw1111II,  VI+VII},
   ^~~~~~~~
va2.c:158:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1111II,  VI+VII}, {bw1111II,  VI+VII}, {bw1111II,  VI+VII},
                        ^~~~~~~~
va2.c:158:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1111II,  VI+VII}, {bw1111II,  VI+VII}, {bw1111II,  VI+VII},
                                             ^~~~~~~~
va2.c:159:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1111II,  VI+VII}, {bw1111II,  VI+VII}, {bw1111II,  VI+VII}, {0,0}}, 
   ^~~~~~~~
va2.c:159:25: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1111II,  VI+VII}, {bw1111II,  VI+VII}, {bw1111II,  VI+VII}, {0,0}}, 
                        ^~~~~~~~
va2.c:159:46: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, UI *, UI *, UI *)' [-Wincompatible-pointer-types]
  {bw1111II,  VI+VII}, {bw1111II,  VI+VII}, {bw1111II,  VI+VII}, {0,0}}, 
                                             ^~~~~~~~
va2.c:165:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{leBB, VB        }, {binDD,VD+VDD+VRI}, {binDD,VD+VDD}, 
   ^~~~
va2.c:165:24: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
 {{leBB, VB        }, {binDD,VD+VDD+VRI}, {binDD,VD+VDD}, 
                       ^~~~~
va2.c:165:44: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
 {{leBB, VB        }, {binDD,VD+VDD+VRI}, {binDD,VD+VDD}, 
                                           ^~~~~
va2.c:166:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {binDD,VD+VDD+VRI}, {binDD,VD+VDD+VRI}, {binDD,VD+VDD}, 
   ^~~~~
va2.c:166:24: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {binDD,VD+VDD+VRI}, {binDD,VD+VDD+VRI}, {binDD,VD+VDD}, 
                       ^~~~~
va2.c:166:44: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {binDD,VD+VDD+VRI}, {binDD,VD+VDD+VRI}, {binDD,VD+VDD}, 
                                           ^~~~~
va2.c:167:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {binDD,VD+VDD    }, {binDD,VD+VDD    }, {binDD,VD    }, 
   ^~~~~
va2.c:167:24: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {binDD,VD+VDD    }, {binDD,VD+VDD    }, {binDD,VD    }, 
                       ^~~~~
va2.c:167:44: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {binDD,VD+VDD    }, {binDD,VD+VDD    }, {binDD,VD    }, 
                                           ^~~~~
va2.c:168:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Z *, Z *, Z *)' [-Wincompatible-pointer-types]
  {binZZ,VZ+VZZ}, {binXX,VX+VXX}, {binQQ,VX+VQQ}, {0,0}}, 
   ^~~~~
va2.c:168:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, X *, X *, X *)' [-Wincompatible-pointer-types]
  {binZZ,VZ+VZZ}, {binXX,VX+VXX}, {binQQ,VX+VQQ}, {0,0}}, 
                   ^~~~~
va2.c:168:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, X *, Q *, Q *)' [-Wincompatible-pointer-types]
  {binZZ,VZ+VZZ}, {binXX,VX+VXX}, {binQQ,VX+VQQ}, {0,0}}, 
                                   ^~~~~
va2.c:174:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, B *, B *)' [-Wincompatible-pointer-types]
 {{divBB,VD}, {divBI,VD}, {divBD,VD},
   ^~~~~
va2.c:174:16: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, B *, I *)' [-Wincompatible-pointer-types]
 {{divBB,VD}, {divBI,VD}, {divBD,VD},
               ^~~~~
va2.c:174:28: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, B *, D *)' [-Wincompatible-pointer-types]
 {{divBB,VD}, {divBI,VD}, {divBD,VD},
                           ^~~~~
va2.c:175:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, I *, B *)' [-Wincompatible-pointer-types]
  {divIB,VD}, {divII,VD}, {divID,VD},
   ^~~~~
va2.c:175:16: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, I *, I *)' [-Wincompatible-pointer-types]
  {divIB,VD}, {divII,VD}, {divID,VD},
               ^~~~~
va2.c:175:28: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, I *, D *)' [-Wincompatible-pointer-types]
  {divIB,VD}, {divII,VD}, {divID,VD},
                           ^~~~~
va2.c:176:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, B *)' [-Wincompatible-pointer-types]
  {divDB,VD}, {divDI,VD}, {divDD,VD}, 
   ^~~~~
va2.c:176:16: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, I *)' [-Wincompatible-pointer-types]
  {divDB,VD}, {divDI,VD}, {divDD,VD}, 
               ^~~~~
va2.c:176:28: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {divDB,VD}, {divDI,VD}, {divDD,VD}, 
                           ^~~~~
va2.c:177:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Z *, Z *, Z *)' [-Wincompatible-pointer-types]
  {divZZ,VZ+VZZ}, {divXX,VX+VXX}, {divQQ,VQ+VQQ}, {0,0}},
   ^~~~~
va2.c:177:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, X *, X *, X *)' [-Wincompatible-pointer-types]
  {divZZ,VZ+VZZ}, {divXX,VX+VXX}, {divQQ,VQ+VQQ}, {0,0}},
                   ^~~~~
va2.c:177:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Q *, Q *, Q *)' [-Wincompatible-pointer-types]
  {divZZ,VZ+VZZ}, {divXX,VX+VXX}, {divQQ,VQ+VQQ}, {0,0}},
                                   ^~~~~
va2.c:183:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{andBB,  VB}, {tymesBI,VI}, {tymesBD,VD},
   ^~~~~
va2.c:183:18: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, B *, I *)' [-Wincompatible-pointer-types]
 {{andBB,  VB}, {tymesBI,VI}, {tymesBD,VD},
                 ^~~~~~~
va2.c:183:32: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, B *, D *)' [-Wincompatible-pointer-types]
 {{andBB,  VB}, {tymesBI,VI}, {tymesBD,VD},
                               ^~~~~~~
va2.c:184:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, B *)' [-Wincompatible-pointer-types]
  {tymesIB,VI}, {tymesII,VI}, {tymesID,VD},
   ^~~~~~~
va2.c:184:18: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
  {tymesIB,VI}, {tymesII,VI}, {tymesID,VD},
                 ^~~~~~~
va2.c:184:32: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, I *, D *)' [-Wincompatible-pointer-types]
  {tymesIB,VI}, {tymesII,VI}, {tymesID,VD},
                               ^~~~~~~
va2.c:185:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, B *)' [-Wincompatible-pointer-types]
  {tymesDB,VD}, {tymesDI,VD}, {tymesDD,VD}, 
   ^~~~~~~
va2.c:185:18: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, I *, D *)' [-Wincompatible-pointer-types]
  {tymesDB,VD}, {tymesDI,VD}, {tymesDD,VD}, 
                 ^~~~~~~
va2.c:185:32: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {tymesDB,VD}, {tymesDI,VD}, {tymesDD,VD}, 
                               ^~~~~~~
va2.c:186:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Z *, Z *, Z *)' [-Wincompatible-pointer-types]
  {tymesZZ,VZ+VZZ}, {tymesXX,VX+VXX}, {tymesQQ,VQ+VQQ}, {0,0}},
   ^~~~~~~
va2.c:186:22: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, X *, X *, X *)' [-Wincompatible-pointer-types]
  {tymesZZ,VZ+VZZ}, {tymesXX,VX+VXX}, {tymesQQ,VQ+VQQ}, {0,0}},
                     ^~~~~~~
va2.c:186:40: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Q *, Q *, Q *)' [-Wincompatible-pointer-types]
  {tymesZZ,VZ+VZZ}, {tymesXX,VX+VXX}, {tymesQQ,VQ+VQQ}, {0,0}},
                                       ^~~~~~~
va2.c:192:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, B *, B *)' [-Wincompatible-pointer-types]
 {{plusBB,VI    }, {plusII,VI+VII}, {plusBD,VD}, 
   ^~~~~~
va2.c:192:21: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
 {{plusBB,VI    }, {plusII,VI+VII}, {plusBD,VD}, 
                    ^~~~~~
va2.c:192:38: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, B *, D *)' [-Wincompatible-pointer-types]
 {{plusBB,VI    }, {plusII,VI+VII}, {plusBD,VD}, 
                                     ^~~~~~
va2.c:193:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
  {plusII,VI+VII}, {plusII,VI    }, {plusID,VD}, 
   ^~~~~~
va2.c:193:21: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
  {plusII,VI+VII}, {plusII,VI    }, {plusID,VD}, 
                    ^~~~~~
va2.c:193:38: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, I *, D *)' [-Wincompatible-pointer-types]
  {plusII,VI+VII}, {plusII,VI    }, {plusID,VD}, 
                                     ^~~~~~
va2.c:194:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, B *)' [-Wincompatible-pointer-types]
  {plusDB,VD    }, {plusDI,VD    }, {plusDD,VD}, 
   ^~~~~~
va2.c:194:21: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, I *)' [-Wincompatible-pointer-types]
  {plusDB,VD    }, {plusDI,VD    }, {plusDD,VD}, 
                    ^~~~~~
va2.c:194:38: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {plusDB,VD    }, {plusDI,VD    }, {plusDD,VD}, 
                                     ^~~~~~
va2.c:195:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Z *, Z *, Z *)' [-Wincompatible-pointer-types]
  {plusZZ,VZ+VZZ}, {plusXX,VX+VXX}, {plusQQ,VQ+VQQ}, {0,0}},
   ^~~~~~
va2.c:195:21: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, X *, X *, X *)' [-Wincompatible-pointer-types]
  {plusZZ,VZ+VZZ}, {plusXX,VX+VXX}, {plusQQ,VQ+VQQ}, {0,0}},
                    ^~~~~~
va2.c:195:38: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Q *, Q *, Q *)' [-Wincompatible-pointer-types]
  {plusZZ,VZ+VZZ}, {plusXX,VX+VXX}, {plusQQ,VQ+VQQ}, {0,0}},
                                     ^~~~~~
va2.c:201:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, B *, B *)' [-Wincompatible-pointer-types]
 {{minusBB,VI    }, {minusII,VI+VII}, {minusBD,VD}, 
   ^~~~~~~
va2.c:201:22: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
 {{minusBB,VI    }, {minusII,VI+VII}, {minusBD,VD}, 
                     ^~~~~~~
va2.c:201:40: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, B *, D *)' [-Wincompatible-pointer-types]
 {{minusBB,VI    }, {minusII,VI+VII}, {minusBD,VD}, 
                                       ^~~~~~~
va2.c:202:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
  {minusII,VI+VII}, {minusII,VI    }, {minusID,VD},
   ^~~~~~~
va2.c:202:22: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
  {minusII,VI+VII}, {minusII,VI    }, {minusID,VD},
                     ^~~~~~~
va2.c:202:40: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, I *, D *)' [-Wincompatible-pointer-types]
  {minusII,VI+VII}, {minusII,VI    }, {minusID,VD},
                                       ^~~~~~~
va2.c:203:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, B *)' [-Wincompatible-pointer-types]
  {minusDB,VD    }, {minusDI,VD    }, {minusDD,VD}, 
   ^~~~~~~
va2.c:203:22: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, I *)' [-Wincompatible-pointer-types]
  {minusDB,VD    }, {minusDI,VD    }, {minusDD,VD}, 
                     ^~~~~~~
va2.c:203:40: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {minusDB,VD    }, {minusDI,VD    }, {minusDD,VD}, 
                                       ^~~~~~~
va2.c:204:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Z *, Z *, Z *)' [-Wincompatible-pointer-types]
  {minusZZ,VZ+VZZ}, {minusXX,VX+VXX}, {minusQQ,VQ+VQQ}, {0,0}},
   ^~~~~~~
va2.c:204:22: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, X *, X *, X *)' [-Wincompatible-pointer-types]
  {minusZZ,VZ+VZZ}, {minusXX,VX+VXX}, {minusQQ,VQ+VQQ}, {0,0}},
                     ^~~~~~~
va2.c:204:40: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Q *, Q *, Q *)' [-Wincompatible-pointer-types]
  {minusZZ,VZ+VZZ}, {minusXX,VX+VXX}, {minusQQ,VQ+VQQ}, {0,0}},
                                       ^~~~~~~
va2.c:210:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{ltBB,VB}, {ltBI,VB}, {ltBD,VB},
   ^~~~
va2.c:210:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, I *)' [-Wincompatible-pointer-types]
 {{ltBB,VB}, {ltBI,VB}, {ltBD,VB},
              ^~~~
va2.c:210:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, D *)' [-Wincompatible-pointer-types]
 {{ltBB,VB}, {ltBI,VB}, {ltBD,VB},
                         ^~~~
va2.c:211:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, B *)' [-Wincompatible-pointer-types]
  {ltIB,VB}, {ltII,VB}, {ltID,VB},
   ^~~~
va2.c:211:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, I *)' [-Wincompatible-pointer-types]
  {ltIB,VB}, {ltII,VB}, {ltID,VB},
              ^~~~
va2.c:211:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, D *)' [-Wincompatible-pointer-types]
  {ltIB,VB}, {ltII,VB}, {ltID,VB},
                         ^~~~
va2.c:212:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, B *)' [-Wincompatible-pointer-types]
  {ltDB,VB}, {ltDI,VB}, {ltDD,VB}, 
   ^~~~
va2.c:212:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, I *)' [-Wincompatible-pointer-types]
  {ltDB,VB}, {ltDI,VB}, {ltDD,VB}, 
              ^~~~
va2.c:212:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, D *)' [-Wincompatible-pointer-types]
  {ltDB,VB}, {ltDI,VB}, {ltDD,VB}, 
                         ^~~~
va2.c:213:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, D *)' [-Wincompatible-pointer-types]
  {ltDD,VB+VDD}, {ltXX,VB+VXFC}, {ltQQ,VB+VQQ}, {ltSS,VB}},
   ^~~~
va2.c:213:19: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, X *, X *)' [-Wincompatible-pointer-types]
  {ltDD,VB+VDD}, {ltXX,VB+VXFC}, {ltQQ,VB+VQQ}, {ltSS,VB}},
                  ^~~~
va2.c:213:35: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, Q *, Q *)' [-Wincompatible-pointer-types]
  {ltDD,VB+VDD}, {ltXX,VB+VXFC}, {ltQQ,VB+VQQ}, {ltSS,VB}},
                                  ^~~~
va2.c:213:50: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, SB *, SB *)' [-Wincompatible-pointer-types]
  {ltDD,VB+VDD}, {ltXX,VB+VXFC}, {ltQQ,VB+VQQ}, {ltSS,VB}},
                                                 ^~~~
va2.c:219:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{eqBB,VB}, {eqBI,VB}, {eqBD,VB},
   ^~~~
va2.c:219:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, I *)' [-Wincompatible-pointer-types]
 {{eqBB,VB}, {eqBI,VB}, {eqBD,VB},
              ^~~~
va2.c:219:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, D *)' [-Wincompatible-pointer-types]
 {{eqBB,VB}, {eqBI,VB}, {eqBD,VB},
                         ^~~~
va2.c:220:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, B *)' [-Wincompatible-pointer-types]
  {eqIB,VB}, {eqII,VB}, {eqID,VB},
   ^~~~
va2.c:220:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, I *)' [-Wincompatible-pointer-types]
  {eqIB,VB}, {eqII,VB}, {eqID,VB},
              ^~~~
va2.c:220:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, D *)' [-Wincompatible-pointer-types]
  {eqIB,VB}, {eqII,VB}, {eqID,VB},
                         ^~~~
va2.c:221:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, B *)' [-Wincompatible-pointer-types]
  {eqDB,VB}, {eqDI,VB}, {eqDD,VB}, 
   ^~~~
va2.c:221:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, I *)' [-Wincompatible-pointer-types]
  {eqDB,VB}, {eqDI,VB}, {eqDD,VB}, 
              ^~~~
va2.c:221:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, D *)' [-Wincompatible-pointer-types]
  {eqDB,VB}, {eqDI,VB}, {eqDD,VB}, 
                         ^~~~
va2.c:222:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, Z *, Z *)' [-Wincompatible-pointer-types]
  {eqZZ,VB+VZZ}, {eqXX,VB+VXEQ}, {eqQQ,VB+VQQ}, {eqII,VB}},
   ^~~~
va2.c:222:19: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, X *, X *)' [-Wincompatible-pointer-types]
  {eqZZ,VB+VZZ}, {eqXX,VB+VXEQ}, {eqQQ,VB+VQQ}, {eqII,VB}},
                  ^~~~
va2.c:222:35: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, Q *, Q *)' [-Wincompatible-pointer-types]
  {eqZZ,VB+VZZ}, {eqXX,VB+VXEQ}, {eqQQ,VB+VQQ}, {eqII,VB}},
                                  ^~~~
va2.c:222:50: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, I *)' [-Wincompatible-pointer-types]
  {eqZZ,VB+VZZ}, {eqXX,VB+VXEQ}, {eqQQ,VB+VQQ}, {eqII,VB}},
                                                 ^~~~
va2.c:228:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{gtBB,VB}, {gtBI,VB}, {gtBD,VB},
   ^~~~
va2.c:228:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, I *)' [-Wincompatible-pointer-types]
 {{gtBB,VB}, {gtBI,VB}, {gtBD,VB},
              ^~~~
va2.c:228:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, D *)' [-Wincompatible-pointer-types]
 {{gtBB,VB}, {gtBI,VB}, {gtBD,VB},
                         ^~~~
va2.c:229:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, B *)' [-Wincompatible-pointer-types]
  {gtIB,VB}, {gtII,VB}, {gtID,VB},
   ^~~~
va2.c:229:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, I *)' [-Wincompatible-pointer-types]
  {gtIB,VB}, {gtII,VB}, {gtID,VB},
              ^~~~
va2.c:229:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, D *)' [-Wincompatible-pointer-types]
  {gtIB,VB}, {gtII,VB}, {gtID,VB},
                         ^~~~
va2.c:230:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, B *)' [-Wincompatible-pointer-types]
  {gtDB,VB}, {gtDI,VB}, {gtDD,VB}, 
   ^~~~
va2.c:230:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, I *)' [-Wincompatible-pointer-types]
  {gtDB,VB}, {gtDI,VB}, {gtDD,VB}, 
              ^~~~
va2.c:230:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, D *)' [-Wincompatible-pointer-types]
  {gtDB,VB}, {gtDI,VB}, {gtDD,VB}, 
                         ^~~~
va2.c:231:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, D *)' [-Wincompatible-pointer-types]
  {gtDD,VB+VDD}, {gtXX,VB+VXCF}, {gtQQ,VB+VQQ}, {gtSS,VB}},
   ^~~~
va2.c:231:19: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, X *, X *)' [-Wincompatible-pointer-types]
  {gtDD,VB+VDD}, {gtXX,VB+VXCF}, {gtQQ,VB+VQQ}, {gtSS,VB}},
                  ^~~~
va2.c:231:35: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, Q *, Q *)' [-Wincompatible-pointer-types]
  {gtDD,VB+VDD}, {gtXX,VB+VXCF}, {gtQQ,VB+VQQ}, {gtSS,VB}},
                                  ^~~~
va2.c:231:50: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, SB *, SB *)' [-Wincompatible-pointer-types]
  {gtDD,VB+VDD}, {gtXX,VB+VXCF}, {gtQQ,VB+VQQ}, {gtSS,VB}},
                                                 ^~~~
va2.c:237:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{geBB, VB}, {powBI,VD}, {powBD,VD},
   ^~~~
va2.c:237:16: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, B *, I *)' [-Wincompatible-pointer-types]
 {{geBB, VB}, {powBI,VD}, {powBD,VD},
               ^~~~~
va2.c:237:28: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, B *, D *)' [-Wincompatible-pointer-types]
 {{geBB, VB}, {powBI,VD}, {powBD,VD},
                           ^~~~~
va2.c:238:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, B *)' [-Wincompatible-pointer-types]
  {powIB,VI}, {powII,VD}, {powID,VD},
   ^~~~~
va2.c:238:16: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, I *, I *)' [-Wincompatible-pointer-types]
  {powIB,VI}, {powII,VD}, {powID,VD},
               ^~~~~
va2.c:238:28: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, I *, D *)' [-Wincompatible-pointer-types]
  {powIB,VI}, {powII,VD}, {powID,VD},
                           ^~~~~
va2.c:239:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, B *)' [-Wincompatible-pointer-types]
  {powDB,VD}, {powDI,VD}, {powDD,VD}, 
   ^~~~~
va2.c:239:16: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, I *)' [-Wincompatible-pointer-types]
  {powDB,VD}, {powDI,VD}, {powDD,VD}, 
               ^~~~~
va2.c:239:28: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {powDB,VD}, {powDI,VD}, {powDD,VD}, 
                           ^~~~~
va2.c:240:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Z *, Z *, Z *)' [-Wincompatible-pointer-types]
  {powZZ,VZ+VZZ}, {powXX,VX+VXX}, {powQQ,VQ+VQQ}, {0,0}},
   ^~~~~
va2.c:240:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, X *, X *, X *)' [-Wincompatible-pointer-types]
  {powZZ,VZ+VZZ}, {powXX,VX+VXX}, {powQQ,VQ+VQQ}, {0,0}},
                   ^~~~~
va2.c:240:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Q *, Q *, Q *)' [-Wincompatible-pointer-types]
  {powZZ,VZ+VZZ}, {powXX,VX+VXX}, {powQQ,VQ+VQQ}, {0,0}},
                                   ^~~~~
va2.c:246:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{ltBB, VB    }, {remII,VI+VII}, {remDD,VD+VDD},
   ^~~~
va2.c:246:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
 {{ltBB, VB    }, {remII,VI+VII}, {remDD,VD+VDD},
                   ^~~~~
va2.c:246:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
 {{ltBB, VB    }, {remII,VI+VII}, {remDD,VD+VDD},
                                   ^~~~~
va2.c:247:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
  {remII,VI+VII}, {remII,VI    }, {remID,VI    },
   ^~~~~
va2.c:247:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
  {remII,VI+VII}, {remII,VI    }, {remID,VI    },
                   ^~~~~
va2.c:247:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, D *)' [-Wincompatible-pointer-types]
  {remII,VI+VII}, {remII,VI    }, {remID,VI    },
                                   ^~~~~
va2.c:248:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {remDD,VD+VDD}, {remDD,VD+VDD}, {remDD,VD    }, 
   ^~~~~
va2.c:248:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {remDD,VD+VDD}, {remDD,VD+VDD}, {remDD,VD    }, 
                   ^~~~~
va2.c:248:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {remDD,VD+VDD}, {remDD,VD+VDD}, {remDD,VD    }, 
                                   ^~~~~
va2.c:249:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Z *, Z *, Z *)' [-Wincompatible-pointer-types]
  {remZZ,VZ+VZZ}, {remXX,VX+VXX}, {remQQ,VQ+VQQ}, {0,0}},
   ^~~~~
va2.c:249:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, X *, X *, X *)' [-Wincompatible-pointer-types]
  {remZZ,VZ+VZZ}, {remXX,VX+VXX}, {remQQ,VQ+VQQ}, {0,0}},
                   ^~~~~
va2.c:249:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Q *, Q *, Q *)' [-Wincompatible-pointer-types]
  {remZZ,VZ+VZZ}, {remXX,VX+VXX}, {remQQ,VQ+VQQ}, {0,0}},
                                   ^~~~~
va2.c:255:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{andBB,VB}, {minBI,VI}, {minBD,VD},
   ^~~~~
va2.c:255:16: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, B *, I *)' [-Wincompatible-pointer-types]
 {{andBB,VB}, {minBI,VI}, {minBD,VD},
               ^~~~~
va2.c:255:28: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, B *, D *)' [-Wincompatible-pointer-types]
 {{andBB,VB}, {minBI,VI}, {minBD,VD},
                           ^~~~~
va2.c:256:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, B *)' [-Wincompatible-pointer-types]
  {minIB,VI}, {minII,VI}, {minID,VD},
   ^~~~~
va2.c:256:16: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
  {minIB,VI}, {minII,VI}, {minID,VD},
               ^~~~~
va2.c:256:28: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, I *, D *)' [-Wincompatible-pointer-types]
  {minIB,VI}, {minII,VI}, {minID,VD},
                           ^~~~~
va2.c:257:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, B *)' [-Wincompatible-pointer-types]
  {minDB,VD}, {minDI,VD}, {minDD,VD}, 
   ^~~~~
va2.c:257:16: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, I *)' [-Wincompatible-pointer-types]
  {minDB,VD}, {minDI,VD}, {minDD,VD}, 
               ^~~~~
va2.c:257:28: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {minDB,VD}, {minDI,VD}, {minDD,VD}, 
                           ^~~~~
va2.c:258:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {minDD,VD+VDD}, {minXX,VX+VXX}, {minQQ,VQ+VQQ}, {minSS,VSB}},
   ^~~~~
va2.c:258:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, X *, X *, X *)' [-Wincompatible-pointer-types]
  {minDD,VD+VDD}, {minXX,VX+VXX}, {minQQ,VQ+VQQ}, {minSS,VSB}},
                   ^~~~~
va2.c:258:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Q *, Q *, Q *)' [-Wincompatible-pointer-types]
  {minDD,VD+VDD}, {minXX,VX+VXX}, {minQQ,VQ+VQQ}, {minSS,VSB}},
                                   ^~~~~
va2.c:258:52: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, SB *, SB *, SB *)' [-Wincompatible-pointer-types]
  {minDD,VD+VDD}, {minXX,VX+VXX}, {minQQ,VQ+VQQ}, {minSS,VSB}},
                                                   ^~~~~
va2.c:264:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{leBB,VB}, {leBI,VB}, {leBD,VB},
   ^~~~
va2.c:264:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, I *)' [-Wincompatible-pointer-types]
 {{leBB,VB}, {leBI,VB}, {leBD,VB},
              ^~~~
va2.c:264:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, D *)' [-Wincompatible-pointer-types]
 {{leBB,VB}, {leBI,VB}, {leBD,VB},
                         ^~~~
va2.c:265:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, B *)' [-Wincompatible-pointer-types]
  {leIB,VB}, {leII,VB}, {leID,VB},
   ^~~~
va2.c:265:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, I *)' [-Wincompatible-pointer-types]
  {leIB,VB}, {leII,VB}, {leID,VB},
              ^~~~
va2.c:265:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, D *)' [-Wincompatible-pointer-types]
  {leIB,VB}, {leII,VB}, {leID,VB},
                         ^~~~
va2.c:266:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, B *)' [-Wincompatible-pointer-types]
  {leDB,VB}, {leDI,VB}, {leDD,VB}, 
   ^~~~
va2.c:266:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, I *)' [-Wincompatible-pointer-types]
  {leDB,VB}, {leDI,VB}, {leDD,VB}, 
              ^~~~
va2.c:266:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, D *)' [-Wincompatible-pointer-types]
  {leDB,VB}, {leDI,VB}, {leDD,VB}, 
                         ^~~~
va2.c:267:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, D *)' [-Wincompatible-pointer-types]
  {leDD,VB+VDD}, {leXX,VB+VXCF}, {leQQ,VB+VQQ}, {leSS,VB}},
   ^~~~
va2.c:267:19: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, X *, X *)' [-Wincompatible-pointer-types]
  {leDD,VB+VDD}, {leXX,VB+VXCF}, {leQQ,VB+VQQ}, {leSS,VB}},
                  ^~~~
va2.c:267:35: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, Q *, Q *)' [-Wincompatible-pointer-types]
  {leDD,VB+VDD}, {leXX,VB+VXCF}, {leQQ,VB+VQQ}, {leSS,VB}},
                                  ^~~~
va2.c:267:50: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, SB *, SB *)' [-Wincompatible-pointer-types]
  {leDD,VB+VDD}, {leXX,VB+VXCF}, {leQQ,VB+VQQ}, {leSS,VB}},
                                                 ^~~~
va2.c:273:5: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{ orBB,VB}, {maxBI,VI}, {maxBD,VD},
    ^~~~
va2.c:273:16: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, B *, I *)' [-Wincompatible-pointer-types]
 {{ orBB,VB}, {maxBI,VI}, {maxBD,VD},
               ^~~~~
va2.c:273:28: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, B *, D *)' [-Wincompatible-pointer-types]
 {{ orBB,VB}, {maxBI,VI}, {maxBD,VD},
                           ^~~~~
va2.c:274:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, B *)' [-Wincompatible-pointer-types]
  {maxIB,VI}, {maxII,VI}, {maxID,VD},
   ^~~~~
va2.c:274:16: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
  {maxIB,VI}, {maxII,VI}, {maxID,VD},
               ^~~~~
va2.c:274:28: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, D *)' [-Wincompatible-pointer-types]
  {maxIB,VI}, {maxII,VI}, {maxID,VD},
                           ^~~~~
va2.c:275:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, B *)' [-Wincompatible-pointer-types]
  {maxDB,VD}, {maxDI,VD}, {maxDD,VD}, 
   ^~~~~
va2.c:275:16: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, I *)' [-Wincompatible-pointer-types]
  {maxDB,VD}, {maxDI,VD}, {maxDD,VD}, 
               ^~~~~
va2.c:275:28: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {maxDB,VD}, {maxDI,VD}, {maxDD,VD}, 
                           ^~~~~
va2.c:276:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {maxDD,VD+VDD}, {maxXX,VX+VXX}, {maxQQ,VQ+VQQ}, {maxSS,VSB}},
   ^~~~~
va2.c:276:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, X *, X *, X *)' [-Wincompatible-pointer-types]
  {maxDD,VD+VDD}, {maxXX,VX+VXX}, {maxQQ,VQ+VQQ}, {maxSS,VSB}},
                   ^~~~~
va2.c:276:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Q *, Q *, Q *)' [-Wincompatible-pointer-types]
  {maxDD,VD+VDD}, {maxXX,VX+VXX}, {maxQQ,VQ+VQQ}, {maxSS,VSB}},
                                   ^~~~~
va2.c:276:52: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, SB *, SB *, SB *)' [-Wincompatible-pointer-types]
  {maxDD,VD+VDD}, {maxXX,VX+VXX}, {maxQQ,VQ+VQQ}, {maxSS,VSB}},
                                                   ^~~~~
va2.c:282:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{geBB,VB}, {geBI,VB}, {geBD,VB},
   ^~~~
va2.c:282:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, I *)' [-Wincompatible-pointer-types]
 {{geBB,VB}, {geBI,VB}, {geBD,VB},
              ^~~~
va2.c:282:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, D *)' [-Wincompatible-pointer-types]
 {{geBB,VB}, {geBI,VB}, {geBD,VB},
                         ^~~~
va2.c:283:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, B *)' [-Wincompatible-pointer-types]
  {geIB,VB}, {geII,VB}, {geID,VB},
   ^~~~
va2.c:283:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, I *)' [-Wincompatible-pointer-types]
  {geIB,VB}, {geII,VB}, {geID,VB},
              ^~~~
va2.c:283:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, D *)' [-Wincompatible-pointer-types]
  {geIB,VB}, {geII,VB}, {geID,VB},
                         ^~~~
va2.c:284:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, B *)' [-Wincompatible-pointer-types]
  {geDB,VB}, {geDI,VB}, {geDD,VB}, 
   ^~~~
va2.c:284:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, I *)' [-Wincompatible-pointer-types]
  {geDB,VB}, {geDI,VB}, {geDD,VB}, 
              ^~~~
va2.c:284:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, D *)' [-Wincompatible-pointer-types]
  {geDB,VB}, {geDI,VB}, {geDD,VB}, 
                         ^~~~
va2.c:285:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, D *)' [-Wincompatible-pointer-types]
  {geDD,VB+VDD}, {geXX,VB+VXFC}, {geQQ,VB+VQQ}, {geSS,VB}},
   ^~~~
va2.c:285:19: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, X *, X *)' [-Wincompatible-pointer-types]
  {geDD,VB+VDD}, {geXX,VB+VXFC}, {geQQ,VB+VQQ}, {geSS,VB}},
                  ^~~~
va2.c:285:35: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, Q *, Q *)' [-Wincompatible-pointer-types]
  {geDD,VB+VDD}, {geXX,VB+VXFC}, {geQQ,VB+VQQ}, {geSS,VB}},
                                  ^~~~
va2.c:285:50: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, SB *, SB *)' [-Wincompatible-pointer-types]
  {geDD,VB+VDD}, {geXX,VB+VXFC}, {geQQ,VB+VQQ}, {geSS,VB}},
                                                 ^~~~
va2.c:291:5: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{ orBB,VB    }, {gcdII,VI+VII}, {gcdDD,VD+VDD},
    ^~~~
va2.c:291:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
 {{ orBB,VB    }, {gcdII,VI+VII}, {gcdDD,VD+VDD},
                   ^~~~~
va2.c:291:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
 {{ orBB,VB    }, {gcdII,VI+VII}, {gcdDD,VD+VDD},
                                   ^~~~~
va2.c:292:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
  {gcdII,VI+VII}, {gcdII,VI    }, {gcdDD,VD+VDD},
   ^~~~~
va2.c:292:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
  {gcdII,VI+VII}, {gcdII,VI    }, {gcdDD,VD+VDD},
                   ^~~~~
va2.c:292:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {gcdII,VI+VII}, {gcdII,VI    }, {gcdDD,VD+VDD},
                                   ^~~~~
va2.c:293:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {gcdDD,VD+VDD}, {gcdDD,VD+VDD}, {gcdDD,VD    }, 
   ^~~~~
va2.c:293:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {gcdDD,VD+VDD}, {gcdDD,VD+VDD}, {gcdDD,VD    }, 
                   ^~~~~
va2.c:293:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {gcdDD,VD+VDD}, {gcdDD,VD+VDD}, {gcdDD,VD    }, 
                                   ^~~~~
va2.c:294:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Z *, Z *, Z *)' [-Wincompatible-pointer-types]
  {gcdZZ,VZ+VZZ}, {gcdXX,VX+VXX}, {gcdQQ,VQ+VQQ}, {0,0}},
   ^~~~~
va2.c:294:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, X *, X *, X *)' [-Wincompatible-pointer-types]
  {gcdZZ,VZ+VZZ}, {gcdXX,VX+VXX}, {gcdQQ,VQ+VQQ}, {0,0}},
                   ^~~~~
va2.c:294:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Q *, Q *, Q *)' [-Wincompatible-pointer-types]
  {gcdZZ,VZ+VZZ}, {gcdXX,VX+VXX}, {gcdQQ,VQ+VQQ}, {0,0}},
                                   ^~~~~
va2.c:300:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{norBB,VB    }, {norBB,VB+VBB}, {norBB,VB+VBB},
   ^~~~~
va2.c:300:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{norBB,VB    }, {norBB,VB+VBB}, {norBB,VB+VBB},
                   ^~~~~
va2.c:300:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{norBB,VB    }, {norBB,VB+VBB}, {norBB,VB+VBB},
                                   ^~~~~
va2.c:301:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {norBB,VB+VBB}, {norBB,VB+VBB}, {norBB,VB+VBB},
   ^~~~~
va2.c:301:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {norBB,VB+VBB}, {norBB,VB+VBB}, {norBB,VB+VBB},
                   ^~~~~
va2.c:301:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {norBB,VB+VBB}, {norBB,VB+VBB}, {norBB,VB+VBB},
                                   ^~~~~
va2.c:302:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {norBB,VB+VBB}, {norBB,VB+VBB}, {norBB,VB+VBB}, 
   ^~~~~
va2.c:302:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {norBB,VB+VBB}, {norBB,VB+VBB}, {norBB,VB+VBB}, 
                   ^~~~~
va2.c:302:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {norBB,VB+VBB}, {norBB,VB+VBB}, {norBB,VB+VBB}, 
                                   ^~~~~
va2.c:303:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {norBB,VB+VBB}, {norBB,VB+VBB}, {norBB,VB+VBB}, {0,0}},
   ^~~~~
va2.c:303:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {norBB,VB+VBB}, {norBB,VB+VBB}, {norBB,VB+VBB}, {0,0}},
                   ^~~~~
va2.c:303:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {norBB,VB+VBB}, {norBB,VB+VBB}, {norBB,VB+VBB}, {0,0}},
                                   ^~~~~
va2.c:309:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{andBB,VB    }, {lcmII,VI+VII}, {lcmDD,VD+VDD},
   ^~~~~
va2.c:309:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
 {{andBB,VB    }, {lcmII,VI+VII}, {lcmDD,VD+VDD},
                   ^~~~~
va2.c:309:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
 {{andBB,VB    }, {lcmII,VI+VII}, {lcmDD,VD+VDD},
                                   ^~~~~
va2.c:310:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
  {lcmII,VI+VII}, {lcmII,VI    }, {lcmDD,VD+VDD},
   ^~~~~
va2.c:310:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, I *, I *, I *)' [-Wincompatible-pointer-types]
  {lcmII,VI+VII}, {lcmII,VI    }, {lcmDD,VD+VDD},
                   ^~~~~
va2.c:310:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {lcmII,VI+VII}, {lcmII,VI    }, {lcmDD,VD+VDD},
                                   ^~~~~
va2.c:311:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {lcmDD,VD+VDD}, {lcmDD,VD+VDD}, {lcmDD,VD    }, 
   ^~~~~
va2.c:311:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {lcmDD,VD+VDD}, {lcmDD,VD+VDD}, {lcmDD,VD    }, 
                   ^~~~~
va2.c:311:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {lcmDD,VD+VDD}, {lcmDD,VD+VDD}, {lcmDD,VD    }, 
                                   ^~~~~
va2.c:312:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Z *, Z *, Z *)' [-Wincompatible-pointer-types]
  {lcmZZ,VZ+VZZ}, {lcmXX,VX+VXX}, {lcmQQ,VQ+VQQ}, {0,0}},
   ^~~~~
va2.c:312:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, X *, X *, X *)' [-Wincompatible-pointer-types]
  {lcmZZ,VZ+VZZ}, {lcmXX,VX+VXX}, {lcmQQ,VQ+VQQ}, {0,0}},
                   ^~~~~
va2.c:312:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Q *, Q *, Q *)' [-Wincompatible-pointer-types]
  {lcmZZ,VZ+VZZ}, {lcmXX,VX+VXX}, {lcmQQ,VQ+VQQ}, {0,0}},
                                   ^~~~~
va2.c:318:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{nandBB,VB},     {nandBB,VB+VBB}, {nandBB,VB+VBB},
   ^~~~~~
va2.c:318:21: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{nandBB,VB},     {nandBB,VB+VBB}, {nandBB,VB+VBB},
                    ^~~~~~
va2.c:318:38: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{nandBB,VB},     {nandBB,VB+VBB}, {nandBB,VB+VBB},
                                     ^~~~~~
va2.c:319:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {nandBB,VB+VBB}, {nandBB,VB+VBB}, {nandBB,VB+VBB},
   ^~~~~~
va2.c:319:21: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {nandBB,VB+VBB}, {nandBB,VB+VBB}, {nandBB,VB+VBB},
                    ^~~~~~
va2.c:319:38: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {nandBB,VB+VBB}, {nandBB,VB+VBB}, {nandBB,VB+VBB},
                                     ^~~~~~
va2.c:320:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {nandBB,VB+VBB}, {nandBB,VB+VBB}, {nandBB,VB+VBB}, 
   ^~~~~~
va2.c:320:21: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {nandBB,VB+VBB}, {nandBB,VB+VBB}, {nandBB,VB+VBB}, 
                    ^~~~~~
va2.c:320:38: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {nandBB,VB+VBB}, {nandBB,VB+VBB}, {nandBB,VB+VBB}, 
                                     ^~~~~~
va2.c:321:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {nandBB,VB+VBB}, {nandBB,VB+VBB}, {nandBB,VB+VBB}, {0,0}},
   ^~~~~~
va2.c:321:21: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {nandBB,VB+VBB}, {nandBB,VB+VBB}, {nandBB,VB+VBB}, {0,0}},
                    ^~~~~~
va2.c:321:38: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
  {nandBB,VB+VBB}, {nandBB,VB+VBB}, {nandBB,VB+VBB}, {0,0}},
                                     ^~~~~~
va2.c:327:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, B *)' [-Wincompatible-pointer-types]
 {{neBB,VB}, {neBI,VB}, {neBD,VB},
   ^~~~
va2.c:327:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, I *)' [-Wincompatible-pointer-types]
 {{neBB,VB}, {neBI,VB}, {neBD,VB},
              ^~~~
va2.c:327:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, B *, D *)' [-Wincompatible-pointer-types]
 {{neBB,VB}, {neBI,VB}, {neBD,VB},
                         ^~~~
va2.c:328:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, B *)' [-Wincompatible-pointer-types]
  {neIB,VB}, {neII,VB}, {neID,VB},
   ^~~~
va2.c:328:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, I *)' [-Wincompatible-pointer-types]
  {neIB,VB}, {neII,VB}, {neID,VB},
              ^~~~
va2.c:328:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, I *, D *)' [-Wincompatible-pointer-types]
  {neIB,VB}, {neII,VB}, {neID,VB},
                         ^~~~
va2.c:329:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, B *)' [-Wincompatible-pointer-types]
  {neDB,VB}, {neDI,VB}, {neDD,VB}, 
   ^~~~
va2.c:329:15: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, I *)' [-Wincompatible-pointer-types]
  {neDB,VB}, {neDI,VB}, {neDD,VB}, 
              ^~~~
va2.c:329:26: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, D *, D *)' [-Wincompatible-pointer-types]
  {neDB,VB}, {neDI,VB}, {neDD,VB}, 
                         ^~~~
va2.c:330:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, Z *, Z *)' [-Wincompatible-pointer-types]
  {neZZ,VB+VZZ}, {neXX,VB+VXEQ}, {neQQ,VB+VQQ}, {0,0}},
   ^~~~
va2.c:330:19: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, X *, X *)' [-Wincompatible-pointer-types]
  {neZZ,VB+VZZ}, {neXX,VB+VXEQ}, {neQQ,VB+VQQ}, {0,0}},
                  ^~~~
va2.c:330:35: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, B *, Q *, Q *)' [-Wincompatible-pointer-types]
  {neZZ,VB+VZZ}, {neXX,VB+VXEQ}, {neQQ,VB+VQQ}, {0,0}},
                                  ^~~~
va2.c:336:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
 {{cirDD,VD+VDD}, {cirDD,VD+VDD}, {cirBD,VD},
   ^~~~~
va2.c:336:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
 {{cirDD,VD+VDD}, {cirDD,VD+VDD}, {cirBD,VD},
                   ^~~~~
va2.c:336:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, B *, D *)' [-Wincompatible-pointer-types]
 {{cirDD,VD+VDD}, {cirDD,VD+VDD}, {cirBD,VD},
                                   ^~~~~
va2.c:337:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {cirDD,VD+VDD}, {cirDD,VD+VDD}, {cirID,VD},
   ^~~~~
va2.c:337:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {cirDD,VD+VDD}, {cirDD,VD+VDD}, {cirID,VD},
                   ^~~~~
va2.c:337:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, I *, D *)' [-Wincompatible-pointer-types]
  {cirDD,VD+VDD}, {cirDD,VD+VDD}, {cirID,VD},
                                   ^~~~~
va2.c:338:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {cirDD,VD+VDD}, {cirDD,VD+VDD}, {cirDD,VD}, 
   ^~~~~
va2.c:338:20: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {cirDD,VD+VDD}, {cirDD,VD+VDD}, {cirDD,VD}, 
                   ^~~~~
va2.c:338:36: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {cirDD,VD+VDD}, {cirDD,VD+VDD}, {cirDD,VD}, 
                                   ^~~~~
va2.c:339:4: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, Z *, Z *, Z *)' [-Wincompatible-pointer-types]
  {cirZZ,VZ+VZZ+VRD}, {cirDD,VD+VDD}, {cirDD,VD+VDD}, {0,0}},
   ^~~~~
va2.c:339:24: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {cirZZ,VZ+VZZ+VRD}, {cirDD,VD+VDD}, {cirDD,VD+VDD}, {0,0}},
                       ^~~~~
va2.c:339:40: warning: incompatible pointer types initializing 'VF' (aka 'void (*)()') with an expression of type 'void (J, B, I, I, D *, D *, D *)' [-Wincompatible-pointer-types]
  {cirZZ,VZ+VZZ+VRD}, {cirDD,VD+VDD}, {cirDD,VD+VDD}, {0,0}},
                                       ^~~~~
va2.c:715:5: warning: expression result unused [-Wunused-value]
 RE(0); R z;
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
440 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o va2s.o va2s.c
va2s.c:26:9: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 while(u=memchr(xv+xc*j,c,xc*(n-j))){
       ~^~~~~~~~~~~~~~~~~~~~~~~~~~~
va2s.c:26:9: note: place parentheses around the assignment to silence this warning
 while(u=memchr(xv+xc*j,c,xc*(n-j))){
        ^
       (                           )
va2s.c:26:9: note: use '==' to turn this assignment into an equality comparison
 while(u=memchr(xv+xc*j,c,xc*(n-j))){
        ^
        ==
va2s.c:40:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(b=1&&AR(a)){xx=a; y=w;}else{xx=w; y=a;}
    ~^~~~~~~~~
va2s.c:40:6: note: place parentheses around the assignment to silence this warning
 if(b=1&&AR(a)){xx=a; y=w;}else{xx=w; y=a;}
     ^
    (         )
va2s.c:40:6: note: use '==' to turn this assignment into an equality comparison
 if(b=1&&AR(a)){xx=a; y=w;}else{xx=w; y=a;}
     ^
     ==
va2s.c:46:88: warning: expression result unused [-Wunused-value]
 GA(ze,zt,1,0,    0    );      ado(jt, 0,1L,1L,AV(ze),b?AV(e):AV(y),b?AV(y):AV(e)); RE(0);
                                                                                       ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
va2s.c:47:88: warning: expression result unused [-Wunused-value]
 GA(zx,zt,n,AR(x),AS(x)); if(n)ado(jt,!b,1L,n, AV(zx),b?AV(x):AV(y),b?AV(y):AV(x)); RE(0);
                                                                                       ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
va2s.c:95:19: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  c=0; DO(yc, if(c=u[i]-v[i])break;);
                 ~^~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
va2s.c:95:19: note: place parentheses around the assignment to silence this warning
  c=0; DO(yc, if(c=u[i]-v[i])break;);
                  ^
                 (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
va2s.c:95:19: note: use '==' to turn this assignment into an equality comparison
  c=0; DO(yc, if(c=u[i]-v[i])break;);
                  ^
                  ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
va2s.c:120:19: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  c=0; DO(yc, if(c=u[i]-v[i])break;);
                 ~^~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
va2s.c:120:19: note: place parentheses around the assignment to silence this warning
  c=0; DO(yc, if(c=u[i]-v[i])break;);
                  ^
                 (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
va2s.c:120:19: note: use '==' to turn this assignment into an equality comparison
  c=0; DO(yc, if(c=u[i]-v[i])break;);
                  ^
                  ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
va2s.c:129:5: warning: expression result unused [-Wunused-value]
 RE(0);
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
7 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vamultsp.o vamultsp.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vb.o vb.c
vb.c:27:29: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(t&B01+LIT+INT||0==jt->ct&&t&FL+CMPX)
                 ~~~~~~~~~~~^~~~~~~~~~~
vb.c:27:29: note: place parentheses around the '&&' expression to silence this warning
 if(t&B01+LIT+INT||0==jt->ct&&t&FL+CMPX)
                   ~~~~~~~~~^~~~~~~~~~~
vb.c:29:56: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   DO(n, u=av; b=0; DO(si,                         if(b=memcmp(u,v,s))break; u+=s; v+=r;); v=v0+=k; zv[i]=!b;);
                                                      ~^~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vb.c:29:56: note: place parentheses around the assignment to silence this warning
   DO(n, u=av; b=0; DO(si,                         if(b=memcmp(u,v,s))break; u+=s; v+=r;); v=v0+=k; zv[i]=!b;);
                                                       ^
                                                      (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vb.c:29:56: note: use '==' to turn this assignment into an equality comparison
   DO(n, u=av; b=0; DO(si,                         if(b=memcmp(u,v,s))break; u+=s; v+=r;); v=v0+=k; zv[i]=!b;);
                                                       ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
vb.c:35:56: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   DO(n, u=av; b=0; DO(si, MC(au,u,s); MC(wu,v,s); if(b=!equ(ya,yw)  )break; u+=s; v+=r;); v=v0+=k; zv[i]=!b;);
                                                      ~^~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vb.c:35:56: note: place parentheses around the assignment to silence this warning
   DO(n, u=av; b=0; DO(si, MC(au,u,s); MC(wu,v,s); if(b=!equ(ya,yw)  )break; u+=s; v+=r;); v=v0+=k; zv[i]=!b;);
                                                       ^
                                                      (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vb.c:35:56: note: use '==' to turn this assignment into an equality comparison
   DO(n, u=av; b=0; DO(si, MC(au,u,s); MC(wu,v,s); if(b=!equ(ya,yw)  )break; u+=s; v+=r;); v=v0+=k; zv[i]=!b;);
                                                       ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
vb.c:48:21: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(t&INT||0==jt->ct&&t&FL+CMPX)DO(n, zv[i]=!memcmp(av,wv,s); wv+=k;)
         ~~~~~~~~~~~^~~~~~~~~~~
vb.c:48:21: note: place parentheses around the '&&' expression to silence this warning
 if(t&INT||0==jt->ct&&t&FL+CMPX)DO(n, zv[i]=!memcmp(av,wv,s); wv+=k;)
           ~~~~~~~~~^~~~~~~~~~~
vb.c:80:29: warning: '&&' within '||' [-Wlogical-op-parentheses]
 R t&B01+LIT+C2T||t&INT&&0<d&&d<=4*n ? d : -4;
                ~~~~~~~~~~~~^~~~~~~~
vb.c:80:29: note: place parentheses around the '&&' expression to silence this warning
 R t&B01+LIT+C2T||t&INT&&0<d&&d<=4*n ? d : -4;
                            ^
                  (                 )
5 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vbang.o vbang.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vbit.o vbit.c
vbit.c:55:7: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(rc=c%BW){
    ~~^~~~~
vbit.c:55:7: note: place parentheses around the assignment to silence this warning
 if(rc=c%BW){
      ^
    (      )
vbit.c:55:7: note: use '==' to turn this assignment into an equality comparison
 if(rc=c%BW){
      ^
      ==
vbit.c:260:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(t=an%BB){UC k,*wv,y;
    ~^~~~~~
vbit.c:260:6: note: place parentheses around the assignment to silence this warning
 if(t=an%BB){UC k,*wv,y;
     ^
    (      )
vbit.c:260:6: note: use '==' to turn this assignment into an equality comparison
 if(t=an%BB){UC k,*wv,y;
     ^
     ==
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vcant.o vcant.c
vcant.c:37:7: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(wf=wr-r){
    ~~^~~~~
vcant.c:37:7: note: place parentheses around the assignment to silence this warning
 if(wf=wr-r){
      ^
    (      )
vcant.c:37:7: note: use '==' to turn this assignment into an equality comparison
 if(wf=wr-r){
      ^
      ==
1 warning generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vchar.o vchar.c
vchar.c:23:26: warning: incompatible pointer types assigning to 'VF' (aka 'void (*)()') from 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
  case CMAX:  zt=LIT; ado=maxC; break;
                         ^~~~~
vchar.c:24:26: warning: incompatible pointer types assigning to 'VF' (aka 'void (*)()') from 'void (J, B, I, I, UC *, UC *, UC *)' [-Wincompatible-pointer-types]
  case CMIN:  zt=LIT; ado=minC; break;
                         ^~~~~
vchar.c:29:26: warning: incompatible pointer types assigning to 'VF' (aka 'void (*)()') from 'void (J, B, I, I, B *, UC *, UC *)' [-Wincompatible-pointer-types]
  case CLT:   zt=B01; ado=ltC;  break;
                         ^~~~
vchar.c:30:26: warning: incompatible pointer types assigning to 'VF' (aka 'void (*)()') from 'void (J, B, I, I, B *, UC *, UC *)' [-Wincompatible-pointer-types]
  case CLE:   zt=B01; ado=leC;  break;
                         ^~~~
vchar.c:31:26: warning: incompatible pointer types assigning to 'VF' (aka 'void (*)()') from 'void (J, B, I, I, B *, UC *, UC *)' [-Wincompatible-pointer-types]
  case CGE:   zt=B01; ado=geC;  break;
                         ^~~~
vchar.c:32:26: warning: incompatible pointer types assigning to 'VF' (aka 'void (*)()') from 'void (J, B, I, I, B *, UC *, UC *)' [-Wincompatible-pointer-types]
  case CGT:   zt=B01; ado=gtC;  break;
                         ^~~~
6 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vcat.o vcat.c
vcat.c:126:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(m=MIN(ar,wr)){
    ~^~~~~~~~~~~
vcat.c:126:6: note: place parentheses around the assignment to silence this warning
 if(m=MIN(ar,wr)){
     ^
    (           )
vcat.c:126:6: note: use '==' to turn this assignment into an equality comparison
 if(m=MIN(ar,wr)){
     ^
     ==
vcat.c:175:35: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(2<r||!AN(a)||!AN(w)||2<acr+wcr&&p!=q||ARELATIVE(a)||ARELATIVE(w)){
                       ~~~~~~~~~~~^~~~~~
vcat.c:175:35: note: place parentheses around the '&&' expression to silence this warning
 if(2<r||!AN(a)||!AN(w)||2<acr+wcr&&p!=q||ARELATIVE(a)||ARELATIVE(w)){
                                  ^
                         (              )
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vcatsp.o vcatsp.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vcomp.o vcomp.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vcompsc.o vcompsc.c
vcompsc.c:223:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0eqBB,B,B,NE   )  INDF( i0eqBI,B,I,ANE  )  INDF( i0eqBD,B,D,TNEXD)  /* =  */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:223:1: note: place parentheses around the assignment to silence this warning
INDB( i0eqBB,B,B,NE   )  INDF( i0eqBI,B,I,ANE  )  INDF( i0eqBD,B,D,TNEXD)  /* =  */
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:223:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0eqBB,B,B,NE   )  INDF( i0eqBI,B,I,ANE  )  INDF( i0eqBD,B,D,TNEXD)  /* =  */
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:223:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0eqBB,B,B,NE   )  INDF( i0eqBI,B,I,ANE  )  INDF( i0eqBD,B,D,TNEXD)  /* =  */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:223:1: note: place parentheses around the assignment to silence this warning
INDB( i0eqBB,B,B,NE   )  INDF( i0eqBI,B,I,ANE  )  INDF( i0eqBD,B,D,TNEXD)  /* =  */
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:223:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0eqBB,B,B,NE   )  INDF( i0eqBI,B,I,ANE  )  INDF( i0eqBD,B,D,TNEXD)  /* =  */
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:223:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0eqBB,B,B,NE   )  INDF( i0eqBI,B,I,ANE  )  INDF( i0eqBD,B,D,TNEXD)  /* =  */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:223:1: note: place parentheses around the assignment to silence this warning
INDB( i0eqBB,B,B,NE   )  INDF( i0eqBI,B,I,ANE  )  INDF( i0eqBD,B,D,TNEXD)  /* =  */
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:223:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0eqBB,B,B,NE   )  INDF( i0eqBI,B,I,ANE  )  INDF( i0eqBD,B,D,TNEXD)  /* =  */
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:227:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1eqBB,B,B,EQ   )  INDF( i1eqBI,B,I,AEQ  )  INDF( i1eqBD,B,D,TEQXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:227:1: note: place parentheses around the assignment to silence this warning
INDB( i1eqBB,B,B,EQ   )  INDF( i1eqBI,B,I,AEQ  )  INDF( i1eqBD,B,D,TEQXD)
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:227:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1eqBB,B,B,EQ   )  INDF( i1eqBI,B,I,AEQ  )  INDF( i1eqBD,B,D,TEQXD)
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:227:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1eqBB,B,B,EQ   )  INDF( i1eqBI,B,I,AEQ  )  INDF( i1eqBD,B,D,TEQXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:227:1: note: place parentheses around the assignment to silence this warning
INDB( i1eqBB,B,B,EQ   )  INDF( i1eqBI,B,I,AEQ  )  INDF( i1eqBD,B,D,TEQXD)
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:227:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1eqBB,B,B,EQ   )  INDF( i1eqBI,B,I,AEQ  )  INDF( i1eqBD,B,D,TEQXD)
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:227:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1eqBB,B,B,EQ   )  INDF( i1eqBI,B,I,AEQ  )  INDF( i1eqBD,B,D,TEQXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:227:1: note: place parentheses around the assignment to silence this warning
INDB( i1eqBB,B,B,EQ   )  INDF( i1eqBI,B,I,AEQ  )  INDF( i1eqBD,B,D,TEQXD)
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:227:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1eqBB,B,B,EQ   )  INDF( i1eqBI,B,I,AEQ  )  INDF( i1eqBD,B,D,TEQXD)
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:231:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0eqBB,B,B,NE   )  JNDF( j0eqBI,B,I,ANE  )  JNDF( j0eqBD,B,D,TNEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:231:1: note: place parentheses around the assignment to silence this warning
JNDB( j0eqBB,B,B,NE   )  JNDF( j0eqBI,B,I,ANE  )  JNDF( j0eqBD,B,D,TNEXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:231:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0eqBB,B,B,NE   )  JNDF( j0eqBI,B,I,ANE  )  JNDF( j0eqBD,B,D,TNEXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:231:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0eqBB,B,B,NE   )  JNDF( j0eqBI,B,I,ANE  )  JNDF( j0eqBD,B,D,TNEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:231:1: note: place parentheses around the assignment to silence this warning
JNDB( j0eqBB,B,B,NE   )  JNDF( j0eqBI,B,I,ANE  )  JNDF( j0eqBD,B,D,TNEXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:231:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0eqBB,B,B,NE   )  JNDF( j0eqBI,B,I,ANE  )  JNDF( j0eqBD,B,D,TNEXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:231:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0eqBB,B,B,NE   )  JNDF( j0eqBI,B,I,ANE  )  JNDF( j0eqBD,B,D,TNEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:231:1: note: place parentheses around the assignment to silence this warning
JNDB( j0eqBB,B,B,NE   )  JNDF( j0eqBI,B,I,ANE  )  JNDF( j0eqBD,B,D,TNEXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:231:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0eqBB,B,B,NE   )  JNDF( j0eqBI,B,I,ANE  )  JNDF( j0eqBD,B,D,TNEXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:235:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1eqBB,B,B,EQ   )  JNDF( j1eqBI,B,I,AEQ  )  JNDF( j1eqBD,B,D,TEQXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:235:1: note: place parentheses around the assignment to silence this warning
JNDB( j1eqBB,B,B,EQ   )  JNDF( j1eqBI,B,I,AEQ  )  JNDF( j1eqBD,B,D,TEQXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:235:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1eqBB,B,B,EQ   )  JNDF( j1eqBI,B,I,AEQ  )  JNDF( j1eqBD,B,D,TEQXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:235:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1eqBB,B,B,EQ   )  JNDF( j1eqBI,B,I,AEQ  )  JNDF( j1eqBD,B,D,TEQXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:235:1: note: place parentheses around the assignment to silence this warning
JNDB( j1eqBB,B,B,EQ   )  JNDF( j1eqBI,B,I,AEQ  )  JNDF( j1eqBD,B,D,TEQXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:235:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1eqBB,B,B,EQ   )  JNDF( j1eqBI,B,I,AEQ  )  JNDF( j1eqBD,B,D,TEQXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:235:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1eqBB,B,B,EQ   )  JNDF( j1eqBI,B,I,AEQ  )  JNDF( j1eqBD,B,D,TEQXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:235:1: note: place parentheses around the assignment to silence this warning
JNDB( j1eqBB,B,B,EQ   )  JNDF( j1eqBI,B,I,AEQ  )  JNDF( j1eqBD,B,D,TEQXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:235:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1eqBB,B,B,EQ   )  JNDF( j1eqBI,B,I,AEQ  )  JNDF( j1eqBD,B,D,TEQXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:251:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbeqBB,B,B,EQ   )  IFBF(ifbeqBI,B,I,AEQ  )  IFBF(ifbeqBD,B,D,TEQXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:251:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbeqBB,B,B,EQ   )  IFBF(ifbeqBI,B,I,AEQ  )  IFBF(ifbeqBD,B,D,TEQXD)
^
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:251:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbeqBB,B,B,EQ   )  IFBF(ifbeqBI,B,I,AEQ  )  IFBF(ifbeqBD,B,D,TEQXD)
^
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:251:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbeqBB,B,B,EQ   )  IFBF(ifbeqBI,B,I,AEQ  )  IFBF(ifbeqBD,B,D,TEQXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:251:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbeqBB,B,B,EQ   )  IFBF(ifbeqBI,B,I,AEQ  )  IFBF(ifbeqBD,B,D,TEQXD)
^
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:251:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbeqBB,B,B,EQ   )  IFBF(ifbeqBI,B,I,AEQ  )  IFBF(ifbeqBD,B,D,TEQXD)
^
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:251:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbeqBB,B,B,EQ   )  IFBF(ifbeqBI,B,I,AEQ  )  IFBF(ifbeqBD,B,D,TEQXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:251:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbeqBB,B,B,EQ   )  IFBF(ifbeqBI,B,I,AEQ  )  IFBF(ifbeqBD,B,D,TEQXD)
^
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:251:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbeqBB,B,B,EQ   )  IFBF(ifbeqBI,B,I,AEQ  )  IFBF(ifbeqBD,B,D,TEQXD)
^
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:255:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0neBB,B,B,EQ   )  INDF( i0neBI,B,I,AEQ  )  INDF( i0neBD,B,D,TEQXD)  /* ~: */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:255:1: note: place parentheses around the assignment to silence this warning
INDB( i0neBB,B,B,EQ   )  INDF( i0neBI,B,I,AEQ  )  INDF( i0neBD,B,D,TEQXD)  /* ~: */
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:255:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0neBB,B,B,EQ   )  INDF( i0neBI,B,I,AEQ  )  INDF( i0neBD,B,D,TEQXD)  /* ~: */
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:255:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0neBB,B,B,EQ   )  INDF( i0neBI,B,I,AEQ  )  INDF( i0neBD,B,D,TEQXD)  /* ~: */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:255:1: note: place parentheses around the assignment to silence this warning
INDB( i0neBB,B,B,EQ   )  INDF( i0neBI,B,I,AEQ  )  INDF( i0neBD,B,D,TEQXD)  /* ~: */
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:255:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0neBB,B,B,EQ   )  INDF( i0neBI,B,I,AEQ  )  INDF( i0neBD,B,D,TEQXD)  /* ~: */
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:255:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0neBB,B,B,EQ   )  INDF( i0neBI,B,I,AEQ  )  INDF( i0neBD,B,D,TEQXD)  /* ~: */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:255:1: note: place parentheses around the assignment to silence this warning
INDB( i0neBB,B,B,EQ   )  INDF( i0neBI,B,I,AEQ  )  INDF( i0neBD,B,D,TEQXD)  /* ~: */
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:255:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0neBB,B,B,EQ   )  INDF( i0neBI,B,I,AEQ  )  INDF( i0neBD,B,D,TEQXD)  /* ~: */
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:259:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1neBB,B,B,NE   )  INDF( i1neBI,B,I,ANE  )  INDF( i1neBD,B,D,TNEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:259:1: note: place parentheses around the assignment to silence this warning
INDB( i1neBB,B,B,NE   )  INDF( i1neBI,B,I,ANE  )  INDF( i1neBD,B,D,TNEXD)
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:259:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1neBB,B,B,NE   )  INDF( i1neBI,B,I,ANE  )  INDF( i1neBD,B,D,TNEXD)
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:259:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1neBB,B,B,NE   )  INDF( i1neBI,B,I,ANE  )  INDF( i1neBD,B,D,TNEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:259:1: note: place parentheses around the assignment to silence this warning
INDB( i1neBB,B,B,NE   )  INDF( i1neBI,B,I,ANE  )  INDF( i1neBD,B,D,TNEXD)
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:259:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1neBB,B,B,NE   )  INDF( i1neBI,B,I,ANE  )  INDF( i1neBD,B,D,TNEXD)
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:259:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1neBB,B,B,NE   )  INDF( i1neBI,B,I,ANE  )  INDF( i1neBD,B,D,TNEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:259:1: note: place parentheses around the assignment to silence this warning
INDB( i1neBB,B,B,NE   )  INDF( i1neBI,B,I,ANE  )  INDF( i1neBD,B,D,TNEXD)
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:259:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1neBB,B,B,NE   )  INDF( i1neBI,B,I,ANE  )  INDF( i1neBD,B,D,TNEXD)
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:263:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0neBB,B,B,EQ   )  JNDF( j0neBI,B,I,AEQ  )  JNDF( j0neBD,B,D,TEQXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:263:1: note: place parentheses around the assignment to silence this warning
JNDB( j0neBB,B,B,EQ   )  JNDF( j0neBI,B,I,AEQ  )  JNDF( j0neBD,B,D,TEQXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:263:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0neBB,B,B,EQ   )  JNDF( j0neBI,B,I,AEQ  )  JNDF( j0neBD,B,D,TEQXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:263:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0neBB,B,B,EQ   )  JNDF( j0neBI,B,I,AEQ  )  JNDF( j0neBD,B,D,TEQXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:263:1: note: place parentheses around the assignment to silence this warning
JNDB( j0neBB,B,B,EQ   )  JNDF( j0neBI,B,I,AEQ  )  JNDF( j0neBD,B,D,TEQXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:263:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0neBB,B,B,EQ   )  JNDF( j0neBI,B,I,AEQ  )  JNDF( j0neBD,B,D,TEQXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:263:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0neBB,B,B,EQ   )  JNDF( j0neBI,B,I,AEQ  )  JNDF( j0neBD,B,D,TEQXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:263:1: note: place parentheses around the assignment to silence this warning
JNDB( j0neBB,B,B,EQ   )  JNDF( j0neBI,B,I,AEQ  )  JNDF( j0neBD,B,D,TEQXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:263:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0neBB,B,B,EQ   )  JNDF( j0neBI,B,I,AEQ  )  JNDF( j0neBD,B,D,TEQXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:267:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1neBB,B,B,NE   )  JNDF( j1neBI,B,I,ANE  )  JNDF( j1neBD,B,D,TNEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:267:1: note: place parentheses around the assignment to silence this warning
JNDB( j1neBB,B,B,NE   )  JNDF( j1neBI,B,I,ANE  )  JNDF( j1neBD,B,D,TNEXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:267:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1neBB,B,B,NE   )  JNDF( j1neBI,B,I,ANE  )  JNDF( j1neBD,B,D,TNEXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:267:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1neBB,B,B,NE   )  JNDF( j1neBI,B,I,ANE  )  JNDF( j1neBD,B,D,TNEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:267:1: note: place parentheses around the assignment to silence this warning
JNDB( j1neBB,B,B,NE   )  JNDF( j1neBI,B,I,ANE  )  JNDF( j1neBD,B,D,TNEXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:267:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1neBB,B,B,NE   )  JNDF( j1neBI,B,I,ANE  )  JNDF( j1neBD,B,D,TNEXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:267:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1neBB,B,B,NE   )  JNDF( j1neBI,B,I,ANE  )  JNDF( j1neBD,B,D,TNEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:267:1: note: place parentheses around the assignment to silence this warning
JNDB( j1neBB,B,B,NE   )  JNDF( j1neBI,B,I,ANE  )  JNDF( j1neBD,B,D,TNEXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:267:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1neBB,B,B,NE   )  JNDF( j1neBI,B,I,ANE  )  JNDF( j1neBD,B,D,TNEXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:283:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbneBB,B,B,NE   )  IFBF(ifbneBI,B,I,ANE  )  IFBF(ifbneBD,B,D,TNEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:283:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbneBB,B,B,NE   )  IFBF(ifbneBI,B,I,ANE  )  IFBF(ifbneBD,B,D,TNEXD)
^
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:283:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbneBB,B,B,NE   )  IFBF(ifbneBI,B,I,ANE  )  IFBF(ifbneBD,B,D,TNEXD)
^
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:283:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbneBB,B,B,NE   )  IFBF(ifbneBI,B,I,ANE  )  IFBF(ifbneBD,B,D,TNEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:283:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbneBB,B,B,NE   )  IFBF(ifbneBI,B,I,ANE  )  IFBF(ifbneBD,B,D,TNEXD)
^
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:283:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbneBB,B,B,NE   )  IFBF(ifbneBI,B,I,ANE  )  IFBF(ifbneBD,B,D,TNEXD)
^
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:283:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbneBB,B,B,NE   )  IFBF(ifbneBI,B,I,ANE  )  IFBF(ifbneBD,B,D,TNEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:283:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbneBB,B,B,NE   )  IFBF(ifbneBI,B,I,ANE  )  IFBF(ifbneBD,B,D,TNEXD)
^
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:283:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbneBB,B,B,NE   )  IFBF(ifbneBI,B,I,ANE  )  IFBF(ifbneBD,B,D,TNEXD)
^
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:287:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0ltBB,B,B,GE   )  INDF( i0ltBI,B,I,AGE  )  INDF( i0ltBD,B,D,TGEXD)  /* <  */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:287:1: note: place parentheses around the assignment to silence this warning
INDB( i0ltBB,B,B,GE   )  INDF( i0ltBI,B,I,AGE  )  INDF( i0ltBD,B,D,TGEXD)  /* <  */
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:287:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0ltBB,B,B,GE   )  INDF( i0ltBI,B,I,AGE  )  INDF( i0ltBD,B,D,TGEXD)  /* <  */
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:287:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0ltBB,B,B,GE   )  INDF( i0ltBI,B,I,AGE  )  INDF( i0ltBD,B,D,TGEXD)  /* <  */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:287:1: note: place parentheses around the assignment to silence this warning
INDB( i0ltBB,B,B,GE   )  INDF( i0ltBI,B,I,AGE  )  INDF( i0ltBD,B,D,TGEXD)  /* <  */
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:287:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0ltBB,B,B,GE   )  INDF( i0ltBI,B,I,AGE  )  INDF( i0ltBD,B,D,TGEXD)  /* <  */
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:287:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0ltBB,B,B,GE   )  INDF( i0ltBI,B,I,AGE  )  INDF( i0ltBD,B,D,TGEXD)  /* <  */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:287:1: note: place parentheses around the assignment to silence this warning
INDB( i0ltBB,B,B,GE   )  INDF( i0ltBI,B,I,AGE  )  INDF( i0ltBD,B,D,TGEXD)  /* <  */
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:287:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0ltBB,B,B,GE   )  INDF( i0ltBI,B,I,AGE  )  INDF( i0ltBD,B,D,TGEXD)  /* <  */
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:291:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1ltBB,B,B,LT   )  INDF( i1ltBI,B,I,ALT  )  INDF( i1ltBD,B,D,TLTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:291:1: note: place parentheses around the assignment to silence this warning
INDB( i1ltBB,B,B,LT   )  INDF( i1ltBI,B,I,ALT  )  INDF( i1ltBD,B,D,TLTXD)
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:291:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1ltBB,B,B,LT   )  INDF( i1ltBI,B,I,ALT  )  INDF( i1ltBD,B,D,TLTXD)
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:291:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1ltBB,B,B,LT   )  INDF( i1ltBI,B,I,ALT  )  INDF( i1ltBD,B,D,TLTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:291:1: note: place parentheses around the assignment to silence this warning
INDB( i1ltBB,B,B,LT   )  INDF( i1ltBI,B,I,ALT  )  INDF( i1ltBD,B,D,TLTXD)
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:291:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1ltBB,B,B,LT   )  INDF( i1ltBI,B,I,ALT  )  INDF( i1ltBD,B,D,TLTXD)
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:291:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1ltBB,B,B,LT   )  INDF( i1ltBI,B,I,ALT  )  INDF( i1ltBD,B,D,TLTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:291:1: note: place parentheses around the assignment to silence this warning
INDB( i1ltBB,B,B,LT   )  INDF( i1ltBI,B,I,ALT  )  INDF( i1ltBD,B,D,TLTXD)
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:291:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1ltBB,B,B,LT   )  INDF( i1ltBI,B,I,ALT  )  INDF( i1ltBD,B,D,TLTXD)
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:295:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0ltBB,B,B,GE   )  JNDF( j0ltBI,B,I,AGE  )  JNDF( j0ltBD,B,D,TGEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:295:1: note: place parentheses around the assignment to silence this warning
JNDB( j0ltBB,B,B,GE   )  JNDF( j0ltBI,B,I,AGE  )  JNDF( j0ltBD,B,D,TGEXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:295:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0ltBB,B,B,GE   )  JNDF( j0ltBI,B,I,AGE  )  JNDF( j0ltBD,B,D,TGEXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:295:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0ltBB,B,B,GE   )  JNDF( j0ltBI,B,I,AGE  )  JNDF( j0ltBD,B,D,TGEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:295:1: note: place parentheses around the assignment to silence this warning
JNDB( j0ltBB,B,B,GE   )  JNDF( j0ltBI,B,I,AGE  )  JNDF( j0ltBD,B,D,TGEXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:295:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0ltBB,B,B,GE   )  JNDF( j0ltBI,B,I,AGE  )  JNDF( j0ltBD,B,D,TGEXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:295:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0ltBB,B,B,GE   )  JNDF( j0ltBI,B,I,AGE  )  JNDF( j0ltBD,B,D,TGEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:295:1: note: place parentheses around the assignment to silence this warning
JNDB( j0ltBB,B,B,GE   )  JNDF( j0ltBI,B,I,AGE  )  JNDF( j0ltBD,B,D,TGEXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:295:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0ltBB,B,B,GE   )  JNDF( j0ltBI,B,I,AGE  )  JNDF( j0ltBD,B,D,TGEXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:299:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1ltBB,B,B,LT   )  JNDF( j1ltBI,B,I,ALT  )  JNDF( j1ltBD,B,D,TLTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:299:1: note: place parentheses around the assignment to silence this warning
JNDB( j1ltBB,B,B,LT   )  JNDF( j1ltBI,B,I,ALT  )  JNDF( j1ltBD,B,D,TLTXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:299:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1ltBB,B,B,LT   )  JNDF( j1ltBI,B,I,ALT  )  JNDF( j1ltBD,B,D,TLTXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:299:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1ltBB,B,B,LT   )  JNDF( j1ltBI,B,I,ALT  )  JNDF( j1ltBD,B,D,TLTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:299:1: note: place parentheses around the assignment to silence this warning
JNDB( j1ltBB,B,B,LT   )  JNDF( j1ltBI,B,I,ALT  )  JNDF( j1ltBD,B,D,TLTXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:299:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1ltBB,B,B,LT   )  JNDF( j1ltBI,B,I,ALT  )  JNDF( j1ltBD,B,D,TLTXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:299:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1ltBB,B,B,LT   )  JNDF( j1ltBI,B,I,ALT  )  JNDF( j1ltBD,B,D,TLTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:299:1: note: place parentheses around the assignment to silence this warning
JNDB( j1ltBB,B,B,LT   )  JNDF( j1ltBI,B,I,ALT  )  JNDF( j1ltBD,B,D,TLTXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:299:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1ltBB,B,B,LT   )  JNDF( j1ltBI,B,I,ALT  )  JNDF( j1ltBD,B,D,TLTXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:315:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbltBB,B,B,LT   )  IFBF(ifbltBI,B,I,ALT  )  IFBF(ifbltBD,B,D,TLTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:315:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbltBB,B,B,LT   )  IFBF(ifbltBI,B,I,ALT  )  IFBF(ifbltBD,B,D,TLTXD)
^
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:315:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbltBB,B,B,LT   )  IFBF(ifbltBI,B,I,ALT  )  IFBF(ifbltBD,B,D,TLTXD)
^
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:315:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbltBB,B,B,LT   )  IFBF(ifbltBI,B,I,ALT  )  IFBF(ifbltBD,B,D,TLTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:315:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbltBB,B,B,LT   )  IFBF(ifbltBI,B,I,ALT  )  IFBF(ifbltBD,B,D,TLTXD)
^
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:315:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbltBB,B,B,LT   )  IFBF(ifbltBI,B,I,ALT  )  IFBF(ifbltBD,B,D,TLTXD)
^
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:315:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbltBB,B,B,LT   )  IFBF(ifbltBI,B,I,ALT  )  IFBF(ifbltBD,B,D,TLTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:315:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbltBB,B,B,LT   )  IFBF(ifbltBI,B,I,ALT  )  IFBF(ifbltBD,B,D,TLTXD)
^
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:315:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbltBB,B,B,LT   )  IFBF(ifbltBI,B,I,ALT  )  IFBF(ifbltBD,B,D,TLTXD)
^
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:319:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0leBB,B,B,GT   )  INDF( i0leBI,B,I,AGT  )  INDF( i0leBD,B,D,TGTXD)  /* <: */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:319:1: note: place parentheses around the assignment to silence this warning
INDB( i0leBB,B,B,GT   )  INDF( i0leBI,B,I,AGT  )  INDF( i0leBD,B,D,TGTXD)  /* <: */
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:319:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0leBB,B,B,GT   )  INDF( i0leBI,B,I,AGT  )  INDF( i0leBD,B,D,TGTXD)  /* <: */
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:319:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0leBB,B,B,GT   )  INDF( i0leBI,B,I,AGT  )  INDF( i0leBD,B,D,TGTXD)  /* <: */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:319:1: note: place parentheses around the assignment to silence this warning
INDB( i0leBB,B,B,GT   )  INDF( i0leBI,B,I,AGT  )  INDF( i0leBD,B,D,TGTXD)  /* <: */
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:319:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0leBB,B,B,GT   )  INDF( i0leBI,B,I,AGT  )  INDF( i0leBD,B,D,TGTXD)  /* <: */
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:319:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0leBB,B,B,GT   )  INDF( i0leBI,B,I,AGT  )  INDF( i0leBD,B,D,TGTXD)  /* <: */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:319:1: note: place parentheses around the assignment to silence this warning
INDB( i0leBB,B,B,GT   )  INDF( i0leBI,B,I,AGT  )  INDF( i0leBD,B,D,TGTXD)  /* <: */
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:319:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0leBB,B,B,GT   )  INDF( i0leBI,B,I,AGT  )  INDF( i0leBD,B,D,TGTXD)  /* <: */
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:323:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1leBB,B,B,LE   )  INDF( i1leBI,B,I,ALE  )  INDF( i1leBD,B,D,TLEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:323:1: note: place parentheses around the assignment to silence this warning
INDB( i1leBB,B,B,LE   )  INDF( i1leBI,B,I,ALE  )  INDF( i1leBD,B,D,TLEXD)
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:323:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1leBB,B,B,LE   )  INDF( i1leBI,B,I,ALE  )  INDF( i1leBD,B,D,TLEXD)
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:323:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1leBB,B,B,LE   )  INDF( i1leBI,B,I,ALE  )  INDF( i1leBD,B,D,TLEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:323:1: note: place parentheses around the assignment to silence this warning
INDB( i1leBB,B,B,LE   )  INDF( i1leBI,B,I,ALE  )  INDF( i1leBD,B,D,TLEXD)
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:323:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1leBB,B,B,LE   )  INDF( i1leBI,B,I,ALE  )  INDF( i1leBD,B,D,TLEXD)
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:323:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1leBB,B,B,LE   )  INDF( i1leBI,B,I,ALE  )  INDF( i1leBD,B,D,TLEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:323:1: note: place parentheses around the assignment to silence this warning
INDB( i1leBB,B,B,LE   )  INDF( i1leBI,B,I,ALE  )  INDF( i1leBD,B,D,TLEXD)
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:323:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1leBB,B,B,LE   )  INDF( i1leBI,B,I,ALE  )  INDF( i1leBD,B,D,TLEXD)
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:327:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0leBB,B,B,GT   )  JNDF( j0leBI,B,I,AGT  )  JNDF( j0leBD,B,D,TGTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:327:1: note: place parentheses around the assignment to silence this warning
JNDB( j0leBB,B,B,GT   )  JNDF( j0leBI,B,I,AGT  )  JNDF( j0leBD,B,D,TGTXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:327:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0leBB,B,B,GT   )  JNDF( j0leBI,B,I,AGT  )  JNDF( j0leBD,B,D,TGTXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:327:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0leBB,B,B,GT   )  JNDF( j0leBI,B,I,AGT  )  JNDF( j0leBD,B,D,TGTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:327:1: note: place parentheses around the assignment to silence this warning
JNDB( j0leBB,B,B,GT   )  JNDF( j0leBI,B,I,AGT  )  JNDF( j0leBD,B,D,TGTXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:327:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0leBB,B,B,GT   )  JNDF( j0leBI,B,I,AGT  )  JNDF( j0leBD,B,D,TGTXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:327:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0leBB,B,B,GT   )  JNDF( j0leBI,B,I,AGT  )  JNDF( j0leBD,B,D,TGTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:327:1: note: place parentheses around the assignment to silence this warning
JNDB( j0leBB,B,B,GT   )  JNDF( j0leBI,B,I,AGT  )  JNDF( j0leBD,B,D,TGTXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:327:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0leBB,B,B,GT   )  JNDF( j0leBI,B,I,AGT  )  JNDF( j0leBD,B,D,TGTXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:331:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1leBB,B,B,LE   )  JNDF( j1leBI,B,I,ALE  )  JNDF( j1leBD,B,D,TLEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:331:1: note: place parentheses around the assignment to silence this warning
JNDB( j1leBB,B,B,LE   )  JNDF( j1leBI,B,I,ALE  )  JNDF( j1leBD,B,D,TLEXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:331:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1leBB,B,B,LE   )  JNDF( j1leBI,B,I,ALE  )  JNDF( j1leBD,B,D,TLEXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:331:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1leBB,B,B,LE   )  JNDF( j1leBI,B,I,ALE  )  JNDF( j1leBD,B,D,TLEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:331:1: note: place parentheses around the assignment to silence this warning
JNDB( j1leBB,B,B,LE   )  JNDF( j1leBI,B,I,ALE  )  JNDF( j1leBD,B,D,TLEXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:331:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1leBB,B,B,LE   )  JNDF( j1leBI,B,I,ALE  )  JNDF( j1leBD,B,D,TLEXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:331:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1leBB,B,B,LE   )  JNDF( j1leBI,B,I,ALE  )  JNDF( j1leBD,B,D,TLEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:331:1: note: place parentheses around the assignment to silence this warning
JNDB( j1leBB,B,B,LE   )  JNDF( j1leBI,B,I,ALE  )  JNDF( j1leBD,B,D,TLEXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:331:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1leBB,B,B,LE   )  JNDF( j1leBI,B,I,ALE  )  JNDF( j1leBD,B,D,TLEXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:347:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbleBB,B,B,LE   )  IFBF(ifbleBI,B,I,ALE  )  IFBF(ifbleBD,B,D,TLEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:347:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbleBB,B,B,LE   )  IFBF(ifbleBI,B,I,ALE  )  IFBF(ifbleBD,B,D,TLEXD)
^
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:347:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbleBB,B,B,LE   )  IFBF(ifbleBI,B,I,ALE  )  IFBF(ifbleBD,B,D,TLEXD)
^
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:347:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbleBB,B,B,LE   )  IFBF(ifbleBI,B,I,ALE  )  IFBF(ifbleBD,B,D,TLEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:347:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbleBB,B,B,LE   )  IFBF(ifbleBI,B,I,ALE  )  IFBF(ifbleBD,B,D,TLEXD)
^
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:347:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbleBB,B,B,LE   )  IFBF(ifbleBI,B,I,ALE  )  IFBF(ifbleBD,B,D,TLEXD)
^
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:347:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbleBB,B,B,LE   )  IFBF(ifbleBI,B,I,ALE  )  IFBF(ifbleBD,B,D,TLEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:347:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbleBB,B,B,LE   )  IFBF(ifbleBI,B,I,ALE  )  IFBF(ifbleBD,B,D,TLEXD)
^
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:347:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbleBB,B,B,LE   )  IFBF(ifbleBI,B,I,ALE  )  IFBF(ifbleBD,B,D,TLEXD)
^
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:351:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0geBB,B,B,LT   )  INDF( i0geBI,B,I,ALT  )  INDF( i0geBD,B,D,TLTXD)  /* >: */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:351:1: note: place parentheses around the assignment to silence this warning
INDB( i0geBB,B,B,LT   )  INDF( i0geBI,B,I,ALT  )  INDF( i0geBD,B,D,TLTXD)  /* >: */
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:351:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0geBB,B,B,LT   )  INDF( i0geBI,B,I,ALT  )  INDF( i0geBD,B,D,TLTXD)  /* >: */
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:351:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0geBB,B,B,LT   )  INDF( i0geBI,B,I,ALT  )  INDF( i0geBD,B,D,TLTXD)  /* >: */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:351:1: note: place parentheses around the assignment to silence this warning
INDB( i0geBB,B,B,LT   )  INDF( i0geBI,B,I,ALT  )  INDF( i0geBD,B,D,TLTXD)  /* >: */
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:351:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0geBB,B,B,LT   )  INDF( i0geBI,B,I,ALT  )  INDF( i0geBD,B,D,TLTXD)  /* >: */
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:351:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0geBB,B,B,LT   )  INDF( i0geBI,B,I,ALT  )  INDF( i0geBD,B,D,TLTXD)  /* >: */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:351:1: note: place parentheses around the assignment to silence this warning
INDB( i0geBB,B,B,LT   )  INDF( i0geBI,B,I,ALT  )  INDF( i0geBD,B,D,TLTXD)  /* >: */
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:351:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0geBB,B,B,LT   )  INDF( i0geBI,B,I,ALT  )  INDF( i0geBD,B,D,TLTXD)  /* >: */
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:355:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1geBB,B,B,GE   )  INDF( i1geBI,B,I,AGE  )  INDF( i1geBD,B,D,TGEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:355:1: note: place parentheses around the assignment to silence this warning
INDB( i1geBB,B,B,GE   )  INDF( i1geBI,B,I,AGE  )  INDF( i1geBD,B,D,TGEXD)
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:355:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1geBB,B,B,GE   )  INDF( i1geBI,B,I,AGE  )  INDF( i1geBD,B,D,TGEXD)
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:355:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1geBB,B,B,GE   )  INDF( i1geBI,B,I,AGE  )  INDF( i1geBD,B,D,TGEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:355:1: note: place parentheses around the assignment to silence this warning
INDB( i1geBB,B,B,GE   )  INDF( i1geBI,B,I,AGE  )  INDF( i1geBD,B,D,TGEXD)
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:355:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1geBB,B,B,GE   )  INDF( i1geBI,B,I,AGE  )  INDF( i1geBD,B,D,TGEXD)
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:355:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1geBB,B,B,GE   )  INDF( i1geBI,B,I,AGE  )  INDF( i1geBD,B,D,TGEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:355:1: note: place parentheses around the assignment to silence this warning
INDB( i1geBB,B,B,GE   )  INDF( i1geBI,B,I,AGE  )  INDF( i1geBD,B,D,TGEXD)
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:355:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1geBB,B,B,GE   )  INDF( i1geBI,B,I,AGE  )  INDF( i1geBD,B,D,TGEXD)
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:359:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0geBB,B,B,LT   )  JNDF( j0geBI,B,I,ALT  )  JNDF( j0geBD,B,D,TLTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:359:1: note: place parentheses around the assignment to silence this warning
JNDB( j0geBB,B,B,LT   )  JNDF( j0geBI,B,I,ALT  )  JNDF( j0geBD,B,D,TLTXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:359:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0geBB,B,B,LT   )  JNDF( j0geBI,B,I,ALT  )  JNDF( j0geBD,B,D,TLTXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:359:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0geBB,B,B,LT   )  JNDF( j0geBI,B,I,ALT  )  JNDF( j0geBD,B,D,TLTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:359:1: note: place parentheses around the assignment to silence this warning
JNDB( j0geBB,B,B,LT   )  JNDF( j0geBI,B,I,ALT  )  JNDF( j0geBD,B,D,TLTXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:359:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0geBB,B,B,LT   )  JNDF( j0geBI,B,I,ALT  )  JNDF( j0geBD,B,D,TLTXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:359:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0geBB,B,B,LT   )  JNDF( j0geBI,B,I,ALT  )  JNDF( j0geBD,B,D,TLTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:359:1: note: place parentheses around the assignment to silence this warning
JNDB( j0geBB,B,B,LT   )  JNDF( j0geBI,B,I,ALT  )  JNDF( j0geBD,B,D,TLTXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:359:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0geBB,B,B,LT   )  JNDF( j0geBI,B,I,ALT  )  JNDF( j0geBD,B,D,TLTXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:363:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1geBB,B,B,GE   )  JNDF( j1geBI,B,I,AGE  )  JNDF( j1geBD,B,D,TGEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:363:1: note: place parentheses around the assignment to silence this warning
JNDB( j1geBB,B,B,GE   )  JNDF( j1geBI,B,I,AGE  )  JNDF( j1geBD,B,D,TGEXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:363:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1geBB,B,B,GE   )  JNDF( j1geBI,B,I,AGE  )  JNDF( j1geBD,B,D,TGEXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:363:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1geBB,B,B,GE   )  JNDF( j1geBI,B,I,AGE  )  JNDF( j1geBD,B,D,TGEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:363:1: note: place parentheses around the assignment to silence this warning
JNDB( j1geBB,B,B,GE   )  JNDF( j1geBI,B,I,AGE  )  JNDF( j1geBD,B,D,TGEXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:363:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1geBB,B,B,GE   )  JNDF( j1geBI,B,I,AGE  )  JNDF( j1geBD,B,D,TGEXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:363:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1geBB,B,B,GE   )  JNDF( j1geBI,B,I,AGE  )  JNDF( j1geBD,B,D,TGEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:363:1: note: place parentheses around the assignment to silence this warning
JNDB( j1geBB,B,B,GE   )  JNDF( j1geBI,B,I,AGE  )  JNDF( j1geBD,B,D,TGEXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:363:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1geBB,B,B,GE   )  JNDF( j1geBI,B,I,AGE  )  JNDF( j1geBD,B,D,TGEXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:379:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbgeBB,B,B,GE   )  IFBF(ifbgeBI,B,I,AGE  )  IFBF(ifbgeBD,B,D,TGEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:379:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbgeBB,B,B,GE   )  IFBF(ifbgeBI,B,I,AGE  )  IFBF(ifbgeBD,B,D,TGEXD)
^
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:379:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbgeBB,B,B,GE   )  IFBF(ifbgeBI,B,I,AGE  )  IFBF(ifbgeBD,B,D,TGEXD)
^
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:379:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbgeBB,B,B,GE   )  IFBF(ifbgeBI,B,I,AGE  )  IFBF(ifbgeBD,B,D,TGEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:379:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbgeBB,B,B,GE   )  IFBF(ifbgeBI,B,I,AGE  )  IFBF(ifbgeBD,B,D,TGEXD)
^
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:379:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbgeBB,B,B,GE   )  IFBF(ifbgeBI,B,I,AGE  )  IFBF(ifbgeBD,B,D,TGEXD)
^
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:379:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbgeBB,B,B,GE   )  IFBF(ifbgeBI,B,I,AGE  )  IFBF(ifbgeBD,B,D,TGEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:379:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbgeBB,B,B,GE   )  IFBF(ifbgeBI,B,I,AGE  )  IFBF(ifbgeBD,B,D,TGEXD)
^
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:379:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbgeBB,B,B,GE   )  IFBF(ifbgeBI,B,I,AGE  )  IFBF(ifbgeBD,B,D,TGEXD)
^
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:383:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0gtBB,B,B,LE   )  INDF( i0gtBI,B,I,ALE  )  INDF( i0gtBD,B,D,TLEXD)  /* >  */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:383:1: note: place parentheses around the assignment to silence this warning
INDB( i0gtBB,B,B,LE   )  INDF( i0gtBI,B,I,ALE  )  INDF( i0gtBD,B,D,TLEXD)  /* >  */
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:383:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0gtBB,B,B,LE   )  INDF( i0gtBI,B,I,ALE  )  INDF( i0gtBD,B,D,TLEXD)  /* >  */
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:383:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0gtBB,B,B,LE   )  INDF( i0gtBI,B,I,ALE  )  INDF( i0gtBD,B,D,TLEXD)  /* >  */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:383:1: note: place parentheses around the assignment to silence this warning
INDB( i0gtBB,B,B,LE   )  INDF( i0gtBI,B,I,ALE  )  INDF( i0gtBD,B,D,TLEXD)  /* >  */
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:383:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0gtBB,B,B,LE   )  INDF( i0gtBI,B,I,ALE  )  INDF( i0gtBD,B,D,TLEXD)  /* >  */
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:383:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i0gtBB,B,B,LE   )  INDF( i0gtBI,B,I,ALE  )  INDF( i0gtBD,B,D,TLEXD)  /* >  */
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:383:1: note: place parentheses around the assignment to silence this warning
INDB( i0gtBB,B,B,LE   )  INDF( i0gtBI,B,I,ALE  )  INDF( i0gtBD,B,D,TLEXD)  /* >  */
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:383:1: note: use '==' to turn this assignment into an equality comparison
INDB( i0gtBB,B,B,LE   )  INDF( i0gtBI,B,I,ALE  )  INDF( i0gtBD,B,D,TLEXD)  /* >  */
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:387:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1gtBB,B,B,GT   )  INDF( i1gtBI,B,I,AGT  )  INDF( i1gtBD,B,D,TGTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:387:1: note: place parentheses around the assignment to silence this warning
INDB( i1gtBB,B,B,GT   )  INDF( i1gtBI,B,I,AGT  )  INDF( i1gtBD,B,D,TGTXD)
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:387:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1gtBB,B,B,GT   )  INDF( i1gtBI,B,I,AGT  )  INDF( i1gtBD,B,D,TGTXD)
^
vcompsc.c:108:42: note: expanded from macro 'INDB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))INDB3;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:387:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1gtBB,B,B,GT   )  INDF( i1gtBI,B,I,AGT  )  INDF( i1gtBD,B,D,TGTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:387:1: note: place parentheses around the assignment to silence this warning
INDB( i1gtBB,B,B,GT   )  INDF( i1gtBI,B,I,AGT  )  INDF( i1gtBD,B,D,TGTXD)
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:387:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1gtBB,B,B,GT   )  INDF( i1gtBI,B,I,AGT  )  INDF( i1gtBD,B,D,TGTXD)
^
vcompsc.c:109:42: note: expanded from macro 'INDB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))INDB3;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:387:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
INDB( i1gtBB,B,B,GT   )  INDF( i1gtBI,B,I,AGT  )  INDF( i1gtBD,B,D,TGTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:387:1: note: place parentheses around the assignment to silence this warning
INDB( i1gtBB,B,B,GT   )  INDF( i1gtBI,B,I,AGT  )  INDF( i1gtBD,B,D,TGTXD)
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:387:1: note: use '==' to turn this assignment into an equality comparison
INDB( i1gtBB,B,B,GT   )  INDF( i1gtBI,B,I,AGT  )  INDF( i1gtBD,B,D,TGTXD)
^
vcompsc.c:110:42: note: expanded from macro 'INDB'
  else           {             DO(q, if(y=F(*av++,*wv++))INDB3;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:391:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0gtBB,B,B,LE   )  JNDF( j0gtBI,B,I,ALE  )  JNDF( j0gtBD,B,D,TLEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:391:1: note: place parentheses around the assignment to silence this warning
JNDB( j0gtBB,B,B,LE   )  JNDF( j0gtBI,B,I,ALE  )  JNDF( j0gtBD,B,D,TLEXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:391:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0gtBB,B,B,LE   )  JNDF( j0gtBI,B,I,ALE  )  JNDF( j0gtBD,B,D,TLEXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:391:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0gtBB,B,B,LE   )  JNDF( j0gtBI,B,I,ALE  )  JNDF( j0gtBD,B,D,TLEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:391:1: note: place parentheses around the assignment to silence this warning
JNDB( j0gtBB,B,B,LE   )  JNDF( j0gtBI,B,I,ALE  )  JNDF( j0gtBD,B,D,TLEXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:391:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0gtBB,B,B,LE   )  JNDF( j0gtBI,B,I,ALE  )  JNDF( j0gtBD,B,D,TLEXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:391:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j0gtBB,B,B,LE   )  JNDF( j0gtBI,B,I,ALE  )  JNDF( j0gtBD,B,D,TLEXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:391:1: note: place parentheses around the assignment to silence this warning
JNDB( j0gtBB,B,B,LE   )  JNDF( j0gtBI,B,I,ALE  )  JNDF( j0gtBD,B,D,TLEXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:391:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j0gtBB,B,B,LE   )  JNDF( j0gtBI,B,I,ALE  )  JNDF( j0gtBD,B,D,TLEXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:395:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1gtBB,B,B,GT   )  JNDF( j1gtBI,B,I,AGT  )  JNDF( j1gtBD,B,D,TGTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:395:1: note: place parentheses around the assignment to silence this warning
JNDB( j1gtBB,B,B,GT   )  JNDF( j1gtBI,B,I,AGT  )  JNDF( j1gtBD,B,D,TGTXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:395:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1gtBB,B,B,GT   )  JNDF( j1gtBI,B,I,AGT  )  JNDF( j1gtBD,B,D,TGTXD)
^
vcompsc.c:121:68: note: expanded from macro 'JNDB'
  if     (!AR(a)){ASSIGNX(av); wv+=q; JNDBR(F(x,  *wv)); DO(q, if(y=F(x,    *--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:395:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1gtBB,B,B,GT   )  JNDF( j1gtBI,B,I,AGT  )  JNDF( j1gtBD,B,D,TGTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:395:1: note: place parentheses around the assignment to silence this warning
JNDB( j1gtBB,B,B,GT   )  JNDF( j1gtBI,B,I,AGT  )  JNDF( j1gtBD,B,D,TGTXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:395:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1gtBB,B,B,GT   )  JNDF( j1gtBI,B,I,AGT  )  JNDF( j1gtBD,B,D,TGTXD)
^
vcompsc.c:122:68: note: expanded from macro 'JNDB'
  else if(!AR(w)){ASSIGNX(wv); av+=q; JNDBR(F(*av,x  )); DO(q, if(y=F(*--av,x    ))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:395:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
JNDB( j1gtBB,B,B,GT   )  JNDF( j1gtBI,B,I,AGT  )  JNDF( j1gtBD,B,D,TGTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                  ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:395:1: note: place parentheses around the assignment to silence this warning
JNDB( j1gtBB,B,B,GT   )  JNDF( j1gtBI,B,I,AGT  )  JNDF( j1gtBD,B,D,TGTXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:395:1: note: use '==' to turn this assignment into an equality comparison
JNDB( j1gtBB,B,B,GT   )  JNDF( j1gtBI,B,I,AGT  )  JNDF( j1gtBD,B,D,TGTXD)
^
vcompsc.c:123:68: note: expanded from macro 'JNDB'
  else           {av+=q;       wv+=q; JNDBR(F(*av,*wv)); DO(q, if(y=F(*--av,*--wv))JNDB3;);}  \
                                                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:411:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbgtBB,B,B,GT   )  IFBF(ifbgtBI,B,I,AGT  )  IFBF(ifbgtBD,B,D,TGTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:411:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbgtBB,B,B,GT   )  IFBF(ifbgtBI,B,I,AGT  )  IFBF(ifbgtBD,B,D,TGTXD)
^
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:411:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbgtBB,B,B,GT   )  IFBF(ifbgtBI,B,I,AGT  )  IFBF(ifbgtBD,B,D,TGTXD)
^
vcompsc.c:216:42: note: expanded from macro 'IFBB'
  if     (!AR(a)){ASSIGNX(av); DO(q, if(y=F(x,    *wv++))IFB3; m+=SZI;); y=F(x,  *wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:411:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbgtBB,B,B,GT   )  IFBF(ifbgtBI,B,I,AGT  )  IFBF(ifbgtBD,B,D,TGTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:411:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbgtBB,B,B,GT   )  IFBF(ifbgtBI,B,I,AGT  )  IFBF(ifbgtBD,B,D,TGTXD)
^
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:411:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbgtBB,B,B,GT   )  IFBF(ifbgtBI,B,I,AGT  )  IFBF(ifbgtBD,B,D,TGTXD)
^
vcompsc.c:217:42: note: expanded from macro 'IFBB'
  else if(!AR(w)){ASSIGNX(wv); DO(q, if(y=F(*av++,x    ))IFB3; m+=SZI;); y=F(*av,x  );}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:411:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
IFBB(ifbgtBB,B,B,GT   )  IFBF(ifbgtBI,B,I,AGT  )  IFBF(ifbgtBD,B,D,TGTXD)
^~~~~~~~~~~~~~~~~~~~~~~
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                        ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:411:1: note: place parentheses around the assignment to silence this warning
IFBB(ifbgtBB,B,B,GT   )  IFBF(ifbgtBI,B,I,AGT  )  IFBF(ifbgtBD,B,D,TGTXD)
^
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:411:1: note: use '==' to turn this assignment into an equality comparison
IFBB(ifbgtBB,B,B,GT   )  IFBF(ifbgtBI,B,I,AGT  )  IFBF(ifbgtBD,B,D,TGTXD)
^
vcompsc.c:218:42: note: expanded from macro 'IFBB'
  else           {             DO(q, if(y=F(*av++,*wv++))IFB3; m+=SZI;); y=F(*av,*wv);}  \
                                         ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vcompsc.c:578:25: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(1<ar||1<wr){if(32<=m&&m<=37||40<=m&&m<=45||48<=m&&m<=53)R(AF)jtfslashatg; RZ(7==m%8);}
                   ~~~~~^~~~~~~~~
vcompsc.c:578:25: note: place parentheses around the '&&' expression to silence this warning
 if(1<ar||1<wr){if(32<=m&&m<=37||40<=m&&m<=45||48<=m&&m<=53)R(AF)jtfslashatg; RZ(7==m%8);}
                        ^
                   (           )
vcompsc.c:578:39: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(1<ar||1<wr){if(32<=m&&m<=37||40<=m&&m<=45||48<=m&&m<=53)R(AF)jtfslashatg; RZ(7==m%8);}
                               ~~~~~~~^~~~~~~
vcompsc.c:578:39: note: place parentheses around the '&&' expression to silence this warning
 if(1<ar||1<wr){if(32<=m&&m<=37||40<=m&&m<=45||48<=m&&m<=53)R(AF)jtfslashatg; RZ(7==m%8);}
                                      ^
                                 (           )
vcompsc.c:578:53: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(1<ar||1<wr){if(32<=m&&m<=37||40<=m&&m<=45||48<=m&&m<=53)R(AF)jtfslashatg; RZ(7==m%8);}
                                             ~~~~~~~^~~~~~~
vcompsc.c:578:53: note: place parentheses around the '&&' expression to silence this warning
 if(1<ar||1<wr){if(32<=m&&m<=37||40<=m&&m<=45||48<=m&&m<=53)R(AF)jtfslashatg; RZ(7==m%8);}
                                                    ^
                                               (           )
93 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vd.o vd.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vdx.o vdx.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o ve.o ve.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vf.o vf.c
vf.c:54:13: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  DO(n, if(k=qv[i]){d=s[av[i]]-k; v=i+AV(y); DO(m, *v<k?(*v+=d):(*v-=k); v+=n;);});
           ~^~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vf.c:54:13: note: place parentheses around the assignment to silence this warning
  DO(n, if(k=qv[i]){d=s[av[i]]-k; v=i+AV(y); DO(m, *v<k?(*v+=d):(*v-=k); v+=n;);});
            ^
           (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vf.c:54:13: note: use '==' to turn this assignment into an equality comparison
  DO(n, if(k=qv[i]){d=s[av[i]]-k; v=i+AV(y); DO(m, *v<k?(*v+=d):(*v-=k); v+=n;);});
            ^
            ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vf.c:90:14: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(1<acr||af&&acr||af&&!wf)R df2(a,w,qq(qq(ds(CROT),v2(1L,RMAX)),v2(acr,wcr)));
         ~~~~^~~~~
vf.c:90:14: note: place parentheses around the '&&' expression to silence this warning
 if(1<acr||af&&acr||af&&!wf)R df2(a,w,qq(qq(ds(CROT),v2(1L,RMAX)),v2(acr,wcr)));
             ^
           (      )
vf.c:90:23: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(1<acr||af&&acr||af&&!wf)R df2(a,w,qq(qq(ds(CROT),v2(1L,RMAX)),v2(acr,wcr)));
                  ~~~~^~~~~
vf.c:90:23: note: place parentheses around the '&&' expression to silence this warning
 if(1<acr||af&&acr||af&&!wf)R df2(a,w,qq(qq(ds(CROT),v2(1L,RMAX)),v2(acr,wcr)));
                      ^
                    (      )
3 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vfft.o vfft.c
vfft.c:66:1: warning: control reaches end of non-void function [-Wreturn-type]
}
^
1 warning generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vfrom.o vfrom.c
vfrom.c:297:5: warning: expression result unused [-Wunused-value]
 RE(y); if(b){RZ(y=ca(x=y)); RZ(y=RELOCATE(x,y));} EPILOG(y);
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
1 warning generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vfromsp.o vfromsp.c
vfromsp.c:18:3: warning: add explicit braces to avoid dangling else [-Wdangling-else]
  else R reshape(mtv,AN(x)?x:SPA(zp,e));
  ^
vfromsp.c:59:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(k=ar-1)DO(an, if(av[i]>=wf)av[i]+=k;);
    ~^~~~~
vfromsp.c:59:6: note: place parentheses around the assignment to silence this warning
 if(k=ar-1)DO(an, if(av[i]>=wf)av[i]+=k;);
     ^
    (     )
vfromsp.c:59:6: note: use '==' to turn this assignment into an equality comparison
 if(k=ar-1)DO(an, if(av[i]>=wf)av[i]+=k;);
     ^
     ==
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vg.o vg.c
vg.c:39:36: warning: add explicit braces to avoid dangling else [-Wdangling-else]
   if(VS(1,2))if(VS(0,2))P3(2,0,1) else XC(1,2);
                                   ^
vg.c:45:36: warning: add explicit braces to avoid dangling else [-Wdangling-else]
   if(VS(1,2))if(VS(0,2))P3(2,0,1) else XC(1,2);
                                   ^
vg.c:53:49: warning: add explicit braces to avoid dangling else [-Wdangling-else]
   if(VS(2,b)){if(3!=c)if(VS(2,c))P5(a,b,c,2,d) else P5(a,b,2,c,d);}
                                                ^
vg.c:110:42: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case 0: t=yv+c+d;     DO(d,   --t; if(k=*t){*t=s; s+=k;}); break;
                                        ~^~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:110:42: note: place parentheses around the assignment to silence this warning
  case 0: t=yv+c+d;     DO(d,   --t; if(k=*t){*t=s; s+=k;}); break;
                                         ^
                                        (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:110:42: note: use '==' to turn this assignment into an equality comparison
  case 0: t=yv+c+d;     DO(d,   --t; if(k=*t){*t=s; s+=k;}); break;
                                         ^
                                         ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:111:42: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case 1: t=yv+c-1;     DO(d,   ++t; if(k=*t){*t=s; s+=k;}); break;
                                        ~^~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:111:42: note: place parentheses around the assignment to silence this warning
  case 1: t=yv+c-1;     DO(d,   ++t; if(k=*t){*t=s; s+=k;}); break;
                                         ^
                                        (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:111:42: note: use '==' to turn this assignment into an equality comparison
  case 1: t=yv+c-1;     DO(d,   ++t; if(k=*t){*t=s; s+=k;}); break;
                                         ^
                                         ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:112:42: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case 2: t=yv+c+d/2;   DO(d/2, --t; if(k=*t){*t=s; s+=k;}); 
                                        ~^~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:112:42: note: place parentheses around the assignment to silence this warning
  case 2: t=yv+c+d/2;   DO(d/2, --t; if(k=*t){*t=s; s+=k;}); 
                                         ^
                                        (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:112:42: note: use '==' to turn this assignment into an equality comparison
  case 2: t=yv+c+d/2;   DO(d/2, --t; if(k=*t){*t=s; s+=k;}); 
                                         ^
                                         ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:113:42: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
          t=yv+c+d  ;   DO(d/2, --t; if(k=*t){*t=s; s+=k;}); break;
                                        ~^~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:113:42: note: place parentheses around the assignment to silence this warning
          t=yv+c+d  ;   DO(d/2, --t; if(k=*t){*t=s; s+=k;}); break;
                                         ^
                                        (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:113:42: note: use '==' to turn this assignment into an equality comparison
          t=yv+c+d  ;   DO(d/2, --t; if(k=*t){*t=s; s+=k;}); break;
                                         ^
                                         ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:114:42: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case 3: t=yv+c+d/2-1; DO(d/2, ++t; if(k=*t){*t=s; s+=k;}); 
                                        ~^~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:114:42: note: place parentheses around the assignment to silence this warning
  case 3: t=yv+c+d/2-1; DO(d/2, ++t; if(k=*t){*t=s; s+=k;}); 
                                         ^
                                        (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:114:42: note: use '==' to turn this assignment into an equality comparison
  case 3: t=yv+c+d/2-1; DO(d/2, ++t; if(k=*t){*t=s; s+=k;}); 
                                         ^
                                         ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:115:42: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
          t=yv+c    -1; DO(d/2, ++t; if(k=*t){*t=s; s+=k;});
                                        ~^~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:115:42: note: place parentheses around the assignment to silence this warning
          t=yv+c    -1; DO(d/2, ++t; if(k=*t){*t=s; s+=k;});
                                         ^
                                        (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:115:42: note: use '==' to turn this assignment into an equality comparison
          t=yv+c    -1; DO(d/2, ++t; if(k=*t){*t=s; s+=k;});
                                         ^
                                         ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:206:24: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(up)DO(p,      if(k=yv[i]){yv[i]=s; s+=k;}) 
                      ~^~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:206:24: note: place parentheses around the assignment to silence this warning
  if(up)DO(p,      if(k=yv[i]){yv[i]=s; s+=k;}) 
                       ^
                      (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:206:24: note: use '==' to turn this assignment into an equality comparison
  if(up)DO(p,      if(k=yv[i]){yv[i]=s; s+=k;}) 
                       ^
                       ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:207:24: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  else  DO(p, --j; if(k=yv[j]){yv[j]=s; s+=k;});
                      ~^~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:207:24: note: place parentheses around the assignment to silence this warning
  else  DO(p, --j; if(k=yv[j]){yv[j]=s; s+=k;});
                       ^
                      (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:207:24: note: use '==' to turn this assignment into an equality comparison
  else  DO(p, --j; if(k=yv[j]){yv[j]=s; s+=k;});
                       ^
                       ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:218:25: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   if(up)DO(p,      if(k=yv[i]){yv[i]=s; s+=k;}) 
                       ~^~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:218:25: note: place parentheses around the assignment to silence this warning
   if(up)DO(p,      if(k=yv[i]){yv[i]=s; s+=k;}) 
                        ^
                       (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:218:25: note: use '==' to turn this assignment into an equality comparison
   if(up)DO(p,      if(k=yv[i]){yv[i]=s; s+=k;}) 
                        ^
                        ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:219:25: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   else  DO(p, --j; if(k=yv[j]){yv[j]=s; s+=k;});
                       ~^~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:219:25: note: place parentheses around the assignment to silence this warning
   else  DO(p, --j; if(k=yv[j]){yv[j]=s; s+=k;});
                        ^
                       (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:219:25: note: use '==' to turn this assignment into an equality comparison
   else  DO(p, --j; if(k=yv[j]){yv[j]=s; s+=k;});
                        ^
                        ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:257:62: warning: expression result unused [-Wunused-value]
  DO(q-1,  vv-=4; DOCOL4(p, *(int*)v, *(int*)(v+d*g[i]),g[i],v   ););
                                                             ^
vg.c:247:47: note: expanded from macro 'DOCOL4'
  v=vv; DO(n, IND4(iicalc1); h[yv[ii]++]=ind; vinc;);  \
                                              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:267:14: warning: use of logical '&&' with constant operand [-Wconstant-logical-operand]
 q=C2T&AT(w) && SYS&SYS_LILENDIAN;
             ^  ~~~~~~~~~~~~~~~~~
vg.c:267:14: note: use '&' for a bitwise operation
 q=C2T&AT(w) && SYS&SYS_LILENDIAN;
             ^~
             &
vg.c:267:14: note: remove constant to silence this warning
 q=C2T&AT(w) && SYS&SYS_LILENDIAN;
            ~^~~~~~~~~~~~~~~~~~~~
vg.c:272:45: warning: expression result unused [-Wunused-value]
  DO(d-1, vv+=e; DOCOL1(p,*v,v[d*g[i]],g[i],v   ); if(q)e=1==e?-3:1;);
                                            ^
vg.c:237:47: note: expanded from macro 'DOCOL1'
  v=vv; DO(n, h[yv[iicalc1]++]=ind;           vinc;);  \
                                              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vg.c:361:11: warning: add explicit braces to avoid dangling else [-Wdangling-else]
 if(wt&FL)OSLOOP(D,scf) else OSLOOP(I,sc);
          ^
vg.c:341:19: note: expanded from macro 'OSLOOP'
   if(4>=n){u=tv; SORT4; R ATOMF(tv[j]);}                                              \
                  ^
vg.c:329:40: note: expanded from macro 'SORT4'
   if(OSGT(1,2))if(OSGT(0,2))P3(2,0,1) else XC(1,2); break;  \
                                       ^
vg.c:361:11: warning: add explicit braces to avoid dangling else [-Wdangling-else]
 if(wt&FL)OSLOOP(D,scf) else OSLOOP(I,sc);
          ^
vg.c:341:19: note: expanded from macro 'OSLOOP'
   if(4>=n){u=tv; SORT4; R ATOMF(tv[j]);}                                              \
                  ^
vg.c:334:40: note: expanded from macro 'SORT4'
   if(OSGT(1,2))if(OSGT(0,2))P3(2,0,1) else XC(1,2);         \
                                       ^
vg.c:361:30: warning: add explicit braces to avoid dangling else [-Wdangling-else]
 if(wt&FL)OSLOOP(D,scf) else OSLOOP(I,sc);
                             ^
vg.c:341:19: note: expanded from macro 'OSLOOP'
   if(4>=n){u=tv; SORT4; R ATOMF(tv[j]);}                                              \
                  ^
vg.c:329:40: note: expanded from macro 'SORT4'
   if(OSGT(1,2))if(OSGT(0,2))P3(2,0,1) else XC(1,2); break;  \
                                       ^
vg.c:361:30: warning: add explicit braces to avoid dangling else [-Wdangling-else]
 if(wt&FL)OSLOOP(D,scf) else OSLOOP(I,sc);
                             ^
vg.c:341:19: note: expanded from macro 'OSLOOP'
   if(4>=n){u=tv; SORT4; R ATOMF(tv[j]);}                                              \
                  ^
vg.c:334:40: note: expanded from macro 'SORT4'
   if(OSGT(1,2))if(OSGT(0,2))P3(2,0,1) else XC(1,2);         \
                                       ^
20 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vgauss.o vgauss.c
vgauss.c:51:5: warning: expression result unused [-Wunused-value]
 RE(0);
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
vgauss.c:94:11: warning: expression result unused [-Wunused-value]
 NAN1; RE(0);
          ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vgcomp.o vgcomp.c
vgcomp.c:26:11: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
CF(compa){COMPLOOPF(A, jt->compn,compare ); R a>b?1:-1;}
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vgcomp.c:17:56: note: expanded from macro 'COMPLOOPF'
#define COMPLOOPF(T,m,f) {COMPDCLP(T);int j; DO(m, if(j=f(x[i],y[i]))R j;);}
                                                      ~^~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:26:11: note: place parentheses around the assignment to silence this warning
CF(compa){COMPLOOPF(A, jt->compn,compare ); R a>b?1:-1;}
          ^
vgcomp.c:17:56: note: expanded from macro 'COMPLOOPF'
#define COMPLOOPF(T,m,f) {COMPDCLP(T);int j; DO(m, if(j=f(x[i],y[i]))R j;);}
                                                       ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:26:11: note: use '==' to turn this assignment into an equality comparison
CF(compa){COMPLOOPF(A, jt->compn,compare ); R a>b?1:-1;}
          ^
vgcomp.c:17:56: note: expanded from macro 'COMPLOOPF'
#define COMPLOOPF(T,m,f) {COMPDCLP(T);int j; DO(m, if(j=f(x[i],y[i]))R j;);}
                                                       ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:27:11: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
CF(compr){COMPLOOPR(A1,jt->compn,compare ); R a>b?1:-1;}
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vgcomp.c:18:56: note: expanded from macro 'COMPLOOPR'
#define COMPLOOPR(T,m,f) {COMPDCLP(T);int j; DO(m, if(j=f((A)AABS(x[i],jt->compw),(A)AABS(y[i],jt->compw)))R j;);}
                                                      ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:27:11: note: place parentheses around the assignment to silence this warning
CF(compr){COMPLOOPR(A1,jt->compn,compare ); R a>b?1:-1;}
          ^
vgcomp.c:18:56: note: expanded from macro 'COMPLOOPR'
#define COMPLOOPR(T,m,f) {COMPDCLP(T);int j; DO(m, if(j=f((A)AABS(x[i],jt->compw),(A)AABS(y[i],jt->compw)))R j;);}
                                                       ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:27:11: note: use '==' to turn this assignment into an equality comparison
CF(compr){COMPLOOPR(A1,jt->compn,compare ); R a>b?1:-1;}
          ^
vgcomp.c:18:56: note: expanded from macro 'COMPLOOPR'
#define COMPLOOPR(T,m,f) {COMPDCLP(T);int j; DO(m, if(j=f((A)AABS(x[i],jt->compw),(A)AABS(y[i],jt->compw)))R j;);}
                                                       ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:28:11: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
CF(compx){COMPLOOPG(X, jt->compn,xcompare); R a>b?1:-1;}
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vgcomp.c:19:56: note: expanded from macro 'COMPLOOPG'
#define COMPLOOPG(T,m,f) {COMPDCLP(T);int j; DO(m, if(j=f(x[i],y[i]))R 0<j?jt->compgt:jt->complt;);}
                                                      ~^~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:28:11: note: place parentheses around the assignment to silence this warning
CF(compx){COMPLOOPG(X, jt->compn,xcompare); R a>b?1:-1;}
          ^
vgcomp.c:19:56: note: expanded from macro 'COMPLOOPG'
#define COMPLOOPG(T,m,f) {COMPDCLP(T);int j; DO(m, if(j=f(x[i],y[i]))R 0<j?jt->compgt:jt->complt;);}
                                                       ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:28:11: note: use '==' to turn this assignment into an equality comparison
CF(compx){COMPLOOPG(X, jt->compn,xcompare); R a>b?1:-1;}
          ^
vgcomp.c:19:56: note: expanded from macro 'COMPLOOPG'
#define COMPLOOPG(T,m,f) {COMPDCLP(T);int j; DO(m, if(j=f(x[i],y[i]))R 0<j?jt->compgt:jt->complt;);}
                                                       ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:29:11: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
CF(compq){COMPLOOPG(Q, jt->compn,QCOMP   ); R a>b?1:-1;}
          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vgcomp.c:19:56: note: expanded from macro 'COMPLOOPG'
#define COMPLOOPG(T,m,f) {COMPDCLP(T);int j; DO(m, if(j=f(x[i],y[i]))R 0<j?jt->compgt:jt->complt;);}
                                                      ~^~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:29:11: note: place parentheses around the assignment to silence this warning
CF(compq){COMPLOOPG(Q, jt->compn,QCOMP   ); R a>b?1:-1;}
          ^
vgcomp.c:19:56: note: expanded from macro 'COMPLOOPG'
#define COMPLOOPG(T,m,f) {COMPDCLP(T);int j; DO(m, if(j=f(x[i],y[i]))R 0<j?jt->compgt:jt->complt;);}
                                                       ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:29:11: note: use '==' to turn this assignment into an equality comparison
CF(compq){COMPLOOPG(Q, jt->compn,QCOMP   ); R a>b?1:-1;}
          ^
vgcomp.c:19:56: note: expanded from macro 'COMPLOOPG'
#define COMPLOOPG(T,m,f) {COMPDCLP(T);int j; DO(m, if(j=f(x[i],y[i]))R 0<j?jt->compgt:jt->complt;);}
                                                       ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:67:15: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   case XNUM: COMPLOOQG(X, m, xcompare); break;
              ^~~~~~~~~~~~~~~~~~~~~~~~~
vgcomp.c:20:56: note: expanded from macro 'COMPLOOQG'
#define COMPLOOQG(T,m,f) {COMPDCLQ(T);int j; DO(m, if(j=f(x[i],y[i]))R 0<j?jt->compgt:jt->complt;);}
                                                      ~^~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:67:15: note: place parentheses around the assignment to silence this warning
   case XNUM: COMPLOOQG(X, m, xcompare); break;
              ^
vgcomp.c:20:56: note: expanded from macro 'COMPLOOQG'
#define COMPLOOQG(T,m,f) {COMPDCLQ(T);int j; DO(m, if(j=f(x[i],y[i]))R 0<j?jt->compgt:jt->complt;);}
                                                       ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:67:15: note: use '==' to turn this assignment into an equality comparison
   case XNUM: COMPLOOQG(X, m, xcompare); break;
              ^
vgcomp.c:20:56: note: expanded from macro 'COMPLOOQG'
#define COMPLOOQG(T,m,f) {COMPDCLQ(T);int j; DO(m, if(j=f(x[i],y[i]))R 0<j?jt->compgt:jt->complt;);}
                                                       ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:68:15: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   case RAT:  COMPLOOQG(Q, m, QCOMP   ); break;
              ^~~~~~~~~~~~~~~~~~~~~~~~~
vgcomp.c:20:56: note: expanded from macro 'COMPLOOQG'
#define COMPLOOQG(T,m,f) {COMPDCLQ(T);int j; DO(m, if(j=f(x[i],y[i]))R 0<j?jt->compgt:jt->complt;);}
                                                      ~^~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:68:15: note: place parentheses around the assignment to silence this warning
   case RAT:  COMPLOOQG(Q, m, QCOMP   ); break;
              ^
vgcomp.c:20:56: note: expanded from macro 'COMPLOOQG'
#define COMPLOOQG(T,m,f) {COMPDCLQ(T);int j; DO(m, if(j=f(x[i],y[i]))R 0<j?jt->compgt:jt->complt;);}
                                                       ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:68:15: note: use '==' to turn this assignment into an equality comparison
   case RAT:  COMPLOOQG(Q, m, QCOMP   ); break;
              ^
vgcomp.c:20:56: note: expanded from macro 'COMPLOOQG'
#define COMPLOOQG(T,m,f) {COMPDCLQ(T);int j; DO(m, if(j=f(x[i],y[i]))R 0<j?jt->compgt:jt->complt;);}
                                                       ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:70:43: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
    case 0: {COMPDCLQ(A);int j; DO(m, if(j=compare(        x[i],           y[i]   ))R j;);} break;
                                         ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:70:43: note: place parentheses around the assignment to silence this warning
    case 0: {COMPDCLQ(A);int j; DO(m, if(j=compare(        x[i],           y[i]   ))R j;);} break;
                                          ^
                                         (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:70:43: note: use '==' to turn this assignment into an equality comparison
    case 0: {COMPDCLQ(A);int j; DO(m, if(j=compare(        x[i],           y[i]   ))R j;);} break;
                                          ^
                                          ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:71:43: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
    case 1: {COMPDCLQ(A);int j; DO(m, if(j=compare(        x[i],   (A)AABS(y[i],w)))R j;);} break;
                                         ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:71:43: note: place parentheses around the assignment to silence this warning
    case 1: {COMPDCLQ(A);int j; DO(m, if(j=compare(        x[i],   (A)AABS(y[i],w)))R j;);} break;
                                          ^
                                         (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:71:43: note: use '==' to turn this assignment into an equality comparison
    case 1: {COMPDCLQ(A);int j; DO(m, if(j=compare(        x[i],   (A)AABS(y[i],w)))R j;);} break;
                                          ^
                                          ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:72:43: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
    case 2: {COMPDCLQ(A);int j; DO(m, if(j=compare((A)AABS(x[i],a),        y[i]   ))R j;);} break;
                                         ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:72:43: note: place parentheses around the assignment to silence this warning
    case 2: {COMPDCLQ(A);int j; DO(m, if(j=compare((A)AABS(x[i],a),        y[i]   ))R j;);} break;
                                          ^
                                         (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:72:43: note: use '==' to turn this assignment into an equality comparison
    case 2: {COMPDCLQ(A);int j; DO(m, if(j=compare((A)AABS(x[i],a),        y[i]   ))R j;);} break;
                                          ^
                                          ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:73:43: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
    case 3: {COMPDCLQ(A);int j; DO(m, if(j=compare((A)AABS(x[i],a),(A)AABS(y[i],w)))R j;);} break;
                                         ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:73:43: note: place parentheses around the assignment to silence this warning
    case 3: {COMPDCLQ(A);int j; DO(m, if(j=compare((A)AABS(x[i],a),(A)AABS(y[i],w)))R j;);} break;
                                          ^
                                         (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:73:43: note: use '==' to turn this assignment into an equality comparison
    case 3: {COMPDCLQ(A);int j; DO(m, if(j=compare((A)AABS(x[i],a),(A)AABS(y[i],w)))R j;);} break;
                                          ^
                                          ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:124:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
COMPSPDS(compspdsB,B,0,                   e       )
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vgcomp.c:116:55: note: expanded from macro 'COMPSPDS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                     ~^~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:124:1: note: place parentheses around the assignment to silence this warning
COMPSPDS(compspdsB,B,0,                   e       )
^
vgcomp.c:116:55: note: expanded from macro 'COMPSPDS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:124:1: note: use '==' to turn this assignment into an equality comparison
COMPSPDS(compspdsB,B,0,                   e       )
^
vgcomp.c:116:55: note: expanded from macro 'COMPSPDS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:125:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
COMPSPDS(compspdsI,I,0,                   e       )
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vgcomp.c:116:55: note: expanded from macro 'COMPSPDS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                     ~^~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:125:1: note: place parentheses around the assignment to silence this warning
COMPSPDS(compspdsI,I,0,                   e       )
^
vgcomp.c:116:55: note: expanded from macro 'COMPSPDS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:125:1: note: use '==' to turn this assignment into an equality comparison
COMPSPDS(compspdsI,I,0,                   e       )
^
vgcomp.c:116:55: note: expanded from macro 'COMPSPDS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:126:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
COMPSPDS(compspdsD,D,0,                   e       )
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vgcomp.c:116:55: note: expanded from macro 'COMPSPDS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                     ~^~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:126:1: note: place parentheses around the assignment to silence this warning
COMPSPDS(compspdsD,D,0,                   e       )
^
vgcomp.c:116:55: note: expanded from macro 'COMPSPDS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:126:1: note: use '==' to turn this assignment into an equality comparison
COMPSPDS(compspdsD,D,0,                   e       )
^
vgcomp.c:116:55: note: expanded from macro 'COMPSPDS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:127:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
COMPSPDS(compspdsZ,D,*(1+(D*)jt->compsev),i%2?e1:e)
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vgcomp.c:116:55: note: expanded from macro 'COMPSPDS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                     ~^~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:127:1: note: place parentheses around the assignment to silence this warning
COMPSPDS(compspdsZ,D,*(1+(D*)jt->compsev),i%2?e1:e)
^
vgcomp.c:116:55: note: expanded from macro 'COMPSPDS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:127:1: note: use '==' to turn this assignment into an equality comparison
COMPSPDS(compspdsZ,D,*(1+(D*)jt->compsev),i%2?e1:e)
^
vgcomp.c:116:55: note: expanded from macro 'COMPSPDS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:129:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
COMPSPSS(compspssB,B,0,                   e       )
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vgcomp.c:94:55: note: expanded from macro 'COMPSPSS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                     ~^~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:129:1: note: place parentheses around the assignment to silence this warning
COMPSPSS(compspssB,B,0,                   e       )
^
vgcomp.c:94:55: note: expanded from macro 'COMPSPSS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:129:1: note: use '==' to turn this assignment into an equality comparison
COMPSPSS(compspssB,B,0,                   e       )
^
vgcomp.c:94:55: note: expanded from macro 'COMPSPSS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:130:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
COMPSPSS(compspssI,I,0,                   e       )
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vgcomp.c:94:55: note: expanded from macro 'COMPSPSS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                     ~^~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:130:1: note: place parentheses around the assignment to silence this warning
COMPSPSS(compspssI,I,0,                   e       )
^
vgcomp.c:94:55: note: expanded from macro 'COMPSPSS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:130:1: note: use '==' to turn this assignment into an equality comparison
COMPSPSS(compspssI,I,0,                   e       )
^
vgcomp.c:94:55: note: expanded from macro 'COMPSPSS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:131:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
COMPSPSS(compspssD,D,0,                   e       )
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vgcomp.c:94:55: note: expanded from macro 'COMPSPSS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                     ~^~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:131:1: note: place parentheses around the assignment to silence this warning
COMPSPSS(compspssD,D,0,                   e       )
^
vgcomp.c:94:55: note: expanded from macro 'COMPSPSS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:131:1: note: use '==' to turn this assignment into an equality comparison
COMPSPSS(compspssD,D,0,                   e       )
^
vgcomp.c:94:55: note: expanded from macro 'COMPSPSS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:132:1: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
COMPSPSS(compspssZ,D,*(1+(D*)jt->compsev),i%2?e1:e)
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vgcomp.c:94:55: note: expanded from macro 'COMPSPSS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                     ~^~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:132:1: note: place parentheses around the assignment to silence this warning
COMPSPSS(compspssZ,D,*(1+(D*)jt->compsev),i%2?e1:e)
^
vgcomp.c:94:55: note: expanded from macro 'COMPSPSS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vgcomp.c:132:1: note: use '==' to turn this assignment into an equality comparison
COMPSPSS(compspssZ,D,*(1+(D*)jt->compsev),i%2?e1:e)
^
vgcomp.c:94:55: note: expanded from macro 'COMPSPSS'
    case 3: c= 0; ya=yv+yc*ia; yb=yv+yc*ib; DO(p, if(c=ya[i]-yb[i]){c=0>c?-1:1; break;});                \
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
18 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vgranking.o vgranking.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vgsort.o vgsort.c
vgsort.c:93:14: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(!p||256<p&&0.69*(p1+2*n)>n*log((D)n))R 3000<n?sorti1(m,n,n,w):irs2(gr1(w),w,0L,1L,1L,jtfrom);
      ~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~
vgsort.c:93:14: note: place parentheses around the '&&' expression to silence this warning
 if(!p||256<p&&0.69*(p1+2*n)>n*log((D)n))R 3000<n?sorti1(m,n,n,w):irs2(gr1(w),w,0L,1L,1L,jtfrom);
             ^
        (                               )
1 warning generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vgsp.o vgsp.c
vgsp.c:88:5: warning: expression result unused [-Wunused-value]
 RE(0);
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
1 warning generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vi.o vi.c
vi.c:205:8: warning: expression result unused [-Wunused-value]
static IOFX(A,jtioax1,hia(t1,AADR(d,*v)),!equ(AADR(d,*v),AADR(ad,av[hj])),++v,   --v  )  /* boxed exact 1-element item */   
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:190:41: note: expanded from macro 'IOFX'
    case ILESS:        XMV(hash,exp,inc,0      );                ZCSHAPE;    break;  \
                                        ^
vi.c:173:59: note: expanded from macro 'XMV'
 if(k==SZI){XDO(hash,exp,inc,if(m==hj){*zi++=*(I*)v;      stmt;}); zc=(C*)zi;}  \
                                                          ^
vi.c:169:89: note: expanded from macro 'XDO'
#define XDO(hash,exp,inc,stmt)     {d=wd; v=wv;          DO(cm, j=(hash)%pm; FIND(exp); stmt;             inc;);}
                                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:205:8: warning: expression result unused [-Wunused-value]
static IOFX(A,jtioax1,hia(t1,AADR(d,*v)),!equ(AADR(d,*v),AADR(ad,av[hj])),++v,   --v  )  /* boxed exact 1-element item */   
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:190:41: note: expanded from macro 'IOFX'
    case ILESS:        XMV(hash,exp,inc,0      );                ZCSHAPE;    break;  \
                                        ^
vi.c:174:59: note: expanded from macro 'XMV'
 else       XDO(hash,exp,inc,if(m==hj){MC(zc,v,k); zc+=k; stmt;});
                                                          ^
vi.c:169:89: note: expanded from macro 'XDO'
#define XDO(hash,exp,inc,stmt)     {d=wd; v=wv;          DO(cm, j=(hash)%pm; FIND(exp); stmt;             inc;);}
                                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:206:8: warning: expression result unused [-Wunused-value]
static IOFX(A,jtioau, hiau(AADR(d,*v)),  !equ(AADR(d,*v),AADR(ad,av[hj])),++v,   --v  )  /* boxed uniform type         */
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:190:41: note: expanded from macro 'IOFX'
    case ILESS:        XMV(hash,exp,inc,0      );                ZCSHAPE;    break;  \
                                        ^
vi.c:173:59: note: expanded from macro 'XMV'
 if(k==SZI){XDO(hash,exp,inc,if(m==hj){*zi++=*(I*)v;      stmt;}); zc=(C*)zi;}  \
                                                          ^
vi.c:169:89: note: expanded from macro 'XDO'
#define XDO(hash,exp,inc,stmt)     {d=wd; v=wv;          DO(cm, j=(hash)%pm; FIND(exp); stmt;             inc;);}
                                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:206:8: warning: expression result unused [-Wunused-value]
static IOFX(A,jtioau, hiau(AADR(d,*v)),  !equ(AADR(d,*v),AADR(ad,av[hj])),++v,   --v  )  /* boxed uniform type         */
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:190:41: note: expanded from macro 'IOFX'
    case ILESS:        XMV(hash,exp,inc,0      );                ZCSHAPE;    break;  \
                                        ^
vi.c:174:59: note: expanded from macro 'XMV'
 else       XDO(hash,exp,inc,if(m==hj){MC(zc,v,k); zc+=k; stmt;});
                                                          ^
vi.c:169:89: note: expanded from macro 'XDO'
#define XDO(hash,exp,inc,stmt)     {d=wd; v=wv;          DO(cm, j=(hash)%pm; FIND(exp); stmt;             inc;);}
                                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:207:8: warning: expression result unused [-Wunused-value]
static IOFX(X,jtiox,  hix(v),            !eqx(n,v,av+n*hj),               v+=cn, v-=cn)  /* extended integer           */   
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:190:41: note: expanded from macro 'IOFX'
    case ILESS:        XMV(hash,exp,inc,0      );                ZCSHAPE;    break;  \
                                        ^
vi.c:173:59: note: expanded from macro 'XMV'
 if(k==SZI){XDO(hash,exp,inc,if(m==hj){*zi++=*(I*)v;      stmt;}); zc=(C*)zi;}  \
                                                          ^
vi.c:169:89: note: expanded from macro 'XDO'
#define XDO(hash,exp,inc,stmt)     {d=wd; v=wv;          DO(cm, j=(hash)%pm; FIND(exp); stmt;             inc;);}
                                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:207:8: warning: expression result unused [-Wunused-value]
static IOFX(X,jtiox,  hix(v),            !eqx(n,v,av+n*hj),               v+=cn, v-=cn)  /* extended integer           */   
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:190:41: note: expanded from macro 'IOFX'
    case ILESS:        XMV(hash,exp,inc,0      );                ZCSHAPE;    break;  \
                                        ^
vi.c:174:59: note: expanded from macro 'XMV'
 else       XDO(hash,exp,inc,if(m==hj){MC(zc,v,k); zc+=k; stmt;});
                                                          ^
vi.c:169:89: note: expanded from macro 'XDO'
#define XDO(hash,exp,inc,stmt)     {d=wd; v=wv;          DO(cm, j=(hash)%pm; FIND(exp); stmt;             inc;);}
                                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:208:8: warning: expression result unused [-Wunused-value]
static IOFX(Q,jtioq,  hiq(v),            !eqq(n,v,av+n*hj),               v+=cn, v-=cn)  /* rational number            */   
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:190:41: note: expanded from macro 'IOFX'
    case ILESS:        XMV(hash,exp,inc,0      );                ZCSHAPE;    break;  \
                                        ^
vi.c:173:59: note: expanded from macro 'XMV'
 if(k==SZI){XDO(hash,exp,inc,if(m==hj){*zi++=*(I*)v;      stmt;}); zc=(C*)zi;}  \
                                                          ^
vi.c:169:89: note: expanded from macro 'XDO'
#define XDO(hash,exp,inc,stmt)     {d=wd; v=wv;          DO(cm, j=(hash)%pm; FIND(exp); stmt;             inc;);}
                                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:208:8: warning: expression result unused [-Wunused-value]
static IOFX(Q,jtioq,  hiq(v),            !eqq(n,v,av+n*hj),               v+=cn, v-=cn)  /* rational number            */   
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:190:41: note: expanded from macro 'IOFX'
    case ILESS:        XMV(hash,exp,inc,0      );                ZCSHAPE;    break;  \
                                        ^
vi.c:174:59: note: expanded from macro 'XMV'
 else       XDO(hash,exp,inc,if(m==hj){MC(zc,v,k); zc+=k; stmt;});
                                                          ^
vi.c:169:89: note: expanded from macro 'XDO'
#define XDO(hash,exp,inc,stmt)     {d=wd; v=wv;          DO(cm, j=(hash)%pm; FIND(exp); stmt;             inc;);}
                                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:209:8: warning: expression result unused [-Wunused-value]
static IOFX(C,jtioc,  hic(k,(UC*)v),     memcmp(v,av+k*hj,k),             v+=cn, v-=cn)  /* boolean, char, or integer  */
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:190:41: note: expanded from macro 'IOFX'
    case ILESS:        XMV(hash,exp,inc,0      );                ZCSHAPE;    break;  \
                                        ^
vi.c:173:59: note: expanded from macro 'XMV'
 if(k==SZI){XDO(hash,exp,inc,if(m==hj){*zi++=*(I*)v;      stmt;}); zc=(C*)zi;}  \
                                                          ^
vi.c:169:89: note: expanded from macro 'XDO'
#define XDO(hash,exp,inc,stmt)     {d=wd; v=wv;          DO(cm, j=(hash)%pm; FIND(exp); stmt;             inc;);}
                                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:209:8: warning: expression result unused [-Wunused-value]
static IOFX(C,jtioc,  hic(k,(UC*)v),     memcmp(v,av+k*hj,k),             v+=cn, v-=cn)  /* boolean, char, or integer  */
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:190:41: note: expanded from macro 'IOFX'
    case ILESS:        XMV(hash,exp,inc,0      );                ZCSHAPE;    break;  \
                                        ^
vi.c:174:59: note: expanded from macro 'XMV'
 else       XDO(hash,exp,inc,if(m==hj){MC(zc,v,k); zc+=k; stmt;});
                                                          ^
vi.c:169:89: note: expanded from macro 'XDO'
#define XDO(hash,exp,inc,stmt)     {d=wd; v=wv;          DO(cm, j=(hash)%pm; FIND(exp); stmt;             inc;);}
                                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:210:8: warning: expression result unused [-Wunused-value]
static IOFX(C,jtiocx, hicx(jt,k,(UC*)v), memcmp(v,av+k*hj,k),             v+=cn, v-=cn)  /* boolean, char, or integer  */
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:190:41: note: expanded from macro 'IOFX'
    case ILESS:        XMV(hash,exp,inc,0      );                ZCSHAPE;    break;  \
                                        ^
vi.c:173:59: note: expanded from macro 'XMV'
 if(k==SZI){XDO(hash,exp,inc,if(m==hj){*zi++=*(I*)v;      stmt;}); zc=(C*)zi;}  \
                                                          ^
vi.c:169:89: note: expanded from macro 'XDO'
#define XDO(hash,exp,inc,stmt)     {d=wd; v=wv;          DO(cm, j=(hash)%pm; FIND(exp); stmt;             inc;);}
                                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:210:8: warning: expression result unused [-Wunused-value]
static IOFX(C,jtiocx, hicx(jt,k,(UC*)v), memcmp(v,av+k*hj,k),             v+=cn, v-=cn)  /* boolean, char, or integer  */
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:190:41: note: expanded from macro 'IOFX'
    case ILESS:        XMV(hash,exp,inc,0      );                ZCSHAPE;    break;  \
                                        ^
vi.c:174:59: note: expanded from macro 'XMV'
 else       XDO(hash,exp,inc,if(m==hj){MC(zc,v,k); zc+=k; stmt;});
                                                          ^
vi.c:169:89: note: expanded from macro 'XDO'
#define XDO(hash,exp,inc,stmt)     {d=wd; v=wv;          DO(cm, j=(hash)%pm; FIND(exp); stmt;             inc;);}
                                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:211:8: warning: expression result unused [-Wunused-value]
static IOFX(I,jtioi,  hicw(v),           *v!=av[hj],                      ++v,   --v  )
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:190:41: note: expanded from macro 'IOFX'
    case ILESS:        XMV(hash,exp,inc,0      );                ZCSHAPE;    break;  \
                                        ^
vi.c:173:59: note: expanded from macro 'XMV'
 if(k==SZI){XDO(hash,exp,inc,if(m==hj){*zi++=*(I*)v;      stmt;}); zc=(C*)zi;}  \
                                                          ^
vi.c:169:89: note: expanded from macro 'XDO'
#define XDO(hash,exp,inc,stmt)     {d=wd; v=wv;          DO(cm, j=(hash)%pm; FIND(exp); stmt;             inc;);}
                                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:211:8: warning: expression result unused [-Wunused-value]
static IOFX(I,jtioi,  hicw(v),           *v!=av[hj],                      ++v,   --v  )
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:190:41: note: expanded from macro 'IOFX'
    case ILESS:        XMV(hash,exp,inc,0      );                ZCSHAPE;    break;  \
                                        ^
vi.c:174:59: note: expanded from macro 'XMV'
 else       XDO(hash,exp,inc,if(m==hj){MC(zc,v,k); zc+=k; stmt;});
                                                          ^
vi.c:169:89: note: expanded from macro 'XDO'
#define XDO(hash,exp,inc,stmt)     {d=wd; v=wv;          DO(cm, j=(hash)%pm; FIND(exp); stmt;             inc;);}
                                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:355:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
static IOFSMALLRANGE(jtio1,UC,SCOZ, SCOW, SCOW, SCOWX,SCQW, SCQW )  /* 1-byte    items */
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:336:49: note: expanded from macro 'IOFSMALLRANGE'
    case INUBSV:  memset(hv,C1,p); SDOW(if(*zb++=hb[x=*u++])hb[x]=0);                   break;  \
                                           ~~~~~^~~~~~~~~~~
vi.c:311:41: note: expanded from macro 'SDOW'
#define SDOW(stmt)      {u=wv;   DO(cm, stmt;);}
                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:355:8: note: place parentheses around the assignment to silence this warning
static IOFSMALLRANGE(jtio1,UC,SCOZ, SCOW, SCOW, SCOWX,SCQW, SCQW )  /* 1-byte    items */
       ^
vi.c:336:49: note: expanded from macro 'IOFSMALLRANGE'
    case INUBSV:  memset(hv,C1,p); SDOW(if(*zb++=hb[x=*u++])hb[x]=0);                   break;  \
                                                ^
vi.c:311:41: note: expanded from macro 'SDOW'
#define SDOW(stmt)      {u=wv;   DO(cm, stmt;);}
                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:355:8: note: use '==' to turn this assignment into an equality comparison
static IOFSMALLRANGE(jtio1,UC,SCOZ, SCOW, SCOW, SCOWX,SCQW, SCQW )  /* 1-byte    items */
       ^
vi.c:336:49: note: expanded from macro 'IOFSMALLRANGE'
    case INUBSV:  memset(hv,C1,p); SDOW(if(*zb++=hb[x=*u++])hb[x]=0);                   break;  \
                                                ^
vi.c:311:41: note: expanded from macro 'SDOW'
#define SDOW(stmt)      {u=wv;   DO(cm, stmt;);}
                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:356:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
static IOFSMALLRANGE(jtio2,US,SCOZ, SCOW, SCOW, SCOWX,SCQW, SCQW )  /* 2-byte    items */
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:336:49: note: expanded from macro 'IOFSMALLRANGE'
    case INUBSV:  memset(hv,C1,p); SDOW(if(*zb++=hb[x=*u++])hb[x]=0);                   break;  \
                                           ~~~~~^~~~~~~~~~~
vi.c:311:41: note: expanded from macro 'SDOW'
#define SDOW(stmt)      {u=wv;   DO(cm, stmt;);}
                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:356:8: note: place parentheses around the assignment to silence this warning
static IOFSMALLRANGE(jtio2,US,SCOZ, SCOW, SCOW, SCOWX,SCQW, SCQW )  /* 2-byte    items */
       ^
vi.c:336:49: note: expanded from macro 'IOFSMALLRANGE'
    case INUBSV:  memset(hv,C1,p); SDOW(if(*zb++=hb[x=*u++])hb[x]=0);                   break;  \
                                                ^
vi.c:311:41: note: expanded from macro 'SDOW'
#define SDOW(stmt)      {u=wv;   DO(cm, stmt;);}
                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:356:8: note: use '==' to turn this assignment into an equality comparison
static IOFSMALLRANGE(jtio2,US,SCOZ, SCOW, SCOW, SCOWX,SCQW, SCQW )  /* 2-byte    items */
       ^
vi.c:336:49: note: expanded from macro 'IOFSMALLRANGE'
    case INUBSV:  memset(hv,C1,p); SDOW(if(*zb++=hb[x=*u++])hb[x]=0);                   break;  \
                                                ^
vi.c:311:41: note: expanded from macro 'SDOW'
#define SDOW(stmt)      {u=wv;   DO(cm, stmt;);}
                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:357:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
static IOFSMALLRANGE(jtio4,I ,SCOZ1,SCOW0,SCOW1,SCOW0,SCQW0,SCQW1)  /* word size items */
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:336:49: note: expanded from macro 'IOFSMALLRANGE'
    case INUBSV:  memset(hv,C1,p); SDOW(if(*zb++=hb[x=*u++])hb[x]=0);                   break;  \
                                           ~~~~~^~~~~~~~~~~
vi.c:311:41: note: expanded from macro 'SDOW'
#define SDOW(stmt)      {u=wv;   DO(cm, stmt;);}
                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:357:8: note: place parentheses around the assignment to silence this warning
static IOFSMALLRANGE(jtio4,I ,SCOZ1,SCOW0,SCOW1,SCOW0,SCQW0,SCQW1)  /* word size items */
       ^
vi.c:336:49: note: expanded from macro 'IOFSMALLRANGE'
    case INUBSV:  memset(hv,C1,p); SDOW(if(*zb++=hb[x=*u++])hb[x]=0);                   break;  \
                                                ^
vi.c:311:41: note: expanded from macro 'SDOW'
#define SDOW(stmt)      {u=wv;   DO(cm, stmt;);}
                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:357:8: note: use '==' to turn this assignment into an equality comparison
static IOFSMALLRANGE(jtio4,I ,SCOZ1,SCOW0,SCOW1,SCOW0,SCQW0,SCQW1)  /* word size items */
       ^
vi.c:336:49: note: expanded from macro 'IOFSMALLRANGE'
    case INUBSV:  memset(hv,C1,p); SDOW(if(*zb++=hb[x=*u++])hb[x]=0);                   break;  \
                                                ^
vi.c:311:41: note: expanded from macro 'SDOW'
#define SDOW(stmt)      {u=wv;   DO(cm, stmt;);}
                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:446:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   case IIDOT:        BSLOOPAW(*zv++=-2==q?hu[j]:m);                       break;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
             ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:446:23: note: place parentheses around the assignment to silence this warning
   case IIDOT:        BSLOOPAW(*zv++=-2==q?hu[j]:m);                       break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:446:23: note: use '==' to turn this assignment into an equality comparison
   case IIDOT:        BSLOOPAW(*zv++=-2==q?hu[j]:m);                       break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:447:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   case IICO:         BSLOOPAW(*zv++=-2==q?hu[j]:m);                       break;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
             ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:447:23: note: place parentheses around the assignment to silence this warning
   case IICO:         BSLOOPAW(*zv++=-2==q?hu[j]:m);                       break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:447:23: note: use '==' to turn this assignment into an equality comparison
   case IICO:         BSLOOPAW(*zv++=-2==q?hu[j]:m);                       break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:448:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   case IEPS:         BSLOOPAW(*zb++=-2==q);                               break;
                      ^~~~~~~~~~~~~~~~~~~~~
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
             ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:448:23: note: place parentheses around the assignment to silence this warning
   case IEPS:         BSLOOPAW(*zb++=-2==q);                               break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:448:23: note: use '==' to turn this assignment into an equality comparison
   case IEPS:         BSLOOPAW(*zb++=-2==q);                               break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:449:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   case ILESS:        BSLOOPAW(if(-2< q){MC(zc,u,k); zc+=k;}); ZCSHAPE;    break;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
             ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:449:23: note: place parentheses around the assignment to silence this warning
   case ILESS:        BSLOOPAW(if(-2< q){MC(zc,u,k); zc+=k;}); ZCSHAPE;    break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:449:23: note: use '==' to turn this assignment into an equality comparison
   case ILESS:        BSLOOPAW(if(-2< q){MC(zc,u,k); zc+=k;}); ZCSHAPE;    break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:450:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   case II0EPS:  s=m; BSLOOPAW(if(-2< q){s=i; break;});        *zi++=s;    break;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
             ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:450:23: note: place parentheses around the assignment to silence this warning
   case II0EPS:  s=m; BSLOOPAW(if(-2< q){s=i; break;});        *zi++=s;    break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:450:23: note: use '==' to turn this assignment into an equality comparison
   case II0EPS:  s=m; BSLOOPAW(if(-2< q){s=i; break;});        *zi++=s;    break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:451:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   case IJ0EPS:  s=m; BSLOOQAW(if(-2< q){s=i; break;});        *zi++=s;    break;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:424:29: note: expanded from macro 'BSLOOQAW'
#define BSLOOQAW(zstmt)     BSLOOPAWX(c-1,i>=0,--i,u-=n,zstmt)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
             ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:451:23: note: place parentheses around the assignment to silence this warning
   case IJ0EPS:  s=m; BSLOOQAW(if(-2< q){s=i; break;});        *zi++=s;    break;
                      ^
vi.c:424:29: note: expanded from macro 'BSLOOQAW'
#define BSLOOQAW(zstmt)     BSLOOPAWX(c-1,i>=0,--i,u-=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:451:23: note: use '==' to turn this assignment into an equality comparison
   case IJ0EPS:  s=m; BSLOOQAW(if(-2< q){s=i; break;});        *zi++=s;    break;
                      ^
vi.c:424:29: note: expanded from macro 'BSLOOQAW'
#define BSLOOQAW(zstmt)     BSLOOPAWX(c-1,i>=0,--i,u-=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:452:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   case II1EPS:  s=m; BSLOOPAW(if(-2==q){s=i; break;});        *zi++=s;    break;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
             ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:452:23: note: place parentheses around the assignment to silence this warning
   case II1EPS:  s=m; BSLOOPAW(if(-2==q){s=i; break;});        *zi++=s;    break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:452:23: note: use '==' to turn this assignment into an equality comparison
   case II1EPS:  s=m; BSLOOPAW(if(-2==q){s=i; break;});        *zi++=s;    break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:453:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   case IJ1EPS:  s=m; BSLOOQAW(if(-2==q){s=i; break;});        *zi++=s;    break;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:424:29: note: expanded from macro 'BSLOOQAW'
#define BSLOOQAW(zstmt)     BSLOOPAWX(c-1,i>=0,--i,u-=n,zstmt)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
             ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:453:23: note: place parentheses around the assignment to silence this warning
   case IJ1EPS:  s=m; BSLOOQAW(if(-2==q){s=i; break;});        *zi++=s;    break;
                      ^
vi.c:424:29: note: expanded from macro 'BSLOOQAW'
#define BSLOOQAW(zstmt)     BSLOOPAWX(c-1,i>=0,--i,u-=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:453:23: note: use '==' to turn this assignment into an equality comparison
   case IJ1EPS:  s=m; BSLOOQAW(if(-2==q){s=i; break;});        *zi++=s;    break;
                      ^
vi.c:424:29: note: expanded from macro 'BSLOOQAW'
#define BSLOOQAW(zstmt)     BSLOOPAWX(c-1,i>=0,--i,u-=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:454:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   case IANYEPS: s=0; BSLOOPAW(if(-2==q){s=1; break;});        *zb++=1&&s; break;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
             ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:454:23: note: place parentheses around the assignment to silence this warning
   case IANYEPS: s=0; BSLOOPAW(if(-2==q){s=1; break;});        *zb++=1&&s; break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:454:23: note: use '==' to turn this assignment into an equality comparison
   case IANYEPS: s=0; BSLOOPAW(if(-2==q){s=1; break;});        *zb++=1&&s; break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:455:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   case IALLEPS: s=1; BSLOOPAW(if(-2< q){s=0; break;});        *zb++=1&&s; break;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
             ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:455:23: note: place parentheses around the assignment to silence this warning
   case IALLEPS: s=1; BSLOOPAW(if(-2< q){s=0; break;});        *zb++=1&&s; break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:455:23: note: use '==' to turn this assignment into an equality comparison
   case IALLEPS: s=1; BSLOOPAW(if(-2< q){s=0; break;});        *zb++=1&&s; break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:456:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   case ISUMEPS: s=0; BSLOOPAW(if(-2==q)++s);                  *zi++=s;    break;
                      ^~~~~~~~~~~~~~~~~~~~~~
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
             ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:456:23: note: place parentheses around the assignment to silence this warning
   case ISUMEPS: s=0; BSLOOPAW(if(-2==q)++s);                  *zi++=s;    break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:456:23: note: use '==' to turn this assignment into an equality comparison
   case ISUMEPS: s=0; BSLOOPAW(if(-2==q)++s);                  *zi++=s;    break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:457:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   case IIFBEPS:      BSLOOPAW(if(-2==q)*zi++=i);              ZISHAPE;    break;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
             ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:457:23: note: place parentheses around the assignment to silence this warning
   case IIFBEPS:      BSLOOPAW(if(-2==q)*zi++=i);              ZISHAPE;    break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:457:23: note: use '==' to turn this assignment into an equality comparison
   case IIFBEPS:      BSLOOPAW(if(-2==q)*zi++=i);              ZISHAPE;    break;
                      ^
vi.c:423:29: note: expanded from macro 'BSLOOPAW'
#define BSLOOPAW(zstmt)     BSLOOPAWX(0  ,i< c,++i,u+=n,zstmt)
                            ^
vi.c:417:15: note: expanded from macro 'BSLOOPAWX'
    DO(n, if(t=compare(AADR(wd,u[i]),AADR(ad,v[i])))break;);  \
              ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vi.c:526:19: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(!(mk||m&&n&&zn&&th))switch(mode){
        ~~~~~~~~~~^~~~
vi.c:526:19: note: place parentheses around the '&&' expression to silence this warning
 if(!(mk||m&&n&&zn&&th))switch(mode){
                  ^
          (           )
30 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o viix.o viix.c
viix.c:109:14: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case XNUM: COMPVLOOF(X, c, xcompare); break;
             ^~~~~~~~~~~~~~~~~~~~~~~~~
viix.c:50:36: note: expanded from macro 'COMPVLOOF'
 {T*u=(T*)uu,*v=(T*)vv; DO(c, if(cc=COMP(*u,*v))break;          ++u; ++v;);}
                                 ~~^~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
viix.c:109:14: note: place parentheses around the assignment to silence this warning
  case XNUM: COMPVLOOF(X, c, xcompare); break;
             ^
viix.c:50:36: note: expanded from macro 'COMPVLOOF'
 {T*u=(T*)uu,*v=(T*)vv; DO(c, if(cc=COMP(*u,*v))break;          ++u; ++v;);}
                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
viix.c:109:14: note: use '==' to turn this assignment into an equality comparison
  case XNUM: COMPVLOOF(X, c, xcompare); break;
             ^
viix.c:50:36: note: expanded from macro 'COMPVLOOF'
 {T*u=(T*)uu,*v=(T*)vv; DO(c, if(cc=COMP(*u,*v))break;          ++u; ++v;);}
                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
viix.c:110:14: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case RAT:  COMPVLOOF(Q, c, qcompare); break;
             ^~~~~~~~~~~~~~~~~~~~~~~~~
viix.c:50:36: note: expanded from macro 'COMPVLOOF'
 {T*u=(T*)uu,*v=(T*)vv; DO(c, if(cc=COMP(*u,*v))break;          ++u; ++v;);}
                                 ~~^~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
viix.c:110:14: note: place parentheses around the assignment to silence this warning
  case RAT:  COMPVLOOF(Q, c, qcompare); break;
             ^
viix.c:50:36: note: expanded from macro 'COMPVLOOF'
 {T*u=(T*)uu,*v=(T*)vv; DO(c, if(cc=COMP(*u,*v))break;          ++u; ++v;);}
                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
viix.c:110:14: note: use '==' to turn this assignment into an equality comparison
  case RAT:  COMPVLOOF(Q, c, qcompare); break;
             ^
viix.c:50:36: note: expanded from macro 'COMPVLOOF'
 {T*u=(T*)uu,*v=(T*)vv; DO(c, if(cc=COMP(*u,*v))break;          ++u; ++v;);}
                                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
viix.c:114:15: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   DO(c, if(cc=compare(AVR(i),AVR(i+c*(n-1))))break;);
            ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
viix.c:114:15: note: place parentheses around the assignment to silence this warning
   DO(c, if(cc=compare(AVR(i),AVR(i+c*(n-1))))break;);
              ^
            (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
viix.c:114:15: note: use '==' to turn this assignment into an equality comparison
   DO(c, if(cc=compare(AVR(i),AVR(i+c*(n-1))))break;);
              ^
              ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
viix.c:136:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case TT(XNUM,XNUM): BSLOOF(X, X, xcompare); break;
                      ^~~~~~~~~~~~~~~~~~~~~~
viix.c:77:28: note: expanded from macro 'BSLOOF'
  else     DO(m, BSLOOPN(cc=COMP(x,y),b=gt==cc); *zv++=1+q; wv+=c;);  \
                         ~~^~~~~~~~~~
viix.c:60:73: note: expanded from macro 'BSLOOPN'
  while(p<=q){MID(k,p,q); u=av+c*k; v=wv; b=1; DO(c, x=*u++; y=*v++; if(NE){CMP; break;});  \
                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
viix.c:136:23: note: place parentheses around the assignment to silence this warning
  case TT(XNUM,XNUM): BSLOOF(X, X, xcompare); break;
                      ^
viix.c:77:28: note: expanded from macro 'BSLOOF'
  else     DO(m, BSLOOPN(cc=COMP(x,y),b=gt==cc); *zv++=1+q; wv+=c;);  \
                           ^
viix.c:60:73: note: expanded from macro 'BSLOOPN'
  while(p<=q){MID(k,p,q); u=av+c*k; v=wv; b=1; DO(c, x=*u++; y=*v++; if(NE){CMP; break;});  \
                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
viix.c:136:23: note: use '==' to turn this assignment into an equality comparison
  case TT(XNUM,XNUM): BSLOOF(X, X, xcompare); break;
                      ^
viix.c:77:28: note: expanded from macro 'BSLOOF'
  else     DO(m, BSLOOPN(cc=COMP(x,y),b=gt==cc); *zv++=1+q; wv+=c;);  \
                           ^
viix.c:60:73: note: expanded from macro 'BSLOOPN'
  while(p<=q){MID(k,p,q); u=av+c*k; v=wv; b=1; DO(c, x=*u++; y=*v++; if(NE){CMP; break;});  \
                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
viix.c:137:23: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  case TT(RAT, RAT ): BSLOOF(Q, Q, qcompare); break;
                      ^~~~~~~~~~~~~~~~~~~~~~
viix.c:77:28: note: expanded from macro 'BSLOOF'
  else     DO(m, BSLOOPN(cc=COMP(x,y),b=gt==cc); *zv++=1+q; wv+=c;);  \
                         ~~^~~~~~~~~~
viix.c:60:73: note: expanded from macro 'BSLOOPN'
  while(p<=q){MID(k,p,q); u=av+c*k; v=wv; b=1; DO(c, x=*u++; y=*v++; if(NE){CMP; break;});  \
                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
viix.c:137:23: note: place parentheses around the assignment to silence this warning
  case TT(RAT, RAT ): BSLOOF(Q, Q, qcompare); break;
                      ^
viix.c:77:28: note: expanded from macro 'BSLOOF'
  else     DO(m, BSLOOPN(cc=COMP(x,y),b=gt==cc); *zv++=1+q; wv+=c;);  \
                           ^
viix.c:60:73: note: expanded from macro 'BSLOOPN'
  while(p<=q){MID(k,p,q); u=av+c*k; v=wv; b=1; DO(c, x=*u++; y=*v++; if(NE){CMP; break;});  \
                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
viix.c:137:23: note: use '==' to turn this assignment into an equality comparison
  case TT(RAT, RAT ): BSLOOF(Q, Q, qcompare); break;
                      ^
viix.c:77:28: note: expanded from macro 'BSLOOF'
  else     DO(m, BSLOOPN(cc=COMP(x,y),b=gt==cc); *zv++=1+q; wv+=c;);  \
                           ^
viix.c:60:73: note: expanded from macro 'BSLOOPN'
  while(p<=q){MID(k,p,q); u=av+c*k; v=wv; b=1; DO(c, x=*u++; y=*v++; if(NE){CMP; break;});  \
                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
viix.c:143:17: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
     DO(c, if(cc=compare(AVR(i+ck),WVR(i+j))){b=gt==cc; break;});
              ~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
viix.c:143:17: note: place parentheses around the assignment to silence this warning
     DO(c, if(cc=compare(AVR(i+ck),WVR(i+j))){b=gt==cc; break;});
                ^
              (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
viix.c:143:17: note: use '==' to turn this assignment into an equality comparison
     DO(c, if(cc=compare(AVR(i+ck),WVR(i+j))){b=gt==cc; break;});
                ^
                ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
viix.c:156:16: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
    case XNUM: BSLOOF(X,X, xcompare); break;
               ^~~~~~~~~~~~~~~~~~~~~
viix.c:77:28: note: expanded from macro 'BSLOOF'
  else     DO(m, BSLOOPN(cc=COMP(x,y),b=gt==cc); *zv++=1+q; wv+=c;);  \
                         ~~^~~~~~~~~~
viix.c:60:73: note: expanded from macro 'BSLOOPN'
  while(p<=q){MID(k,p,q); u=av+c*k; v=wv; b=1; DO(c, x=*u++; y=*v++; if(NE){CMP; break;});  \
                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
viix.c:156:16: note: place parentheses around the assignment to silence this warning
    case XNUM: BSLOOF(X,X, xcompare); break;
               ^
viix.c:77:28: note: expanded from macro 'BSLOOF'
  else     DO(m, BSLOOPN(cc=COMP(x,y),b=gt==cc); *zv++=1+q; wv+=c;);  \
                           ^
viix.c:60:73: note: expanded from macro 'BSLOOPN'
  while(p<=q){MID(k,p,q); u=av+c*k; v=wv; b=1; DO(c, x=*u++; y=*v++; if(NE){CMP; break;});  \
                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
viix.c:156:16: note: use '==' to turn this assignment into an equality comparison
    case XNUM: BSLOOF(X,X, xcompare); break;
               ^
viix.c:77:28: note: expanded from macro 'BSLOOF'
  else     DO(m, BSLOOPN(cc=COMP(x,y),b=gt==cc); *zv++=1+q; wv+=c;);  \
                           ^
viix.c:60:73: note: expanded from macro 'BSLOOPN'
  while(p<=q){MID(k,p,q); u=av+c*k; v=wv; b=1; DO(c, x=*u++; y=*v++; if(NE){CMP; break;});  \
                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
viix.c:157:16: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
    case RAT:  BSLOOF(Q,Q, qcompare); break;
               ^~~~~~~~~~~~~~~~~~~~~
viix.c:77:28: note: expanded from macro 'BSLOOF'
  else     DO(m, BSLOOPN(cc=COMP(x,y),b=gt==cc); *zv++=1+q; wv+=c;);  \
                         ~~^~~~~~~~~~
viix.c:60:73: note: expanded from macro 'BSLOOPN'
  while(p<=q){MID(k,p,q); u=av+c*k; v=wv; b=1; DO(c, x=*u++; y=*v++; if(NE){CMP; break;});  \
                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
viix.c:157:16: note: place parentheses around the assignment to silence this warning
    case RAT:  BSLOOF(Q,Q, qcompare); break;
               ^
viix.c:77:28: note: expanded from macro 'BSLOOF'
  else     DO(m, BSLOOPN(cc=COMP(x,y),b=gt==cc); *zv++=1+q; wv+=c;);  \
                           ^
viix.c:60:73: note: expanded from macro 'BSLOOPN'
  while(p<=q){MID(k,p,q); u=av+c*k; v=wv; b=1; DO(c, x=*u++; y=*v++; if(NE){CMP; break;});  \
                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
viix.c:157:16: note: use '==' to turn this assignment into an equality comparison
    case RAT:  BSLOOF(Q,Q, qcompare); break;
               ^
viix.c:77:28: note: expanded from macro 'BSLOOF'
  else     DO(m, BSLOOPN(cc=COMP(x,y),b=gt==cc); *zv++=1+q; wv+=c;);  \
                           ^
viix.c:60:73: note: expanded from macro 'BSLOOPN'
  while(p<=q){MID(k,p,q); u=av+c*k; v=wv; b=1; DO(c, x=*u++; y=*v++; if(NE){CMP; break;});  \
                                                                        ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./j.h:218:55: note: expanded from macro 'DO'
8 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o visp.o visp.c
visp.c:25:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(h=HOMO(at,wt))t=maxtype(at,wt);
    ~^~~~~~~~~~~~
visp.c:25:6: note: place parentheses around the assignment to silence this warning
 if(h=HOMO(at,wt))t=maxtype(at,wt);
     ^
    (            )
visp.c:25:6: note: use '==' to turn this assignment into an equality comparison
 if(h=HOMO(at,wt))t=maxtype(at,wt);
     ^
     ==
visp.c:57:33: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 at=DTYPE(AT(a)); wt=AT(w); if(h=HOMO(at,wt))t=maxtype(at,wt);
                               ~^~~~~~~~~~~~
visp.c:57:33: note: place parentheses around the assignment to silence this warning
 at=DTYPE(AT(a)); wt=AT(w); if(h=HOMO(at,wt))t=maxtype(at,wt);
                                ^
                               (            )
visp.c:57:33: note: use '==' to turn this assignment into an equality comparison
 at=DTYPE(AT(a)); wt=AT(w); if(h=HOMO(at,wt))t=maxtype(at,wt);
                                ^
                                ==
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vm.o vm.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vo.o vo.c
vo.c:45:19: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 b=0; DO(r-p, if(b=1<s[i])break;);
                 ~^~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vo.c:45:19: note: place parentheses around the assignment to silence this warning
 b=0; DO(r-p, if(b=1<s[i])break;);
                  ^
                 (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vo.c:45:19: note: use '==' to turn this assignment into an equality comparison
 b=0; DO(r-p, if(b=1<s[i])break;);
                  ^
                  ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vo.c:177:7: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(j=r-yr){DO(j,v1[i]=1;); ICPY(j+v1,ys,yr); RZ(y=reshape(h1,y));}
     ~^~~~~
vo.c:177:7: note: place parentheses around the assignment to silence this warning
  if(j=r-yr){DO(j,v1[i]=1;); ICPY(j+v1,ys,yr); RZ(y=reshape(h1,y));}
      ^
     (     )
vo.c:177:7: note: use '==' to turn this assignment into an equality comparison
  if(j=r-yr){DO(j,v1[i]=1;); ICPY(j+v1,ys,yr); RZ(y=reshape(h1,y));}
      ^
      ==
vo.c:240:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(b=NUMERIC&AT(a)&&1==AR(a)&&BOX&AT(w)&&!ARELATIVE(w)&&1==AR(w)&&1<wn&&an>10*wn){
    ~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
vo.c:240:6: note: place parentheses around the assignment to silence this warning
 if(b=NUMERIC&AT(a)&&1==AR(a)&&BOX&AT(w)&&!ARELATIVE(w)&&1==AR(w)&&1<wn&&an>10*wn){
     ^
    (                                                                            )
vo.c:240:6: note: use '==' to turn this assignment into an equality comparison
 if(b=NUMERIC&AT(a)&&1==AR(a)&&BOX&AT(w)&&!ARELATIVE(w)&&1==AR(w)&&1<wn&&an>10*wn){
     ^
     ==
3 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vp.o vp.c
vp.c:25:5: warning: expression result unused [-Wunused-value]
 RE(n); RZ(w);
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
vp.c:43:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(c=1&&INT&AT(w)){
    ~^~~~~~~~~~~~~
vp.c:43:6: note: place parentheses around the assignment to silence this warning
 if(c=1&&INT&AT(w)){
     ^
    (             )
vp.c:43:6: note: use '==' to turn this assignment into an equality comparison
 if(c=1&&INT&AT(w)){
     ^
     ==
vp.c:65:5: warning: expression result unused [-Wunused-value]
 RE(n); RZ(w);
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
vp.c:117:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(n=s[r-1])DO(AN(w)/n, j=n-1; ++x; DO(n-1, k=0; DO(j--, k+=*x>x[i];); *x++=k;););
    ~^~~~~~~
vp.c:117:6: note: place parentheses around the assignment to silence this warning
 if(n=s[r-1])DO(AN(w)/n, j=n-1; ++x; DO(n-1, k=0; DO(j--, k+=*x>x[i];); *x++=k;););
     ^
    (       )
vp.c:117:6: note: use '==' to turn this assignment into an equality comparison
 if(n=s[r-1])DO(AN(w)/n, j=n-1; ++x; DO(n-1, k=0; DO(j--, k+=*x>x[i];); *x++=k;););
     ^
     ==
4 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vq.o vq.c
vq.c:71:6: warning: expression result unused [-Wunused-value]
 QRE(1);
     ^
./vq.h:11:30: note: expanded from macro 'QRE'
#define QRE(exp)        {if((exp),jt->jerr)R zeroQ;}
                             ^
1 warning generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vrand.o vrand.c
vrand.c:328:42: warning: passing 'UI *' (aka 'unsigned long *') to parameter of type 'I *' (aka 'long *') converts between pointers to integer types with different sign [-Wpointer-sign]
static void jtdx_init(J jt,UI s){lcg(DXN,jt->rngv,s); jt->rngi=0;} 
                                         ^~~~~~~~
vrand.c:45:23: note: passing argument to parameter 'v' here
static void lcg(I n,I*v,I seed){D c=16807.0,p=2147483647.0,x=(D)seed;
                      ^
vrand.c:474:39: warning: assigning to 'UI *' (aka 'unsigned long *') from 'I *' (aka 'long *') converts between pointers to integer types with different sign [-Wpointer-sign]
  GA(x,t,n,1,0); ra(x); vv[i]=jt->rngv=AV(x);
                                      ^~~~~~
vrand.c:508:46: warning: assigning to 'UI *' (aka 'unsigned long *') from 'I *' (aka 'long *') converts between pointers to integer types with different sign [-Wpointer-sign]
   u=(D*)jt->rngV0[MRI]; GA(x,INT,MRN,1,0); v=AV(x); DO(MRN, v[i]=(UI)u[i];);
                                             ^~~~~~
vrand.c:518:54: warning: assigning to 'UI *' (aka 'unsigned long *') from 'I *' (aka 'long *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case MRI: n=MRN; u=(D*)jt->rngv; GA(x,INT,n,1,0); v=AV(x); DO(n, v[i]=(UI)u[i];);
                                                     ^~~~~~
vrand.c:527:17: warning: assigning to 'UI *' (aka 'unsigned long *') from 'I *' (aka 'long *') converts between pointers to integer types with different sign [-Wpointer-sign]
 RZ(x=vi(x)); xv=AV(x);
                ^~~~~~
vrand.c:567:3: warning: passing 'I *' (aka 'long *') to parameter of type 'UI *' (aka 'unsigned long *') converts between pointers to integer types with different sign [-Wpointer-sign]
  mt_init_by_array(AV(w),AN(w));
  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
./ja.h:613:59: note: expanded from macro 'mt_init_by_array'
#define mt_init_by_array(x,y)       jtmt_init_by_array(jt,(x),(y))
                                                          ^~~
vrand.c:204:40: note: passing argument to parameter 'init_key' here
static void jtmt_init_by_array(J jt,UI init_key[], I key_length){I i,j,k;UI*mt=jt->rngv;
                                       ^
vrand.c:608:37: warning: while loop has empty body [-Wempty-body]
    case 3: DO(q, while(s<=(t=NEXT)); DO(p, *u++=mk&t; t>>=k;););
                                    ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vrand.c:608:37: note: put the semicolon on a separate line to silence this warning
    case 3: DO(q, while(s<=(t=NEXT)); DO(p, *u++=mk&t; t>>=k;););
                                    ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vrand.c:765:47: warning: assigning to 'UI *' (aka 'unsigned long *') from 'I *' (aka 'long *') converts between pointers to integer types with different sign [-Wpointer-sign]
F1(jtrollx  ){FXSDECL; RZ(w);                 FXSDO; z=roll(w);         FXSOD; R z;}       
                                              ^~~~~
vrand.c:761:76: note: expanded from macro 'FXSDO'
                     if(!jt->rngfxsv){GA(z,INT,GBN,1,0); ra(z); jt->rngfxsv=AV(z);}  \
                                                                           ^~~~~~
vrand.c:766:47: warning: assigning to 'UI *' (aka 'unsigned long *') from 'I *' (aka 'long *') converts between pointers to integer types with different sign [-Wpointer-sign]
F2(jtdealx  ){FXSDECL; F2RANK(0,0,jtdealx,0); FXSDO; z=deal(a,w);       FXSOD; R z;}        
                                              ^~~~~
vrand.c:761:76: note: expanded from macro 'FXSDO'
                     if(!jt->rngfxsv){GA(z,INT,GBN,1,0); ra(z); jt->rngfxsv=AV(z);}  \
                                                                           ^~~~~~
vrand.c:767:47: warning: assigning to 'UI *' (aka 'unsigned long *') from 'I *' (aka 'long *') converts between pointers to integer types with different sign [-Wpointer-sign]
DF2(jtrollkx){FXSDECL; RZ(a&&w&&self);        FXSDO; z=rollk(a,w,self); FXSOD; R z;}      
                                              ^~~~~
vrand.c:761:76: note: expanded from macro 'FXSDO'
                     if(!jt->rngfxsv){GA(z,INT,GBN,1,0); ra(z); jt->rngfxsv=AV(z);}  \
                                                                           ^~~~~~
vrand.c:783:6: warning: '/*' within block comment [-Wcomment]
}    /* P.C. Berry, Sharp APL Reference Manual, 1979, p. 126. */
     ^
vrand.c:791:6: warning: '/*' within block comment [-Wcomment]
}    /* E.E. McDonnell circa 1966, small m and large n */
     ^
vrand.c:800:6: warning: '/*' within block comment [-Wcomment]
}    /* P.C. Berry, Sharp APL Reference Manual, 1979, p. 178. */
     ^
13 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vrep.o vrep.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vs.o vs.c
vs.c:202:48: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(m){b[m-1]=1; n=1; u=AV(y); DO(m-1, if(b[i]=1&&ICMP(u,u+c,d))++n; u+=c;);} 
                                           ~~~~^~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vs.c:202:48: note: place parentheses around the assignment to silence this warning
  if(m){b[m-1]=1; n=1; u=AV(y); DO(m-1, if(b[i]=1&&ICMP(u,u+c,d))++n; u+=c;);} 
                                               ^
                                           (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vs.c:202:48: note: use '==' to turn this assignment into an equality comparison
  if(m){b[m-1]=1; n=1; u=AV(y); DO(m-1, if(b[i]=1&&ICMP(u,u+c,d))++n; u+=c;);} 
                                               ^
                                               ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vs.c:245:7: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(m=*AS(y)){n=1; u=AV(y); DO(m-1, if(ICMP(u,u+d,d))++n; u+=d;);} 
     ~^~~~~~~
vs.c:245:7: note: place parentheses around the assignment to silence this warning
  if(m=*AS(y)){n=1; u=AV(y); DO(m-1, if(ICMP(u,u+d,d))++n; u+=d;);} 
      ^
     (       )
vs.c:245:7: note: use '==' to turn this assignment into an equality comparison
  if(m=*AS(y)){n=1; u=AV(y); DO(m-1, if(ICMP(u,u+d,d))++n; u+=d;);} 
      ^
      ==
vs.c:270:7: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(m=*AS(y)){n=1; u=AV(y); DO(m-1, if(ICMP(u,u+d,d))++n; u+=d;);} 
     ~^~~~~~~
vs.c:270:7: note: place parentheses around the assignment to silence this warning
  if(m=*AS(y)){n=1; u=AV(y); DO(m-1, if(ICMP(u,u+d,d))++n; u+=d;);} 
      ^
     (       )
vs.c:270:7: note: use '==' to turn this assignment into an equality comparison
  if(m=*AS(y)){n=1; u=AV(y); DO(m-1, if(ICMP(u,u+d,d))++n; u+=d;);} 
      ^
      ==
vs.c:315:5: warning: expression result unused [-Wunused-value]
 RE(0); R z;
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
4 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vsb.o vsb.c
vsb.c:111:17: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
    if (RIGHT(x)= LEFT(y))    PARENT(LEFT(y)) = x;         /* establish x->right link  */
        ~~~~~~~~^~~~~~~~~
vsb.c:111:17: note: place parentheses around the assignment to silence this warning
    if (RIGHT(x)= LEFT(y))    PARENT(LEFT(y)) = x;         /* establish x->right link  */
                ^
        (                )
vsb.c:111:17: note: use '==' to turn this assignment into an equality comparison
    if (RIGHT(x)= LEFT(y))    PARENT(LEFT(y)) = x;         /* establish x->right link  */
                ^
                ==
vsb.c:116:17: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
    if (LEFT(y) = x)          PARENT(x)       = y;         /* link x and y             */
        ~~~~~~~~^~~
vsb.c:116:17: note: place parentheses around the assignment to silence this warning
    if (LEFT(y) = x)          PARENT(x)       = y;         /* link x and y             */
                ^
        (          )
vsb.c:116:17: note: use '==' to turn this assignment into an equality comparison
    if (LEFT(y) = x)          PARENT(x)       = y;         /* link x and y             */
                ^
                ==
vsb.c:128:16: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
    if (LEFT(x)= RIGHT(y))    PARENT(RIGHT(y))= x;         /* establish x->left link   */
        ~~~~~~~^~~~~~~~~~
vsb.c:128:16: note: place parentheses around the assignment to silence this warning
    if (LEFT(x)= RIGHT(y))    PARENT(RIGHT(y))= x;         /* establish x->left link   */
               ^
        (                )
vsb.c:128:16: note: use '==' to turn this assignment into an equality comparison
    if (LEFT(x)= RIGHT(y))    PARENT(RIGHT(y))= x;         /* establish x->left link   */
               ^
               ==
vsb.c:133:17: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
    if (RIGHT(y)= x)          PARENT(x)       = y;         /* link x and y             */
        ~~~~~~~~^~~
vsb.c:133:17: note: place parentheses around the assignment to silence this warning
    if (RIGHT(y)= x)          PARENT(x)       = y;         /* link x and y             */
                ^
        (          )
vsb.c:133:17: note: use '==' to turn this assignment into an equality comparison
    if (RIGHT(y)= x)          PARENT(x)       = y;         /* link x and y             */
                ^
                ==
vsb.c:533:32: warning: passing 'UC *' (aka 'unsigned char *') to parameter of type 'C *' (aka 'char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  RZ(xv[i]=c2?vec(C2T,vn/2,vc):str(vn,vc));
                               ^~~~~~~~~~
./ja.h:954:50: note: expanded from macro 'str'
#define str(x,y)                    jtstr(jt,(x),(y))
                                                 ^~~
./j.h:252:31: note: expanded from macro 'RZ'
#define RZ(exp)         {if(!(exp))R 0;}
                              ^
./je.h:709:29: note: passing argument to parameter here
extern A        jtstr(J,I,C*);
                            ^
5 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vt.o vt.c
vt.c:31:19: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 b=0; DO(r-m, if(b=u[i+m]!=s[i+m])break;);
                 ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vt.c:31:19: note: place parentheses around the assignment to silence this warning
 b=0; DO(r-m, if(b=u[i+m]!=s[i+m])break;);
                  ^
                 (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vt.c:31:19: note: use '==' to turn this assignment into an equality comparison
 b=0; DO(r-m, if(b=u[i+m]!=s[i+m])break;);
                  ^
                  ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vt.c:32:19: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 c=0; DO(m,   if(c=u[i  ]!=s[i  ])break;);
                 ~^~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vt.c:32:19: note: place parentheses around the assignment to silence this warning
 c=0; DO(m,   if(c=u[i  ]!=s[i  ])break;);
                  ^
                 (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vt.c:32:19: note: use '==' to turn this assignment into an equality comparison
 c=0; DO(m,   if(c=u[i  ]!=s[i  ])break;);
                  ^
                  ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vt.c:41:27: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   c=0; DO(m, t=u[i]; if(c=0>t?iv[i]<t+s[i]:iv[i]>=t)break;);
                         ~^~~~~~~~~~~~~~~~~~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vt.c:41:27: note: place parentheses around the assignment to silence this warning
   c=0; DO(m, t=u[i]; if(c=0>t?iv[i]<t+s[i]:iv[i]>=t)break;);
                          ^
                         (
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
vt.c:41:27: note: use '==' to turn this assignment into an equality comparison
   c=0; DO(m, t=u[i]; if(c=0>t?iv[i]<t+s[i]:iv[i]>=t)break;);
                          ^
                          ==
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
3 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vu.o vu.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vx.o vx.c
vx.c:67:5: warning: expression result unused [-Wunused-value]
 RE(1);
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
vx.c:119:7: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(c=av[i])for(j=0;j<wn;++j){
     ~^~~~~~
vx.c:119:7: note: place parentheses around the assignment to silence this warning
  if(c=av[i])for(j=0;j<wn;++j){
      ^
     (      )
vx.c:119:7: note: use '==' to turn this assignment into an equality comparison
  if(c=av[i])for(j=0;j<wn;++j){
      ^
      ==
vx.c:413:5: warning: expression result unused [-Wunused-value]
 RE(e); R e;
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
vx.c:432:38: warning: expression result unused [-Wunused-value]
  DO(6, s0=xtymes(s0,xc(sk++));); RE(s0);  /* s0 = ! 6*i */
                                     ^~
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
4 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o vz.o vz.c
vz.c:75:33: warning: add explicit braces to avoid dangling else [-Wdangling-else]
 if(1<=p+q+jt->ct)if(p>=q)++zr; else ++zi;
                                ^
vz.c:267:42: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 v=ZAV(w); r=exp(PI*v->re); y=v->im; if(b=0>y)y=-y;
                                        ~^~~~
vz.c:267:42: note: place parentheses around the assignment to silence this warning
 v=ZAV(w); r=exp(PI*v->re); y=v->im; if(b=0>y)y=-y;
                                         ^
                                        (    )
vz.c:267:42: note: use '==' to turn this assignment into an equality comparison
 v=ZAV(w); r=exp(PI*v->re); y=v->im; if(b=0>y)y=-y;
                                         ^
                                         ==
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o w.o w.c
w.c:109:36: warning: '&&' within '||' [-Wlogical-op-parentheses]
  if(1<wl){d=*(wi+wl-1); if(b=p!=C9&&d==CESC1||d==CESC2)e=spellin(wl,wi);}
                              ~~~~~^~~~~~~~~~~~
w.c:109:36: note: place parentheses around the '&&' expression to silence this warning
  if(1<wl){d=*(wi+wl-1); if(b=p!=C9&&d==CESC1||d==CESC2)e=spellin(wl,wi);}
                              ~~~~~^~~~~~~~~~
w.c:109:30: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  if(1<wl){d=*(wi+wl-1); if(b=p!=C9&&d==CESC1||d==CESC2)e=spellin(wl,wi);}
                            ~^~~~~~~~~~~~~~~~~~~~~~~~~~
w.c:109:30: note: place parentheses around the assignment to silence this warning
  if(1<wl){d=*(wi+wl-1); if(b=p!=C9&&d==CESC1||d==CESC2)e=spellin(wl,wi);}
                             ^
                            (                          )
w.c:109:30: note: use '==' to turn this assignment into an equality comparison
  if(1<wl){d=*(wi+wl-1); if(b=p!=C9&&d==CESC1||d==CESC2)e=spellin(wl,wi);}
                             ^
                             ==
w.c:118:64: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(6<=n && TAIA(0,n-1) && ((b=TRBRACE(n-2)) || RPAR&AT(v[n-2])&&TRBRACE(n-3))){I c,j,p,q;
                                             ~~ ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~
w.c:118:64: note: place parentheses around the '&&' expression to silence this warning
 if(6<=n && TAIA(0,n-1) && ((b=TRBRACE(n-2)) || RPAR&AT(v[n-2])&&TRBRACE(n-3))){I c,j,p,q;
                                                ~~~~~~~~~~~~~~~^~~~~~~~~~~~~~
w.c:221:16: warning: initializing 'B *' (aka 'char *') with an expression of type 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case  1: {B *wv=UAV(w); FSMF(B,B01,1, 1,   wv[i] ,EMIT1, ZVAx);} break;
               ^  ~~~~~~
w.c:227:53: warning: passing 'UC *' (aka 'unsigned char *') to parameter of type 'C *' (aka 'char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case 10: {UC*wv=UAV(w); FSMF(A,BOX,1, 1,mv[wv[i]],EMIT0c,ZVAx);} break;
                                                    ^~~~~~~~~~~~
w.c:201:62: note: expanded from macro 'FSMF'
  for(;i<n;++i,r=*v){c=(cexp); v=sv+2*(c+r*q); ZVA; DO_ONE(T,EMIT);}        \
                                                             ^
w.c:188:29: note: expanded from macro 'DO_ONE'
  case 2: case 3: if(0<=vi){EMIT(T,vj,vi,vr,vc); vi=vr=-1;} EMIT(T,j,i,r,c);       j=2==e?i:-1; break;  \
                            ^
w.c:174:69: note: expanded from macro 'EMIT0c'
#define EMIT0c(T,j,i,r,c)   {CHKJ(j); p=(i)-(j); EXTZ(T,1); RZ(*u++=str(p,(j)+wv));}
                                                                    ^~~~~~~~~~~~~
./ja.h:954:50: note: expanded from macro 'str'
#define str(x,y)                    jtstr(jt,(x),(y))
                                                 ^~~
./j.h:252:31: note: expanded from macro 'RZ'
#define RZ(exp)         {if(!(exp))R 0;}
                              ^
./je.h:709:29: note: passing argument to parameter here
extern A        jtstr(J,I,C*);
                            ^
w.c:227:53: warning: passing 'UC *' (aka 'unsigned char *') to parameter of type 'C *' (aka 'char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case 10: {UC*wv=UAV(w); FSMF(A,BOX,1, 1,mv[wv[i]],EMIT0c,ZVAx);} break;
                                                    ^~~~~~~~~~~~
w.c:201:62: note: expanded from macro 'FSMF'
  for(;i<n;++i,r=*v){c=(cexp); v=sv+2*(c+r*q); ZVA; DO_ONE(T,EMIT);}        \
                                                             ^
w.c:188:61: note: expanded from macro 'DO_ONE'
  case 2: case 3: if(0<=vi){EMIT(T,vj,vi,vr,vc); vi=vr=-1;} EMIT(T,j,i,r,c);       j=2==e?i:-1; break;  \
                                                            ^
w.c:174:69: note: expanded from macro 'EMIT0c'
#define EMIT0c(T,j,i,r,c)   {CHKJ(j); p=(i)-(j); EXTZ(T,1); RZ(*u++=str(p,(j)+wv));}
                                                                    ^~~~~~~~~~~~~
./ja.h:954:50: note: expanded from macro 'str'
#define str(x,y)                    jtstr(jt,(x),(y))
                                                 ^~~
./j.h:252:31: note: expanded from macro 'RZ'
#define RZ(exp)         {if(!(exp))R 0;}
                              ^
./je.h:709:29: note: passing argument to parameter here
extern A        jtstr(J,I,C*);
                            ^
w.c:227:53: warning: passing 'UC *' (aka 'unsigned char *') to parameter of type 'C *' (aka 'char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case 10: {UC*wv=UAV(w); FSMF(A,BOX,1, 1,mv[wv[i]],EMIT0c,ZVAx);} break;
                                                    ^~~~~~~~~~~~
w.c:201:62: note: expanded from macro 'FSMF'
  for(;i<n;++i,r=*v){c=(cexp); v=sv+2*(c+r*q); ZVA; DO_ONE(T,EMIT);}        \
                                                             ^
w.c:189:38: note: expanded from macro 'DO_ONE'
  case 4: case 5: if(r!=vr){if(0<=vi)EMIT(T,vj,vi,vr,vc); vj=j; vr=r; vc=c;} vi=i; j=4==e?i:-1; break;  \
                                     ^
w.c:174:69: note: expanded from macro 'EMIT0c'
#define EMIT0c(T,j,i,r,c)   {CHKJ(j); p=(i)-(j); EXTZ(T,1); RZ(*u++=str(p,(j)+wv));}
                                                                    ^~~~~~~~~~~~~
./ja.h:954:50: note: expanded from macro 'str'
#define str(x,y)                    jtstr(jt,(x),(y))
                                                 ^~~
./j.h:252:31: note: expanded from macro 'RZ'
#define RZ(exp)         {if(!(exp))R 0;}
                              ^
./je.h:709:29: note: passing argument to parameter here
extern A        jtstr(J,I,C*);
                            ^
w.c:227:53: warning: passing 'UC *' (aka 'unsigned char *') to parameter of type 'C *' (aka 'char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case 10: {UC*wv=UAV(w); FSMF(A,BOX,1, 1,mv[wv[i]],EMIT0c,ZVAx);} break;
                                                    ^~~~~~~~~~~~
w.c:203:62: note: expanded from macro 'FSMF'
   if(0<=d)         {c=d;      v=sv+2*(c+r*q); ZVA; DO_ONE(T,EMIT);}        \
                                                             ^
w.c:188:29: note: expanded from macro 'DO_ONE'
  case 2: case 3: if(0<=vi){EMIT(T,vj,vi,vr,vc); vi=vr=-1;} EMIT(T,j,i,r,c);       j=2==e?i:-1; break;  \
                            ^
w.c:174:69: note: expanded from macro 'EMIT0c'
#define EMIT0c(T,j,i,r,c)   {CHKJ(j); p=(i)-(j); EXTZ(T,1); RZ(*u++=str(p,(j)+wv));}
                                                                    ^~~~~~~~~~~~~
./ja.h:954:50: note: expanded from macro 'str'
#define str(x,y)                    jtstr(jt,(x),(y))
                                                 ^~~
./j.h:252:31: note: expanded from macro 'RZ'
#define RZ(exp)         {if(!(exp))R 0;}
                              ^
./je.h:709:29: note: passing argument to parameter here
extern A        jtstr(J,I,C*);
                            ^
w.c:227:53: warning: passing 'UC *' (aka 'unsigned char *') to parameter of type 'C *' (aka 'char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case 10: {UC*wv=UAV(w); FSMF(A,BOX,1, 1,mv[wv[i]],EMIT0c,ZVAx);} break;
                                                    ^~~~~~~~~~~~
w.c:203:62: note: expanded from macro 'FSMF'
   if(0<=d)         {c=d;      v=sv+2*(c+r*q); ZVA; DO_ONE(T,EMIT);}        \
                                                             ^
w.c:188:61: note: expanded from macro 'DO_ONE'
  case 2: case 3: if(0<=vi){EMIT(T,vj,vi,vr,vc); vi=vr=-1;} EMIT(T,j,i,r,c);       j=2==e?i:-1; break;  \
                                                            ^
w.c:174:69: note: expanded from macro 'EMIT0c'
#define EMIT0c(T,j,i,r,c)   {CHKJ(j); p=(i)-(j); EXTZ(T,1); RZ(*u++=str(p,(j)+wv));}
                                                                    ^~~~~~~~~~~~~
./ja.h:954:50: note: expanded from macro 'str'
#define str(x,y)                    jtstr(jt,(x),(y))
                                                 ^~~
./j.h:252:31: note: expanded from macro 'RZ'
#define RZ(exp)         {if(!(exp))R 0;}
                              ^
./je.h:709:29: note: passing argument to parameter here
extern A        jtstr(J,I,C*);
                            ^
w.c:227:53: warning: passing 'UC *' (aka 'unsigned char *') to parameter of type 'C *' (aka 'char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case 10: {UC*wv=UAV(w); FSMF(A,BOX,1, 1,mv[wv[i]],EMIT0c,ZVAx);} break;
                                                    ^~~~~~~~~~~~
w.c:203:62: note: expanded from macro 'FSMF'
   if(0<=d)         {c=d;      v=sv+2*(c+r*q); ZVA; DO_ONE(T,EMIT);}        \
                                                             ^
w.c:189:38: note: expanded from macro 'DO_ONE'
  case 4: case 5: if(r!=vr){if(0<=vi)EMIT(T,vj,vi,vr,vc); vj=j; vr=r; vc=c;} vi=i; j=4==e?i:-1; break;  \
                                     ^
w.c:174:69: note: expanded from macro 'EMIT0c'
#define EMIT0c(T,j,i,r,c)   {CHKJ(j); p=(i)-(j); EXTZ(T,1); RZ(*u++=str(p,(j)+wv));}
                                                                    ^~~~~~~~~~~~~
./ja.h:954:50: note: expanded from macro 'str'
#define str(x,y)                    jtstr(jt,(x),(y))
                                                 ^~~
./j.h:252:31: note: expanded from macro 'RZ'
#define RZ(exp)         {if(!(exp))R 0;}
                              ^
./je.h:709:29: note: passing argument to parameter here
extern A        jtstr(J,I,C*);
                            ^
w.c:227:53: warning: passing 'UC *' (aka 'unsigned char *') to parameter of type 'C *' (aka 'char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case 10: {UC*wv=UAV(w); FSMF(A,BOX,1, 1,mv[wv[i]],EMIT0c,ZVAx);} break;
                                                    ^~~~~~~~~~~~
w.c:205:20: note: expanded from macro 'FSMF'
    if(0<=vi      )EMIT(T,vj,r==vr?n:vi,vr,vc);                             \
                   ^
w.c:174:69: note: expanded from macro 'EMIT0c'
#define EMIT0c(T,j,i,r,c)   {CHKJ(j); p=(i)-(j); EXTZ(T,1); RZ(*u++=str(p,(j)+wv));}
                                                                    ^~~~~~~~~~~~~
./ja.h:954:50: note: expanded from macro 'str'
#define str(x,y)                    jtstr(jt,(x),(y))
                                                 ^~~
./j.h:252:31: note: expanded from macro 'RZ'
#define RZ(exp)         {if(!(exp))R 0;}
                              ^
./je.h:709:29: note: passing argument to parameter here
extern A        jtstr(J,I,C*);
                            ^
w.c:227:53: warning: passing 'UC *' (aka 'unsigned char *') to parameter of type 'C *' (aka 'char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case 10: {UC*wv=UAV(w); FSMF(A,BOX,1, 1,mv[wv[i]],EMIT0c,ZVAx);} break;
                                                    ^~~~~~~~~~~~
w.c:206:20: note: expanded from macro 'FSMF'
    if(r!=vr&&0<=j)EMIT(T,j,n,r,c);                                         \
                   ^
w.c:174:69: note: expanded from macro 'EMIT0c'
#define EMIT0c(T,j,i,r,c)   {CHKJ(j); p=(i)-(j); EXTZ(T,1); RZ(*u++=str(p,(j)+wv));}
                                                                    ^~~~~~~~~~~~~
./ja.h:954:50: note: expanded from macro 'str'
#define str(x,y)                    jtstr(jt,(x),(y))
                                                 ^~~
./j.h:252:31: note: expanded from macro 'RZ'
#define RZ(exp)         {if(!(exp))R 0;}
                              ^
./je.h:709:29: note: passing argument to parameter here
extern A        jtstr(J,I,C*);
                            ^
w.c:228:53: warning: assigning to 'C *' (aka 'char *') from 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case 11: {UC*wv=UAV(w); FSMF(C,LIT,1, 1,mv[wv[i]],EMIT1, ZVAx);} break;
                                                    ^~~~~~~~~~~~
w.c:201:62: note: expanded from macro 'FSMF'
  for(;i<n;++i,r=*v){c=(cexp); v=sv+2*(c+r*q); ZVA; DO_ONE(T,EMIT);}        \
                                                             ^
w.c:188:29: note: expanded from macro 'DO_ONE'
  case 2: case 3: if(0<=vi){EMIT(T,vj,vi,vr,vc); vi=vr=-1;} EMIT(T,j,i,r,c);       j=2==e?i:-1; break;  \
                            ^
w.c:178:63: note: expanded from macro 'EMIT1'
#define EMIT1(T,j,i,r,c)    {CHKJ(j); p=(i)-(j);            cc=(j)+wv; DO(p, *u++=*cc++;);}
                                                              ^~~~~~~
w.c:228:53: warning: assigning to 'C *' (aka 'char *') from 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case 11: {UC*wv=UAV(w); FSMF(C,LIT,1, 1,mv[wv[i]],EMIT1, ZVAx);} break;
                                                    ^~~~~~~~~~~~
w.c:201:62: note: expanded from macro 'FSMF'
  for(;i<n;++i,r=*v){c=(cexp); v=sv+2*(c+r*q); ZVA; DO_ONE(T,EMIT);}        \
                                                             ^
w.c:188:61: note: expanded from macro 'DO_ONE'
  case 2: case 3: if(0<=vi){EMIT(T,vj,vi,vr,vc); vi=vr=-1;} EMIT(T,j,i,r,c);       j=2==e?i:-1; break;  \
                                                            ^
w.c:178:63: note: expanded from macro 'EMIT1'
#define EMIT1(T,j,i,r,c)    {CHKJ(j); p=(i)-(j);            cc=(j)+wv; DO(p, *u++=*cc++;);}
                                                              ^~~~~~~
w.c:228:53: warning: assigning to 'C *' (aka 'char *') from 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case 11: {UC*wv=UAV(w); FSMF(C,LIT,1, 1,mv[wv[i]],EMIT1, ZVAx);} break;
                                                    ^~~~~~~~~~~~
w.c:201:62: note: expanded from macro 'FSMF'
  for(;i<n;++i,r=*v){c=(cexp); v=sv+2*(c+r*q); ZVA; DO_ONE(T,EMIT);}        \
                                                             ^
w.c:189:38: note: expanded from macro 'DO_ONE'
  case 4: case 5: if(r!=vr){if(0<=vi)EMIT(T,vj,vi,vr,vc); vj=j; vr=r; vc=c;} vi=i; j=4==e?i:-1; break;  \
                                     ^
w.c:178:63: note: expanded from macro 'EMIT1'
#define EMIT1(T,j,i,r,c)    {CHKJ(j); p=(i)-(j);            cc=(j)+wv; DO(p, *u++=*cc++;);}
                                                              ^~~~~~~
w.c:228:53: warning: assigning to 'C *' (aka 'char *') from 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case 11: {UC*wv=UAV(w); FSMF(C,LIT,1, 1,mv[wv[i]],EMIT1, ZVAx);} break;
                                                    ^~~~~~~~~~~~
w.c:203:62: note: expanded from macro 'FSMF'
   if(0<=d)         {c=d;      v=sv+2*(c+r*q); ZVA; DO_ONE(T,EMIT);}        \
                                                             ^
w.c:188:29: note: expanded from macro 'DO_ONE'
  case 2: case 3: if(0<=vi){EMIT(T,vj,vi,vr,vc); vi=vr=-1;} EMIT(T,j,i,r,c);       j=2==e?i:-1; break;  \
                            ^
w.c:178:63: note: expanded from macro 'EMIT1'
#define EMIT1(T,j,i,r,c)    {CHKJ(j); p=(i)-(j);            cc=(j)+wv; DO(p, *u++=*cc++;);}
                                                              ^~~~~~~
w.c:228:53: warning: assigning to 'C *' (aka 'char *') from 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case 11: {UC*wv=UAV(w); FSMF(C,LIT,1, 1,mv[wv[i]],EMIT1, ZVAx);} break;
                                                    ^~~~~~~~~~~~
w.c:203:62: note: expanded from macro 'FSMF'
   if(0<=d)         {c=d;      v=sv+2*(c+r*q); ZVA; DO_ONE(T,EMIT);}        \
                                                             ^
w.c:188:61: note: expanded from macro 'DO_ONE'
  case 2: case 3: if(0<=vi){EMIT(T,vj,vi,vr,vc); vi=vr=-1;} EMIT(T,j,i,r,c);       j=2==e?i:-1; break;  \
                                                            ^
w.c:178:63: note: expanded from macro 'EMIT1'
#define EMIT1(T,j,i,r,c)    {CHKJ(j); p=(i)-(j);            cc=(j)+wv; DO(p, *u++=*cc++;);}
                                                              ^~~~~~~
w.c:228:53: warning: assigning to 'C *' (aka 'char *') from 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case 11: {UC*wv=UAV(w); FSMF(C,LIT,1, 1,mv[wv[i]],EMIT1, ZVAx);} break;
                                                    ^~~~~~~~~~~~
w.c:203:62: note: expanded from macro 'FSMF'
   if(0<=d)         {c=d;      v=sv+2*(c+r*q); ZVA; DO_ONE(T,EMIT);}        \
                                                             ^
w.c:189:38: note: expanded from macro 'DO_ONE'
  case 4: case 5: if(r!=vr){if(0<=vi)EMIT(T,vj,vi,vr,vc); vj=j; vr=r; vc=c;} vi=i; j=4==e?i:-1; break;  \
                                     ^
w.c:178:63: note: expanded from macro 'EMIT1'
#define EMIT1(T,j,i,r,c)    {CHKJ(j); p=(i)-(j);            cc=(j)+wv; DO(p, *u++=*cc++;);}
                                                              ^~~~~~~
w.c:228:53: warning: assigning to 'C *' (aka 'char *') from 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case 11: {UC*wv=UAV(w); FSMF(C,LIT,1, 1,mv[wv[i]],EMIT1, ZVAx);} break;
                                                    ^~~~~~~~~~~~
w.c:205:20: note: expanded from macro 'FSMF'
    if(0<=vi      )EMIT(T,vj,r==vr?n:vi,vr,vc);                             \
                   ^
w.c:178:63: note: expanded from macro 'EMIT1'
#define EMIT1(T,j,i,r,c)    {CHKJ(j); p=(i)-(j);            cc=(j)+wv; DO(p, *u++=*cc++;);}
                                                              ^~~~~~~
w.c:228:53: warning: assigning to 'C *' (aka 'char *') from 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  case 11: {UC*wv=UAV(w); FSMF(C,LIT,1, 1,mv[wv[i]],EMIT1, ZVAx);} break;
                                                    ^~~~~~~~~~~~
w.c:206:20: note: expanded from macro 'FSMF'
    if(r!=vr&&0<=j)EMIT(T,j,n,r,c);                                         \
                   ^
w.c:178:63: note: expanded from macro 'EMIT1'
#define EMIT1(T,j,i,r,c)    {CHKJ(j); p=(i)-(j);            cc=(j)+wv; DO(p, *u++=*cc++;);}
                                                              ^~~~~~~
20 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o wc.o wc.c
wc.c:286:66: warning: '&&' within '||' [-Wlogical-op-parentheses]
   if(!k)RZ(x=enqueue(w1,w0)) else x=k==CLABEL||k==CGOTO||k==CFOR&&4<AN(w0)?w0:0L;
                                                        ~~~~~~~~~^~~~~~~~~~
wc.c:286:66: note: place parentheses around the '&&' expression to silence this warning
   if(!k)RZ(x=enqueue(w1,w0)) else x=k==CLABEL||k==CGOTO||k==CFOR&&4<AN(w0)?w0:0L;
                                                          ~~~~~~~^~~~~~~~~~
wc.c:297:5: warning: expression result unused [-Wunused-value]
 RE(0);
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o wn.o wn.c
wn.c:32:3: warning: add explicit braces to avoid dangling else [-Wdangling-else]
  else{
  ^
wn.c:44:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(t=memchr(s,'j',n))ta=0; else t=ta=memchr(s,'a',n);
    ~^~~~~~~~~~~~~~~~
wn.c:44:6: note: place parentheses around the assignment to silence this warning
 if(t=memchr(s,'j',n))ta=0; else t=ta=memchr(s,'a',n);
     ^
    (                )
wn.c:44:6: note: use '==' to turn this assignment into an equality comparison
 if(t=memchr(s,'j',n))ta=0; else t=ta=memchr(s,'a',n);
     ^
     ==
wn.c:57:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(neg='-'==*s){++s; --n; RZ(n);}
    ~~~^~~~~~~~
wn.c:57:8: note: place parentheses around the assignment to silence this warning
 if(neg='-'==*s){++s; --n; RZ(n);}
       ^
    (          )
wn.c:57:8: note: use '==' to turn this assignment into an equality comparison
 if(neg='-'==*s){++s; --n; RZ(n);}
       ^
       ==
wn.c:87:7: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(te=memchr(s,'e',n)){ne=n-(te-s)-1; e=strtol(1+te,&t,10);  RZ(!*t&&10>ne);}
    ~~^~~~~~~~~~~~~~~~
wn.c:87:7: note: place parentheses around the assignment to silence this warning
 if(te=memchr(s,'e',n)){ne=n-(te-s)-1; e=strtol(1+te,&t,10);  RZ(!*t&&10>ne);}
      ^
    (                 )
wn.c:87:7: note: use '==' to turn this assignment into an equality comparison
 if(te=memchr(s,'e',n)){ne=n-(te-s)-1; e=strtol(1+te,&t,10);  RZ(!*t&&10>ne);}
      ^
      ==
wn.c:88:7: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(td=memchr(s,'.',n)){nf=te?(te-td)-1:n-(td-s)-1; if(nf)RZ(numx(nf,td+1,&f.n));}
    ~~^~~~~~~~~~~~~~~~
wn.c:88:7: note: place parentheses around the assignment to silence this warning
 if(td=memchr(s,'.',n)){nf=te?(te-td)-1:n-(td-s)-1; if(nf)RZ(numx(nf,td+1,&f.n));}
      ^
    (                 )
wn.c:88:7: note: use '==' to turn this assignment into an equality comparison
 if(td=memchr(s,'.',n)){nf=te?(te-td)-1:n-(td-s)-1; if(nf)RZ(numx(nf,td+1,&f.n));}
      ^
      ==
wn.c:129:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(t=memchr(s,'b',n)){
    ~^~~~~~~~~~~~~~~~
wn.c:129:6: note: place parentheses around the assignment to silence this warning
 if(t=memchr(s,'b',n)){
     ^
    (                )
wn.c:129:6: note: use '==' to turn this assignment into an equality comparison
 if(t=memchr(s,'b',n)){
     ^
     ==
wn.c:131:13: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  ++t; if(ne='-'==*t)++t;
          ~~^~~~~~~~
wn.c:131:13: note: place parentheses around the assignment to silence this warning
  ++t; if(ne='-'==*t)++t;
            ^
          (         )
wn.c:131:13: note: use '==' to turn this assignment into an equality comparison
  ++t; if(ne='-'==*t)++t;
            ^
            ==
wn.c:132:18: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  m=k=n+s-t; if(u=memchr(t,'.',m))k=u-t;
                ~^~~~~~~~~~~~~~~~
wn.c:132:18: note: place parentheses around the assignment to silence this warning
  m=k=n+s-t; if(u=memchr(t,'.',m))k=u-t;
                 ^
                (                )
wn.c:132:18: note: use '==' to turn this assignment into an equality comparison
  m=k=n+s-t; if(u=memchr(t,'.',m))k=u-t;
                 ^
                 ==
wn.c:137:9: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   if(ze=!(b.re||b.im))b.re=1;
      ~~^~~~~~~~~~~~~~
wn.c:137:9: note: place parentheses around the assignment to silence this warning
   if(ze=!(b.re||b.im))b.re=1;
        ^
      (               )
wn.c:137:9: note: use '==' to turn this assignment into an equality comparison
   if(ze=!(b.re||b.im))b.re=1;
        ^
        ==
wn.c:144:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(t=memchr(s,'p',n))u=0; else t=u=memchr(s,'x',n);
    ~^~~~~~~~~~~~~~~~
wn.c:144:6: note: place parentheses around the assignment to silence this warning
 if(t=memchr(s,'p',n))u=0; else t=u=memchr(s,'x',n);
     ^
    (                )
wn.c:144:6: note: use '==' to turn this assignment into an equality comparison
 if(t=memchr(s,'p',n))u=0; else t=u=memchr(s,'x',n);
     ^
     ==
wn.c:229:12: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
    while(d=*++v)if(','!=d)*x++=d; 
          ~^~~~~
wn.c:229:12: note: place parentheses around the assignment to silence this warning
    while(d=*++v)if(','!=d)*x++=d; 
           ^
          (     )
wn.c:229:12: note: use '==' to turn this assignment into an equality comparison
    while(d=*++v)if(','!=d)*x++=d; 
           ^
           ==
wn.c:237:42: warning: while loop has empty body [-Wempty-body]
    else{zv[i++]=a0; --v; while(C0!=*v++); u=v;}
                                         ^
wn.c:237:42: note: put the semicolon on a separate line to silence this warning
wn.c:242:32: warning: while loop has empty body [-Wempty-body]
    zv[i++]=a0; while(C0!=*++v); u=v;
                               ^
wn.c:242:32: note: put the semicolon on a separate line to silence this warning
13 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o ws.o ws.c
ws.c:59:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   if(t=(C*)strchr(sp3[1],p)){j=t-sp3[1]; R c==sp3[2][j]&&d==sp3[3][j]?sp3[0][j]:0;}
      ~^~~~~~~~~~~~~~~~~~~~~
ws.c:59:8: note: place parentheses around the assignment to silence this warning
   if(t=(C*)strchr(sp3[1],p)){j=t-sp3[1]; R c==sp3[2][j]&&d==sp3[3][j]?sp3[0][j]:0;}
       ^
      (                     )
ws.c:59:8: note: use '==' to turn this assignment into an equality comparison
   if(t=(C*)strchr(sp3[1],p)){j=t-sp3[1]; R c==sp3[2][j]&&d==sp3[3][j]?sp3[0][j]:0;}
       ^
       ==
ws.c:67:11: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 else if(q=(C*)strchr(spell[1],c)){k=q-spell[1]; s[0]=spell[0][k]; s[1]=CESC1;}
         ~^~~~~~~~~~~~~~~~~~~~~~~
ws.c:67:11: note: place parentheses around the assignment to silence this warning
 else if(q=(C*)strchr(spell[1],c)){k=q-spell[1]; s[0]=spell[0][k]; s[1]=CESC1;}
          ^
         (                       )
ws.c:67:11: note: use '==' to turn this assignment into an equality comparison
 else if(q=(C*)strchr(spell[1],c)){k=q-spell[1]; s[0]=spell[0][k]; s[1]=CESC1;}
          ^
          ==
ws.c:68:11: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 else if(q=(C*)strchr(spell[2],c)){k=q-spell[2]; s[0]=spell[0][k]; s[1]=CESC2;}
         ~^~~~~~~~~~~~~~~~~~~~~~~
ws.c:68:11: note: place parentheses around the assignment to silence this warning
 else if(q=(C*)strchr(spell[2],c)){k=q-spell[2]; s[0]=spell[0][k]; s[1]=CESC2;}
          ^
         (                       )
ws.c:68:11: note: use '==' to turn this assignment into an equality comparison
 else if(q=(C*)strchr(spell[2],c)){k=q-spell[2]; s[0]=spell[0][k]; s[1]=CESC2;}
          ^
          ==
ws.c:69:11: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 else if(q=(C*)strchr(sp3[0],  c)){k=q-sp3[0];   s[0]=sp3[1][k];   s[1]=sp3[2][k]; s[2]=sp3[3][k];}
         ~^~~~~~~~~~~~~~~~~~~~~~~
ws.c:69:11: note: place parentheses around the assignment to silence this warning
 else if(q=(C*)strchr(sp3[0],  c)){k=q-sp3[0];   s[0]=sp3[1][k];   s[1]=sp3[2][k]; s[2]=sp3[3][k];}
          ^
         (                       )
ws.c:69:11: note: use '==' to turn this assignment into an equality comparison
 else if(q=(C*)strchr(sp3[0],  c)){k=q-sp3[0];   s[0]=sp3[1][k];   s[1]=sp3[2][k]; s[2]=sp3[3][k];}
          ^
          ==
4 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o x.o x.c
x.c:28:23: warning: expression result unused [-Wunused-value]
 p=i0(a); q=i0(w); RE(0);
                      ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
1 warning generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o x15.o x15.c
x15.c:416:26: warning: passing 'C *' (aka 'char *') to parameter of type 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
 an=strlen(av); j=hic(an,av)%hn; 
                         ^~
./je.h:758:26: note: passing argument to parameter here
extern UI       hic(I,UC*);
                         ^
x15.c:430:32: warning: passing 'C *' (aka 'char *') to parameter of type 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
 DO(jt->cdna-k, j=hic(pv[k].an,s+pv[k].ai)%hn; while(0<=hv[j])j=(j+1)%hn; hv[j]=k; ++k;);
                               ^~~~~~~~~~
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
./je.h:758:26: note: passing argument to parameter here
extern UI       hic(I,UC*);
                         ^
x15.c:449:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(h=cdlookupl(lib))cc->h=h;
    ~^~~~~~~~~~~~~~~
x15.c:449:6: note: place parentheses around the assignment to silence this warning
 if(h=cdlookupl(lib))cc->h=h;
     ^
    (               )
x15.c:449:6: note: use '==' to turn this assignment into an equality comparison
 if(h=cdlookupl(lib))cc->h=h;
     ^
     ==
x15.c:480:16: warning: passing 'C *' (aka 'char *') to parameter of type 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  j=hic(cc->ln,lib)%hn; while(0<=hv[j])j=(j+1)%hn; hv[j]=jt->cdna;
               ^~~
./je.h:758:26: note: passing argument to parameter here
extern UI       hic(I,UC*);
                         ^
x15.c:521:7: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(cc=cdlookup(a))R cc;
    ~~^~~~~~~~~~~~
x15.c:521:7: note: place parentheses around the assignment to silence this warning
 if(cc=cdlookup(a))R cc;
      ^
    (             )
x15.c:521:7: note: use '==' to turn this assignment into an equality comparison
 if(cc=cdlookup(a))R cc;
      ^
      ==
x15.c:546:9: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 while(c=*s++){
       ~^~~~~
x15.c:546:9: note: place parentheses around the assignment to silence this warning
 while(c=*s++){
        ^
       (     )
x15.c:546:9: note: use '==' to turn this assignment into an equality comparison
 while(c=*s++){
        ^
        ==
x15.c:605:29: warning: '&&' within '||' [-Wlogical-op-parentheses]
   lit=star&&xt&LIT&&(c=='s'&&0==xn%2||c=='f'&&0==xn%4);
                      ~~~~~~^~~~~~~~~~~
x15.c:605:29: note: place parentheses around the '&&' expression to silence this warning
   lit=star&&xt&LIT&&(c=='s'&&0==xn%2||c=='f'&&0==xn%4);
                            ^
                      (              )
x15.c:605:46: warning: '&&' within '||' [-Wlogical-op-parentheses]
   lit=star&&xt&LIT&&(c=='s'&&0==xn%2||c=='f'&&0==xn%4);
                                     ~~~~~~~~^~~~~~~~~
x15.c:605:46: note: place parentheses around the '&&' expression to silence this warning
   lit=star&&xt&LIT&&(c=='s'&&0==xn%2||c=='f'&&0==xn%4);
                                             ^
                                       (              )
x15.c:606:33: warning: '&&' within '||' [-Wlogical-op-parentheses]
   if(t&&t!=xt&&!(lit||star&&!xr&&xt&BOX)){x=cvt(xt=t,x); CDASSERT(x,per);}
                     ~~~~~~~~~~~^~~~~~~~
x15.c:606:33: note: place parentheses around the '&&' expression to silence this warning
   if(t&&t!=xt&&!(lit||star&&!xr&&xt&BOX)){x=cvt(xt=t,x); CDASSERT(x,per);}
                       ~~~~~~~~~^~~~~~~~
x15.c:621:35: warning: '&&' within '||' [-Wlogical-op-parentheses]
   if(!lit&&(c=='s'||c=='f'||SY_64&&c=='i')){
                           ~~~~~~~^~~~~~~~
x15.c:621:35: note: place parentheses around the '&&' expression to silence this warning
   if(!lit&&(c=='s'||c=='f'||SY_64&&c=='i')){
                             ~~~~~^~~~~~~~
x15.c:887:10: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  while(c=*s++){
        ~^~~~~
x15.c:887:10: note: place parentheses around the assignment to silence this warning
  while(c=*s++){
         ^
        (     )
x15.c:887:10: note: use '==' to turn this assignment into an equality comparison
  while(c=*s++){
         ^
         ==
11 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o xa.o xa.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o xb.o xb.c
xb.c:171:5: warning: expression result unused [-Wunused-value]
 RE(z); R z;
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
xb.c:211:5: warning: expression result unused [-Wunused-value]
 RE(z); R z;
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
xb.c:241:30: warning: '&&' within '||' [-Wlogical-op-parentheses]
   if(!(0<=k&&(!n||0<=c&&k<=n&&c<=n)))b=1;
                 ~~~~~~~~~~~~^~~~~~
xb.c:241:30: note: place parentheses around the '&&' expression to silence this warning
   if(!(0<=k&&(!n||0<=c&&k<=n&&c<=n)))b=1;
                             ^
                   (               )
xb.c:310:83: warning: expression result unused [-Wunused-value]
 else if(t&BOX ){wv=AAV(w); wd=(I)w*ARELATIVE(w); DO(n, *u++=isnanq(WVR(i));); RE(0);}
                                                                                  ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
4 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o xc.o xc.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o xcrc.o xcrc.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o xd.o xd.c
xd.c:302:16: warning: implicit declaration of function 'access' is invalid in C99 [-Wimplicit-function-declaration]
 jt->dirrwx[0]=access(jt->dirnamebuf,R_OK)?'-':'r';
               ^
xd.c:334:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(x=strrchr(s,'/')){dir=s==x?"/":s; pat=x+1; *x=0;}else{dir="."; pat=s;}
    ~^~~~~~~~~~~~~~~
xd.c:334:6: note: place parentheses around the assignment to silence this warning
 if(x=strrchr(s,'/')){dir=s==x?"/":s; pat=x+1; *x=0;}else{dir="."; pat=s;}
     ^
    (               )
xd.c:334:6: note: use '==' to turn this assignment into an equality comparison
 if(x=strrchr(s,'/')){dir=s==x?"/":s; pat=x+1; *x=0;}else{dir="."; pat=s;}
     ^
     ==
2 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o xf.o xf.c
xf.c:113:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(b=!f)RZ(f=jope(w,FWRITE)) else RE(vfn(f)); 
    ~^~~
xf.c:113:6: note: place parentheses around the assignment to silence this warning
 if(b=!f)RZ(f=jope(w,FWRITE)) else RE(vfn(f)); 
     ^
    (   )
xf.c:113:6: note: use '==' to turn this assignment into an equality comparison
 if(b=!f)RZ(f=jope(w,FWRITE)) else RE(vfn(f)); 
     ^
     ==
xf.c:125:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(b=!f)RZ(f=jope(w,FAPPEND)) else RE(vfn(f));
    ~^~~
xf.c:125:6: note: place parentheses around the assignment to silence this warning
 if(b=!f)RZ(f=jope(w,FAPPEND)) else RE(vfn(f));
     ^
    (   )
xf.c:125:6: note: use '==' to turn this assignment into an equality comparison
 if(b=!f)RZ(f=jope(w,FAPPEND)) else RE(vfn(f));
     ^
     ==
xf.c:134:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(b=!f)RZ(f=jope(w,FREAD)) else RE(vfn(f)); 
    ~^~~
xf.c:134:6: note: place parentheses around the assignment to silence this warning
 if(b=!f)RZ(f=jope(w,FREAD)) else RE(vfn(f)); 
     ^
    (   )
xf.c:134:6: note: use '==' to turn this assignment into an equality comparison
 if(b=!f)RZ(f=jope(w,FREAD)) else RE(vfn(f)); 
     ^
     ==
xf.c:164:20: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 RE(f=ixf(w)); if(b=!f)RZ(f=jope(w,FREAD));
                  ~^~~
xf.c:164:20: note: place parentheses around the assignment to silence this warning
 RE(f=ixf(w)); if(b=!f)RZ(f=jope(w,FREAD));
                   ^
                  (   )
xf.c:164:20: note: use '==' to turn this assignment into an equality comparison
 RE(f=ixf(w)); if(b=!f)RZ(f=jope(w,FREAD));
                   ^
                   ==
xf.c:174:20: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 RE(f=ixf(w)); if(b=!f)RZ(f=jope(w,FUPDATE));
                  ~^~~
xf.c:174:20: note: place parentheses around the assignment to silence this warning
 RE(f=ixf(w)); if(b=!f)RZ(f=jope(w,FUPDATE));
                   ^
                  (   )
xf.c:174:20: note: use '==' to turn this assignment into an equality comparison
 RE(f=ixf(w)); if(b=!f)RZ(f=jope(w,FUPDATE));
                   ^
                   ==
xf.c:227:5: warning: implicit declaration of function 'unlink' is invalid in C99 [-Wimplicit-function-declaration]
 R !unlink(CAV(y))||!rmdir(CAV(y))?one:jerrno();
    ^
xf.c:227:22: warning: implicit declaration of function 'rmdir' is invalid in C99 [-Wimplicit-function-declaration]
 R !unlink(CAV(y))||!rmdir(CAV(y))?one:jerrno();
                     ^
xf.c:242:9: warning: implicit declaration of function 'getcwd' is invalid in C99 [-Wimplicit-function-declaration]
 ASSERT(getcwd(path,NPATH),EVFACE);
        ^
./j.h:208:31: note: expanded from macro 'ASSERT'
#define ASSERT(b,e)     {if(!(b)){jsignal(e); R 0;}}
                              ^
xf.c:261:10: warning: implicit declaration of function 'chdir' is invalid in C99 [-Wimplicit-function-declaration]
 ASSERT(!chdir(CAV(w)),EVFACE);
         ^
./j.h:208:31: note: expanded from macro 'ASSERT'
#define ASSERT(b,e)     {if(!(b)){jsignal(e); R 0;}}
                              ^
xf.c:301:7: warning: implicit declaration of function 'getpid' is invalid in C99 [-Wimplicit-function-declaration]
 R(sc(getpid()));
      ^
./ja.h:853:46: note: expanded from macro 'sc'
#define sc(x)                       jtsc(jt,(x))
                                             ^
10 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o xfmt.o xfmt.c
xfmt.c:65:12: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  else if(s=strchr(pp,c)){t=1; p=c; q=qq[s-pp];}
          ~^~~~~~~~~~~~~
xfmt.c:65:12: note: place parentheses around the assignment to silence this warning
  else if(s=strchr(pp,c)){t=1; p=c; q=qq[s-pp];}
           ^
          (             )
xfmt.c:65:12: note: use '==' to turn this assignment into an equality comparison
  else if(s=strchr(pp,c)){t=1; p=c; q=qq[s-pp];}
           ^
           ==
xfmt.c:73:12: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
  else if(s=strchr(pp,c)){t=1; q=qq[s-pp];}
          ~^~~~~~~~~~~~~
xfmt.c:73:12: note: place parentheses around the assignment to silence this warning
  else if(s=strchr(pp,c)){t=1; q=qq[s-pp];}
           ^
          (             )
xfmt.c:73:12: note: use '==' to turn this assignment into an equality comparison
  else if(s=strchr(pp,c)){t=1; q=qq[s-pp];}
           ^
           ==
xfmt.c:81:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(v=memchr(x, SUBd, n)){j=n-(v-x); u-=j; memmove(u+1,v,j); v--;} else v=x+n-1;
    ~^~~~~~~~~~~~~~~~~~~
xfmt.c:81:6: note: place parentheses around the assignment to silence this warning
 if(v=memchr(x, SUBd, n)){j=n-(v-x); u-=j; memmove(u+1,v,j); v--;} else v=x+n-1;
     ^
    (                   )
xfmt.c:81:6: note: use '==' to turn this assignment into an equality comparison
 if(v=memchr(x, SUBd, n)){j=n-(v-x); u-=j; memmove(u+1,v,j); v--;} else v=x+n-1;
     ^
     ==
xfmt.c:141:13: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   else if(s=strchr(pp,c)){mod=0; t=1; p=c; q=qq[s-pp];}
           ~^~~~~~~~~~~~~
xfmt.c:141:13: note: place parentheses around the assignment to silence this warning
   else if(s=strchr(pp,c)){mod=0; t=1; p=c; q=qq[s-pp];}
            ^
           (             )
xfmt.c:141:13: note: use '==' to turn this assignment into an equality comparison
   else if(s=strchr(pp,c)){mod=0; t=1; p=c; q=qq[s-pp];}
            ^
            ==
xfmt.c:148:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
   if(s=strchr(cu1,d)){if(i-mi>3)RZ(zv[s-cu1]=str(i-mi-3,wv+mi+2));}else ASSERT(1==i-mi,EVDOMAIN);
      ~^~~~~~~~~~~~~~
xfmt.c:148:8: note: place parentheses around the assignment to silence this warning
   if(s=strchr(cu1,d)){if(i-mi>3)RZ(zv[s-cu1]=str(i-mi-3,wv+mi+2));}else ASSERT(1==i-mi,EVDOMAIN);
       ^
      (              )
xfmt.c:148:8: note: use '==' to turn this assignment into an equality comparison
   if(s=strchr(cu1,d)){if(i-mi>3)RZ(zv[s-cu1]=str(i-mi-3,wv+mi+2));}else ASSERT(1==i-mi,EVDOMAIN);
       ^
       ==
xfmt.c:515:8: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(lvl=level(w)){A*wv=AAV(w),x;I wd=(I)w*ARELATIVE(w);
    ~~~^~~~~~~~~
xfmt.c:515:8: note: place parentheses around the assignment to silence this warning
 if(lvl=level(w)){A*wv=AAV(w),x;I wd=(I)w*ARELATIVE(w);
       ^
    (           )
xfmt.c:515:8: note: use '==' to turn this assignment into an equality comparison
 if(lvl=level(w)){A*wv=AAV(w),x;I wd=(I)w*ARELATIVE(w);
       ^
       ==
6 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o xh.o xh.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o xi.o xi.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o xl.o xl.c
xl.c:63:5: warning: expression result unused [-Wunused-value]
 RE(j);
    ^
./j.h:248:30: note: expanded from macro 'RE'
#define RE(exp)         {if((exp),jt->jerr)R 0;}
                             ^
1 warning generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o xo.o xo.c
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o xs.o xs.c
xs.c:73:19: warning: '&&' within '||' [-Wlogical-op-parentheses]
 if(a!=mark||AN(x)&&CFF==*CAV(x)){
           ~~~~~~~^~~~~~~~~~~~~~
xs.c:73:19: note: place parentheses around the '&&' expression to silence this warning
 if(a!=mark||AN(x)&&CFF==*CAV(x)){
             ~~~~~^~~~~~~~~~~~~~
1 warning generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o xt.o xt.c
xt.c:157:8: warning: implicit declaration of function 'sleep' is invalid in C99 [-Wimplicit-function-declaration]
 DO(s, sleepms(1000); JBREAK0;);
       ^
xt.c:147:20: note: expanded from macro 'sleepms'
#define sleepms(i) sleep((i+500)/1000)
                   ^
./j.h:218:55: note: expanded from macro 'DO'
#define DO(n,stm)       {I i=0,_n=(n); for(;i<_n;i++){stm}}
                                                      ^
xt.c:224:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(b=u->wrapped){x=v->name; y=v->loc;}
    ~^~~~~~~~~~~
xt.c:224:6: note: place parentheses around the assignment to silence this warning
 if(b=u->wrapped){x=v->name; y=v->loc;}
     ^
    (           )
xt.c:224:6: note: use '==' to turn this assignment into an equality comparison
 if(b=u->wrapped){x=v->name; y=v->loc;}
     ^
     ==
xt.c:280:6: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
 if(x=jt->pma){
    ~^~~~~~~~
xt.c:280:6: note: place parentheses around the assignment to silence this warning
 if(x=jt->pma){
     ^
    (        )
xt.c:280:6: note: use '==' to turn this assignment into an equality comparison
 if(x=jt->pma){
     ^
     ==
3 warnings generated.
cc  -m32  -fPIC -O3 -fno-strict-aliasing -DNOASM     -c -o xu.o xu.c
xu.c:108:14: warning: passing 'C *' (aka 'char *') to parameter of type 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  q=mtowsize(CAV(w),n);
             ^~~~~~
./jtype.h:81:25: note: expanded from macro 'CAV'
#define CAV(x)          (      (C*)(x)+AK(x) )  /* character               */
                        ^~~~~~~~~~~~~~~~~~~~~~
xu.c:32:23: note: passing argument to parameter 'src' here
static I mtowsize(UC* src, I srcn){ US c,c1,c2,cf; I r=0;
                      ^
xu.c:111:8: warning: passing 'C *' (aka 'char *') to parameter of type 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
  mtow(CAV(w),n,(US*)CAV(z));
       ^~~~~~
./jtype.h:81:25: note: expanded from macro 'CAV'
#define CAV(x)          (      (C*)(x)+AK(x) )  /* character               */
                        ^~~~~~~~~~~~~~~~~~~~~~
xu.c:10:22: note: passing argument to parameter 'src' here
static void mtow(UC* src, I srcn, US* snk){ US c,c1,c2;
                     ^
xu.c:136:20: warning: passing 'C *' (aka 'char *') to parameter of type 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
wtom((US*)CAV(w),n,CAV(z));
                   ^~~~~~
./jtype.h:81:25: note: expanded from macro 'CAV'
#define CAV(x)          (      (C*)(x)+AK(x) )  /* character               */
                        ^~~~~~~~~~~~~~~~~~~~~~
xu.c:66:32: note: passing argument to parameter 'snk' here
void wtom(US* src, I srcn, UC* snk){ US w;
                               ^
xu.c:142:12: warning: passing 'C *' (aka 'char *') to parameter of type 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
q=mtowsize(CAV(w),AN(w));
           ^~~~~~
./jtype.h:81:25: note: expanded from macro 'CAV'
#define CAV(x)          (      (C*)(x)+AK(x) )  /* character               */
                        ^~~~~~~~~~~~~~~~~~~~~~
xu.c:32:23: note: passing argument to parameter 'src' here
static I mtowsize(UC* src, I srcn){ US c,c1,c2,cf; I r=0;
                      ^
xu.c:145:6: warning: passing 'C *' (aka 'char *') to parameter of type 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
mtow(CAV(w),AN(w),(US*)CAV(z));
     ^~~~~~
./jtype.h:81:25: note: expanded from macro 'CAV'
#define CAV(x)          (      (C*)(x)+AK(x) )  /* character               */
                        ^~~~~~~~~~~~~~~~~~~~~~
xu.c:10:22: note: passing argument to parameter 'src' here
static void mtow(UC* src, I srcn, US* snk){ US c,c1,c2;
                     ^
xu.c:150:15: warning: implicit declaration of function 'wcslen' is invalid in C99 [-Wimplicit-function-declaration]
q=wtomsize(fw,wcslen(fw));
              ^
xu.c:151:20: warning: passing 'C *' (aka 'char *') to parameter of type 'UC *' (aka 'unsigned char *') converts between pointers to integer types with different sign [-Wpointer-sign]
wtom(fw,wcslen(fw),f);
                   ^
xu.c:66:32: note: passing argument to parameter 'snk' here
void wtom(US* src, I srcn, UC* snk){ US w;
                               ^
7 warnings generated.
cc  a.o ab.o  af.o  ai.o  am.o  am1.o  amn.o  ao.o  ap.o  ar.o  as.o  au.o  c.o  ca.o  cc.o  cd.o  cf.o  cg.o  ch.o  cip.o  cl.o  cp.o  cpdtsp.o  cr.o  crs.o  ct.o  cu.o  cv.o  cx.o  d.o  dc.o  dss.o  dstop.o  dsusp.o dtoa.o f.o f2.o i.o io.o j.o jdlllic.o k.o m.o mbx.o p.o pv.o px.o r.o rl.o rt.o s.o sc.o sl.o sn.o t.o u.o v.o v0.o v1.o v2.o va1.o va2.o va2s.o vamultsp.o vb.o vbang.o vbit.o vcant.o vchar.o vcat.o vcatsp.o vcomp.o vcompsc.o vd.o vdx.o ve.o vf.o vfft.o vfrom.o vfromsp.o vg.o vgauss.o vgcomp.o vgranking.o vgsort.o vgsp.o vi.o viix.o visp.o vm.o vo.o vp.o vq.o vrand.o vrep.o vs.o vsb.o vt.o vu.o vx.o vz.o w.o wc.o wn.o ws.o x.o x15.o xa.o xb.o xc.o xcrc.o xd.o xf.o xfmt.o xh.o xi.o xl.o xo.o xs.o xt.o xu.o    -m32  -dynamiclib -lm -ldl -o   libj.dylib 
